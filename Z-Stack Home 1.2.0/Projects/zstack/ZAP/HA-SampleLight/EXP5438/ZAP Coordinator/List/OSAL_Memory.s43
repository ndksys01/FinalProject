///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.60.5.50814/W32 for MSP430      08/Apr/2014  21:14:16 /
// Copyright 1996-2013 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Texas Instruments\Z-Stack Home                      /
//                     1.2.0\Components\osal\common\OSAL_Memory.c             /
//    Command line  =  -f "C:\Texas Instruments\Z-Stack Home                  /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \Source\zap.cfg" (-DZAP_PHY_SPI=1                      /
//                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE   /
//                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                 /
//                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE              /
//                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE           /
//                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE           /
//                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG           /
//                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC              /
//                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC         /
//                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0        /
//                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000          /
//                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4) -f  /
//                     "C:\Texas Instruments\Z-Stack Home                     /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\Tools\MSP5438\f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE  /
//                     -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF                /
//                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4         /
//                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10        /
//                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10       /
//                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING               /
//                     -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU  /
//                     -DZCL_DEVICE_MGMT) "C:\Texas Instruments\Z-Stack Home  /
//                     1.2.0\Components\osal\common\OSAL_Memory.c" -D         /
//                     FEATURE_GREEN_POWER -D FEATURE_ENHANCED_BEACON -D      /
//                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -lC           /
//                     "C:\Texas Instruments\Z-Stack Home                     /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP   /
//                     Coordinator\List\" -lA "C:\Texas Instruments\Z-Stack   /
//                     Home 1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ /
//                     ZAP Coordinator\List\" --remarks --diag_suppress       /
//                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                   /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\ZAP Coordinator\Obj\" --debug      /
//                     -D__MSP430F5438__ -e --double=32 --clib -I "C:\Texas   /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\" -I "C:\Texas                     /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\Source\" -I "C:\Texas           /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\Source\" -I "C:\Texas        /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\hal\targ /
//                     et\MSP5438ZAP\" -I "C:\Texas Instruments\Z-Stack Home  /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\hal\include\" -I "C:\Texas        /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\mac\incl /
//                     ude\" -I "C:\Texas Instruments\Z-Stack Home            /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\mt\" -I "C:\Texas                 /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\osal\inc /
//                     lude\" -I "C:\Texas Instruments\Z-Stack Home           /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\osal\mcu\msp430\" -I "C:\Texas    /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\services /
//                     \saddr\" -I "C:\Texas Instruments\Z-Stack Home         /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\services\sdata\" -I "C:\Texas     /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\stack\af /
//                     \" -I "C:\Texas Instruments\Z-Stack Home               /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\stack\nwk\" -I "C:\Texas          /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\stack\sa /
//                     pi\" -I "C:\Texas Instruments\Z-Stack Home             /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\stack\sec\" -I "C:\Texas          /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\stack\sy /
//                     s\" -I "C:\Texas Instruments\Z-Stack Home              /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\stack\zcl\" -I "C:\Texas          /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\stack\zd /
//                     o\" -I "C:\Texas Instruments\Z-Stack Home              /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\zmac\" -I "C:\Texas               /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\zmac\f8w /
//                     \" --core=430X --data_model=small -Ohz                 /
//                     --multiplier=32 --multiplier_location=4C0              /
//                     --require_prototypes --hw_workaround=CPU40             /
//                     --hw_workaround=CPU39                                  /
//    List file     =  C:\Texas Instruments\Z-Stack Home                      /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP   /
//                     Coordinator\List\OSAL_Memory.s43                       /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME OSAL_Memory

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC osal_mem_alloc
        FUNCTION osal_mem_alloc,0a1203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC osal_mem_free
        FUNCTION osal_mem_free,0a1203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC osal_mem_init
        FUNCTION osal_mem_init,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC osal_mem_kick
        FUNCTION osal_mem_kick,0a1203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN halAssertHandler
        FUNCTION halAssertHandler,0202H

// C:\Texas Instruments\Z-Stack Home 1.2.0\Components\osal\common\OSAL_Memory.c
//    1 /**************************************************************************************************
//    2   Filename:       OSAL_Memory.c
//    3   Revised:        $Date: 2013-03-14 17:58:51 -0700 (Thu, 14 Mar 2013) $
//    4   Revision:       $Revision: 33490 $
//    5 
//    6   Description:    OSAL Heap Memory management functions. There is an Application Note that
//    7                   should be read before studying and/or modifying this module:
//    8                   SWRA204 "Heap Memory Management"
//    9 
//   10   Copyright 2004-2010 Texas Instruments Incorporated. All rights reserved.
//   11 
//   12   IMPORTANT: Your use of this Software is limited to those specific rights
//   13   granted under the terms of a software license agreement between the user
//   14   who downloaded the software, his/her employer (which must be your employer)
//   15   and Texas Instruments Incorporated (the "License").  You may not use this
//   16   Software unless you agree to abide by the terms of the License. The License
//   17   limits your use, and you acknowledge, that the Software may not be modified,
//   18   copied or distributed unless embedded on a Texas Instruments microcontroller
//   19   or used solely and exclusively in conjunction with a Texas Instruments radio
//   20   frequency transceiver, which is integrated into your product.  Other than for
//   21   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   22   works of, modify, distribute, perform, display or sell this Software and/or
//   23   its documentation for any purpose.
//   24 
//   25   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   26   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   27   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   28   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   29   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   30   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   31   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   32   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   33   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   34   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   35   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   36 
//   37   Should you have any questions regarding your right to use this Software,
//   38   contact Texas Instruments Incorporated at www.TI.com.
//   39 **************************************************************************************************/
//   40 
//   41 /* ------------------------------------------------------------------------------------------------
//   42  *                                          Includes
//   43  * ------------------------------------------------------------------------------------------------
//   44  */
//   45 
//   46 #include "comdef.h"
//   47 #include "OSAL.h"
//   48 #include "OSAL_Memory.h"
//   49 #include "OnBoard.h"
//   50 #include "hal_mcu.h"
//   51 #include "hal_assert.h"
//   52 
//   53 /* ------------------------------------------------------------------------------------------------
//   54  *                                           Constants
//   55  * ------------------------------------------------------------------------------------------------
//   56  */
//   57 
//   58 #define OSALMEM_IN_USE             0x8000
//   59 #if (MAXMEMHEAP & OSALMEM_IN_USE)
//   60 #error MAXMEMHEAP is too big to manage!
//   61 #endif
//   62 
//   63 #define OSALMEM_HDRSZ              sizeof(osalMemHdr_t)
//   64 
//   65 // Round a value up to the ceiling of OSALMEM_HDRSZ for critical dependencies on even multiples.
//   66 #define OSALMEM_ROUND(X)       ((((X) + OSALMEM_HDRSZ - 1) / OSALMEM_HDRSZ) * OSALMEM_HDRSZ)
//   67 
//   68 /* Minimum wasted bytes to justify splitting a block before allocation.
//   69  * Adjust accordingly to attempt to balance the tradeoff of wasted space and runtime throughput
//   70  * spent splitting blocks into sizes that may not be practically usable when sandwiched between
//   71  * two blocks in use (and thereby not able to be coalesced.)
//   72  * Ensure that this size is an even multiple of OSALMEM_HDRSZ.
//   73  */
//   74 #if !defined OSALMEM_MIN_BLKSZ
//   75 #define OSALMEM_MIN_BLKSZ         (OSALMEM_ROUND((OSALMEM_HDRSZ * 2)))
//   76 #endif
//   77 
//   78 #if !defined OSALMEM_LL_BLKSZ
//   79 #if defined NONWK
//   80 #define OSALMEM_LL_BLKSZ          (OSALMEM_ROUND(6) + (1 * OSALMEM_HDRSZ))
//   81 #else
//   82 /*
//   83  * Profiling the sample apps with default settings shows the following long-lived allocations
//   84  * which should live at the bottom of the small-block bucket so that they are never iterated over
//   85  * by osal_mem_alloc/free(), nor ever considered for coalescing, etc. This saves significant
//   86  * run-time throughput (on 8051 SOC if not also MSP). This is dynamic "dead space" and is not
//   87  * available to the small-block bucket heap.
//   88  *
//   89  * Adjust this size accordingly to accomodate application-specific changes including changing the
//   90  * size of long-lived objects profiled by sample apps and long-lived objects added by application.
//   91  */
//   92 #if defined ZCL_KEY_ESTABLISH     // Attempt to capture worst-case for SE sample apps.
//   93 #define OSALMEM_LL_BLKSZ          (OSALMEM_ROUND(526) + (32 * OSALMEM_HDRSZ))
//   94 #elif defined TC_LINKKEY_JOIN
//   95 #define OSALMEM_LL_BLKSZ          (OSALMEM_ROUND(454) + (21 * OSALMEM_HDRSZ))
//   96 #elif ((defined SECURE) && (SECURE != 0))
//   97 #define OSALMEM_LL_BLKSZ          (OSALMEM_ROUND(418) + (19 * OSALMEM_HDRSZ))
//   98 #else
//   99 #define OSALMEM_LL_BLKSZ          (OSALMEM_ROUND(417) + (19 * OSALMEM_HDRSZ))
//  100 #endif
//  101 #endif
//  102 #endif
//  103 
//  104 /* Adjust accordingly to attempt to accomodate the block sizes of the vast majority of
//  105  * very high frequency allocations/frees by profiling the system runtime.
//  106  * This default of 16 accomodates the OSAL timers block, osalTimerRec_t, and many others.
//  107  * Ensure that this size is an even multiple of OSALMEM_MIN_BLKSZ for run-time efficiency.
//  108  */
//  109 #if !defined OSALMEM_SMALL_BLKSZ
//  110 #define OSALMEM_SMALL_BLKSZ       (OSALMEM_ROUND(16))
//  111 #endif
//  112 #if !defined OSALMEM_SMALL_BLKCNT
//  113 #define OSALMEM_SMALL_BLKCNT       8
//  114 #endif
//  115 
//  116 /*
//  117  * These numbers setup the size of the small-block bucket which is reserved at the front of the
//  118  * heap for allocations of OSALMEM_SMALL_BLKSZ or smaller.
//  119  */
//  120 
//  121 // Size of the heap bucket reserved for small block-sized allocations.
//  122 // Adjust accordingly to attempt to accomodate the vast majority of very high frequency operations.
//  123 #define OSALMEM_SMALLBLK_BUCKET  ((OSALMEM_SMALL_BLKSZ * OSALMEM_SMALL_BLKCNT) + OSALMEM_LL_BLKSZ)
//  124 // Index of the first available osalMemHdr_t after the small-block heap which will be set in-use in
//  125 // order to prevent the small-block bucket from being coalesced with the wilderness.
//  126 #define OSALMEM_SMALLBLK_HDRCNT   (OSALMEM_SMALLBLK_BUCKET / OSALMEM_HDRSZ)
//  127 // Index of the first available osalMemHdr_t after the small-block heap which will be set in-use in
//  128 #define OSALMEM_BIGBLK_IDX        (OSALMEM_SMALLBLK_HDRCNT + 1)
//  129 // The size of the wilderness after losing the small-block heap, the wasted header to block the
//  130 // small-block heap from being coalesced, and the wasted header to mark the end of the heap.
//  131 #define OSALMEM_BIGBLK_SZ         (MAXMEMHEAP - OSALMEM_SMALLBLK_BUCKET - OSALMEM_HDRSZ*2)
//  132 // Index of the last available osalMemHdr_t at the end of the heap which will be set to zero for
//  133 // fast comparisons with zero to determine the end of the heap.
//  134 #define OSALMEM_LASTBLK_IDX      ((MAXMEMHEAP / OSALMEM_HDRSZ) - 1)
//  135 
//  136 // For information about memory profiling, refer to SWRA204 "Heap Memory Management", section 1.5.
//  137 #if !defined OSALMEM_PROFILER
//  138 #define OSALMEM_PROFILER           FALSE  // Enable/disable the memory usage profiling buckets.
//  139 #endif
//  140 #if !defined OSALMEM_PROFILER_LL
//  141 #define OSALMEM_PROFILER_LL        FALSE  // Special profiling of the Long-Lived bucket.
//  142 #endif
//  143 
//  144 #if OSALMEM_PROFILER
//  145 #define OSALMEM_INIT              'X'
//  146 #define OSALMEM_ALOC              'A'
//  147 #define OSALMEM_REIN              'F'
//  148 #endif
//  149 
//  150 /* ------------------------------------------------------------------------------------------------
//  151  *                                           Typedefs
//  152  * ------------------------------------------------------------------------------------------------
//  153  */
//  154 
//  155 typedef struct {
//  156   // The 15 LSB's of 'val' indicate the total item size, including the header, in 8-bit bytes.
//  157   unsigned len : 15;
//  158   // The 1 MSB of 'val' is used as a boolean to indicate in-use or freed.
//  159   unsigned inUse : 1;
//  160 } osalMemHdrHdr_t;
//  161 
//  162 typedef union {
//  163   /* Dummy variable so compiler forces structure to alignment of largest element while not wasting
//  164    * space on targets when the halDataAlign_t is smaller than a UINT16.
//  165    */
//  166   halDataAlign_t alignDummy;
//  167   uint16 val;
//  168   osalMemHdrHdr_t hdr;
//  169 } osalMemHdr_t;
//  170 
//  171 /* ------------------------------------------------------------------------------------------------
//  172  *                                           Local Variables
//  173  * ------------------------------------------------------------------------------------------------
//  174  */
//  175 
//  176 #if !defined ( ZBIT )

        RSEG DATA16_N:DATA:SORT:NOROOT(1)
//  177 static __no_init osalMemHdr_t theHeap[MAXMEMHEAP / OSALMEM_HDRSZ];
theHeap:
        DS8 4096

        RSEG DATA16_N:DATA:SORT:NOROOT(1)
//  178 static __no_init osalMemHdr_t *ff1;  // First free block in the small-block bucket.
ff1:
        DS8 2
//  179 #else
//  180 static osalMemHdr_t theHeap[MAXMEMHEAP / OSALMEM_HDRSZ];
//  181 static osalMemHdr_t *ff1;  // First free block in the small-block bucket.
//  182 #endif
//  183 

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  184 static uint8 osalMemStat;            // Discrete status flags: 0x01 = kicked.
osalMemStat:
        DS8 1
//  185 
//  186 #if OSALMEM_METRICS
//  187 static uint16 blkMax;  // Max cnt of all blocks ever seen at once.
//  188 static uint16 blkCnt;  // Current cnt of all blocks.
//  189 static uint16 blkFree; // Current cnt of free blocks.
//  190 static uint16 memAlo;  // Current total memory allocated.
//  191 static uint16 memMax;  // Max total memory ever allocated at once.
//  192 #endif
//  193 
//  194 #if OSALMEM_PROFILER
//  195 #define OSALMEM_PROMAX  8
//  196 /* The profiling buckets must differ by at least OSALMEM_MIN_BLKSZ; the
//  197  * last bucket must equal the max alloc size. Set the bucket sizes to
//  198  * whatever sizes necessary to show how your application is using memory.
//  199  */
//  200 static uint16 proCnt[OSALMEM_PROMAX] = {
//  201 OSALMEM_SMALL_BLKSZ, 48, 112, 176, 192, 224, 256, 65535 };
//  202 static uint16 proCur[OSALMEM_PROMAX] = { 0 };
//  203 static uint16 proMax[OSALMEM_PROMAX] = { 0 };
//  204 static uint16 proTot[OSALMEM_PROMAX] = { 0 };
//  205 static uint16 proSmallBlkMiss;
//  206 #endif
//  207 
//  208 /* ------------------------------------------------------------------------------------------------
//  209  *                                           Global Variables
//  210  * ------------------------------------------------------------------------------------------------
//  211  */
//  212 
//  213 #ifdef DPRINTF_HEAPTRACE
//  214 extern int dprintf(const char *fmt, ...);
//  215 #endif /* DPRINTF_HEAPTRACE */
//  216 
//  217 /**************************************************************************************************
//  218  * @fn          osal_mem_init
//  219  *
//  220  * @brief       This function is the OSAL heap memory management initialization callback.
//  221  *
//  222  * input parameters
//  223  *
//  224  * None.
//  225  *
//  226  * output parameters
//  227  *
//  228  * None.
//  229  *
//  230  * @return      None.
//  231  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  232 void osal_mem_init(void)
osal_mem_init:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function osal_mem_init
//  233 {
//  234   HAL_ASSERT(((OSALMEM_MIN_BLKSZ % OSALMEM_HDRSZ) == 0));
//  235   HAL_ASSERT(((OSALMEM_LL_BLKSZ % OSALMEM_HDRSZ) == 0));
//  236   HAL_ASSERT(((OSALMEM_SMALL_BLKSZ % OSALMEM_HDRSZ) == 0));
//  237 
//  238 #if OSALMEM_PROFILER
//  239   (void)osal_memset(theHeap, OSALMEM_INIT, MAXMEMHEAP);
//  240 #endif
//  241 
//  242   // Setup a NULL block at the end of the heap for fast comparisons with zero.
//  243   theHeap[OSALMEM_LASTBLK_IDX].val = 0;
        MOV.W   #0x0, &theHeap + 4094
//  244 
//  245   // Setup the small-block bucket.
//  246   ff1 = theHeap;
        MOV.W   #theHeap, &ff1
//  247   ff1->val = OSALMEM_SMALLBLK_BUCKET;                   // Set 'len' & clear 'inUse' field.
        MOV.W   #0x248, &theHeap
//  248   // Set 'len' & 'inUse' fields - this is a 'zero data bytes' lifetime allocation to block the
//  249   // small-block bucket from ever being coalesced with the wilderness.
//  250   theHeap[OSALMEM_SMALLBLK_HDRCNT].val = (OSALMEM_HDRSZ | OSALMEM_IN_USE);
        MOV.W   #0x8002, &theHeap + 584
//  251 
//  252   // Setup the wilderness.
//  253   theHeap[OSALMEM_BIGBLK_IDX].val = OSALMEM_BIGBLK_SZ;  // Set 'len' & clear 'inUse' field.
        MOV.W   #0xdb4, &theHeap + 586
//  254 
//  255 #if ( OSALMEM_METRICS )
//  256   /* Start with the small-block bucket and the wilderness - don't count the
//  257    * end-of-heap NULL block nor the end-of-small-block NULL block.
//  258    */
//  259   blkCnt = blkFree = 2;
//  260 #endif
//  261 }
        RETA
          CFI EndBlock cfiBlock0
//  262 
//  263 /**************************************************************************************************
//  264  * @fn          osal_mem_kick
//  265  *
//  266  * @brief       This function is the OSAL task initialization callback.
//  267  * @brief       Kick the ff1 pointer out past the long-lived OSAL Task blocks.
//  268  *              Invoke this once after all long-lived blocks have been allocated -
//  269  *              presently at the end of osal_init_system().
//  270  *
//  271  * input parameters
//  272  *
//  273  * None.
//  274  *
//  275  * output parameters
//  276  *
//  277  * None.
//  278  *
//  279  * @return      None.
//  280  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  281 void osal_mem_kick(void)
osal_mem_kick:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function osal_mem_kick
//  282 {
        FUNCALL osal_mem_kick, osal_mem_alloc
        LOCFRAME CSTACK, 8, STACK
        FUNCALL osal_mem_kick, halAssertHandler
        LOCFRAME CSTACK, 8, STACK
        FUNCALL osal_mem_kick, osal_mem_free
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
//  283   halIntState_t intState;
//  284   osalMemHdr_t *tmp = osal_mem_alloc(1);
        MOV.W   #0x1, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, R10
//  285 
//  286   HAL_ASSERT((tmp != NULL));
        CMP.W   #0x0, R12
        JNE     ??osal_mem_kick_0
        CALLA   #halAssertHandler
//  287   HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
??osal_mem_kick_0:
        MOV.W   SR, R11
        dint
        nop
//  288 
//  289   /* All long-lived allocations have filled the LL block reserved in the small-block bucket.
//  290    * Set 'osalMemStat' so searching for memory in this bucket from here onward will only be done
//  291    * for sizes meeting the OSALMEM_SMALL_BLKSZ criteria.
//  292    */
//  293   ff1 = tmp - 1;       // Set 'ff1' to point to the first available memory after the LL block.
        MOV.W   R10, R15
        SUB.W   #0x2, R15
        MOV.W   R15, &ff1
//  294   osal_mem_free(tmp);
        MOV.W   R10, R12
        CALLA   #osal_mem_free
//  295   osalMemStat = 0x01;  // Set 'osalMemStat' after the free because it enables memory profiling.
        MOV.B   #0x1, &osalMemStat
//  296 
//  297   HAL_EXIT_CRITICAL_SECTION(intState);  // Re-enable interrupts.
        MOV.W   R11, SR
        NOP
//  298 }
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//  299 
//  300 /**************************************************************************************************
//  301  * @fn          osal_mem_alloc
//  302  *
//  303  * @brief       This function implements the OSAL dynamic memory allocation functionality.
//  304  *
//  305  * input parameters
//  306  *
//  307  * @param size - the number of bytes to allocate from the HEAP.
//  308  *
//  309  * output parameters
//  310  *
//  311  * None.
//  312  *
//  313  * @return      None.
//  314  */
//  315 #ifdef DPRINTF_OSALHEAPTRACE
//  316 void *osal_mem_alloc_dbg( uint16 size, const char *fname, unsigned lnum )
//  317 #else /* DPRINTF_OSALHEAPTRACE */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  318 void *osal_mem_alloc( uint16 size )
osal_mem_alloc:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function osal_mem_alloc
//  319 #endif /* DPRINTF_OSALHEAPTRACE */
//  320 {
        FUNCALL osal_mem_alloc, halAssertHandler
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
//  321   osalMemHdr_t *prev = NULL;
        MOV.W   #0x0, R11
//  322   osalMemHdr_t *hdr;
//  323   halIntState_t intState;
//  324   uint8 coal = 0;
        MOV.B   #0x0, R8
//  325 
//  326   size += OSALMEM_HDRSZ;
        ADD.W   #0x2, R12
//  327 
//  328   // Calculate required bytes to add to 'size' to align to halDataAlign_t.
//  329   if ( sizeof( halDataAlign_t ) == 2 )
//  330   {
//  331     size += (size & 0x01);
        MOV.W   R12, R15
        AND.W   #0x1, R15
        ADD.W   R15, R12
//  332   }
//  333   else if ( sizeof( halDataAlign_t ) != 1 )
//  334   {
//  335     const uint8 mod = size % sizeof( halDataAlign_t );
//  336 
//  337     if ( mod != 0 )
//  338     {
//  339       size += (sizeof( halDataAlign_t ) - mod);
//  340     }
//  341   }
//  342 
//  343   HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
        MOV.W   SR, R14
        dint
        nop
//  344 
//  345   // Smaller allocations are first attempted in the small-block bucket, and all long-lived
//  346   // allocations are channeled into the LL block reserved within this bucket.
//  347   if ((osalMemStat == 0) || (size <= OSALMEM_SMALL_BLKSZ))
        CMP.B   #0x0, &osalMemStat
        JEQ     ??osal_mem_alloc_2
        CMP.W   #0x11, R12
        JC      ??osal_mem_alloc_3
//  348   {
//  349     hdr = ff1;
??osal_mem_alloc_2:
        MOV.W   &ff1, R10
        JMP     ??osal_mem_alloc_1
//  350   }
//  351   else
//  352   {
//  353     hdr = (theHeap + OSALMEM_BIGBLK_IDX);
??osal_mem_alloc_3:
        MOV.W   #theHeap + 586, R10
//  354   }
//  355 
//  356   do
//  357   {
//  358     if ( hdr->hdr.inUse )
??osal_mem_alloc_1:
        MOV.W   #0x7fff, R13
        CMP.W   #0x0, 0(R10)
        JGE     ??osal_mem_alloc_4
//  359     {
//  360       coal = 0;
        MOV.B   #0x0, R8
        JMP     ??osal_mem_alloc_5
//  361     }
//  362     else
//  363     {
//  364       if ( coal != 0 )
??osal_mem_alloc_4:
        BIT.B   #0x1, R8
        JNC     ??osal_mem_alloc_6
//  365       {
//  366 #if ( OSALMEM_METRICS )
//  367         blkCnt--;
//  368         blkFree--;
//  369 #endif
//  370 
//  371         prev->hdr.len += hdr->hdr.len;
        MOV.W   @R11, R15
        MOV.W   R15, R9
        ADD.W   @R10, R9
        AND.W   R13, R9
        AND.W   #0x8000, R15
        BIS.W   R9, R15
        MOV.W   R15, 0(R11)
//  372 
//  373         if ( prev->hdr.len >= size )
        AND.W   R13, R15
        CMP.W   R12, R15
        JNC     ??osal_mem_alloc_5
//  374         {
//  375           hdr = prev;
        MOV.W   R11, R10
//  376           break;
//  377         }
//  378       }
//  379       else
//  380       {
//  381         if ( hdr->hdr.len >= size )
//  382         {
//  383           break;
//  384         }
//  385 
//  386         coal = 1;
//  387         prev = hdr;
//  388       }
//  389     }
//  390 
//  391     hdr = (osalMemHdr_t *)((uint8 *)hdr + hdr->hdr.len);
//  392 
//  393     if ( hdr->val == 0 )
//  394     {
//  395       hdr = NULL;
//  396       break;
//  397     }
//  398   } while (1);
//  399 
//  400   if ( hdr != NULL )
??osal_mem_alloc_0:
        CMP.W   #0x0, R10
        JEQ     ??osal_mem_alloc_7
//  401   {
//  402     uint16 tmp = hdr->hdr.len - size;
        MOV.W   R13, R11
        AND.W   @R10, R11
        SUB.W   R12, R11
//  403 
//  404     // Determine whether the threshold for splitting is met.
//  405     if ( tmp >= OSALMEM_MIN_BLKSZ )
        CMP.W   #0x4, R11
        JNC     ??osal_mem_alloc_8
//  406     {
//  407       // Split the block before allocating it.
//  408       osalMemHdr_t *next = (osalMemHdr_t *)((uint8 *)hdr + size);
//  409       next->val = tmp;                     // Set 'len' & clear 'inUse' field.
        MOV.W   R10, R15
        ADD.W   R12, R15
        MOV.W   R11, 0(R15)
//  410       hdr->val = (size | OSALMEM_IN_USE);  // Set 'len' & 'inUse' field.
        BIS.W   #0x8000, R12
        MOV.W   R12, 0(R10)
        JMP     ??osal_mem_alloc_9
//  411 
//  412 #if ( OSALMEM_METRICS )
//  413       blkCnt++;
//  414       if ( blkMax < blkCnt )
//  415       {
//  416         blkMax = blkCnt;
//  417       }
//  418       memAlo += size;
//  419 #endif
//  420     }
??osal_mem_alloc_6:
        MOV.W   R13, R15
        AND.W   @R10, R15
        CMP.W   R12, R15
        JC      ??osal_mem_alloc_0
        MOV.B   #0x1, R8
        MOV.W   R10, R11
??osal_mem_alloc_5:
        AND.W   @R10, R13
        ADD.W   R13, R10
        CMP.W   #0x0, 0(R10)
        JNE     ??osal_mem_alloc_1
        MOV.W   #0x0, R10
        JMP     ??osal_mem_alloc_7
//  421     else
//  422     {
//  423 #if ( OSALMEM_METRICS )
//  424       memAlo += hdr->hdr.len;
//  425       blkFree--;
//  426 #endif
//  427 
//  428       hdr->hdr.inUse = TRUE;
??osal_mem_alloc_8:
        BIS.W   #0x8000, 0(R10)
//  429     }
//  430 
//  431 #if ( OSALMEM_METRICS )
//  432     if ( memMax < memAlo )
//  433     {
//  434       memMax = memAlo;
//  435     }
//  436 #endif
//  437 
//  438 #if ( OSALMEM_PROFILER )
//  439 #if !OSALMEM_PROFILER_LL
//  440     if (osalMemStat != 0)  // Don't profile until after the LL block is filled.
//  441 #endif
//  442     {
//  443       uint8 idx;
//  444 
//  445       for ( idx = 0; idx < OSALMEM_PROMAX; idx++ )
//  446       {
//  447         if ( hdr->hdr.len <= proCnt[idx] )
//  448         {
//  449           break;
//  450         }
//  451       }
//  452       proCur[idx]++;
//  453       if ( proMax[idx] < proCur[idx] )
//  454       {
//  455         proMax[idx] = proCur[idx];
//  456       }
//  457       proTot[idx]++;
//  458 
//  459       /* A small-block could not be allocated in the small-block bucket.
//  460        * When this occurs significantly frequently, increase the size of the
//  461        * bucket in order to restore better worst case run times. Set the first
//  462        * profiling bucket size in proCnt[] to the small-block bucket size and
//  463        * divide proSmallBlkMiss by the corresponding proTot[] size to get % miss.
//  464        * Best worst case time on TrasmitApp was achieved at a 0-15% miss rate
//  465        * during steady state Tx load, 0% during idle and steady state Rx load.
//  466        */
//  467       if ((hdr->hdr.len <= OSALMEM_SMALL_BLKSZ) && (hdr >= (theHeap + OSALMEM_BIGBLK_IDX)))
//  468       {
//  469         proSmallBlkMiss++;
//  470       }
//  471     }
//  472 
//  473     (void)osal_memset((uint8 *)(hdr+1), OSALMEM_ALOC, (hdr->hdr.len - OSALMEM_HDRSZ));
//  474 #endif
//  475 
//  476     if ((osalMemStat != 0) && (ff1 == hdr))
??osal_mem_alloc_9:
        CMP.B   #0x0, &osalMemStat
        JEQ     ??osal_mem_alloc_10
        CMP.W   R10, &ff1
        JNE     ??osal_mem_alloc_10
//  477     {
//  478       ff1 = (osalMemHdr_t *)((uint8 *)hdr + hdr->hdr.len);
        AND.W   @R10, R13
        MOV.W   R10, R15
        ADD.W   R13, R15
        MOV.W   R15, &ff1
//  479     }
//  480 
//  481     hdr++;
??osal_mem_alloc_10:
        ADD.W   #0x2, R10
//  482   }
//  483 
//  484   HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
??osal_mem_alloc_7:
        MOV.W   R14, SR
        NOP
//  485 
//  486 #if !defined ( ZBIT )
//  487 #pragma diag_suppress=Pe767
//  488   HAL_ASSERT(((halDataAlign_t)hdr % sizeof(halDataAlign_t)) == 0);
        BIT.B   #0x1, R10
        JEQ     ??osal_mem_alloc_11
        CALLA   #halAssertHandler
//  489 #pragma diag_default=Pe767
//  490 #else
//  491   HAL_ASSERT(((halDataAlign_t)hdr % sizeof(halDataAlign_t)) == 0);
//  492 #endif
//  493 #ifdef DPRINTF_OSALHEAPTRACE
//  494   dprintf("osal_mem_alloc(%u)->%lx:%s:%u\n", size, (unsigned) hdr, fname, lnum);
//  495 #endif /* DPRINTF_OSALHEAPTRACE */
//  496   return (void *)hdr;
??osal_mem_alloc_11:
        MOV.W   R10, R12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
//  497 }
//  498 
//  499 /**************************************************************************************************
//  500  * @fn          osal_mem_free
//  501  *
//  502  * @brief       This function implements the OSAL dynamic memory de-allocation functionality.
//  503  *
//  504  * input parameters
//  505  *
//  506  * @param ptr - A valid pointer (i.e. a pointer returned by osal_mem_alloc()) to the memory to free.
//  507  *
//  508  * output parameters
//  509  *
//  510  * None.
//  511  *
//  512  * @return      None.
//  513  */
//  514 #ifdef DPRINTF_OSALHEAPTRACE
//  515 void osal_mem_free_dbg(void *ptr, const char *fname, unsigned lnum)
//  516 #else /* DPRINTF_OSALHEAPTRACE */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  517 void osal_mem_free(void *ptr)
osal_mem_free:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function osal_mem_free
//  518 #endif /* DPRINTF_OSALHEAPTRACE */
//  519 {
        FUNCALL osal_mem_free, halAssertHandler
        LOCFRAME CSTACK, 6, STACK
        FUNCALL osal_mem_free, halAssertHandler
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
//  520   osalMemHdr_t *hdr = (osalMemHdr_t *)ptr - 1;
        MOV.W   R12, R10
        SUB.W   #0x2, R10
//  521   halIntState_t intState;
//  522 
//  523 #ifdef DPRINTF_OSALHEAPTRACE
//  524   dprintf("osal_mem_free(%lx):%s:%u\n", (unsigned) ptr, fname, lnum);
//  525 #endif /* DPRINTF_OSALHEAPTRACE */
//  526 
//  527   HAL_ASSERT(((uint8 *)ptr >= (uint8 *)theHeap) && ((uint8 *)ptr < (uint8 *)theHeap+MAXMEMHEAP));
        CMP.W   #theHeap, R12
        JNC     ??osal_mem_free_0
        CMP.W   #theHeap + 4096, R12
        JNC     ??osal_mem_free_1
??osal_mem_free_0:
        CALLA   #halAssertHandler
//  528   HAL_ASSERT(hdr->hdr.inUse);
??osal_mem_free_1:
        CMP.W   #0x0, 0(R10)
        JL      ??osal_mem_free_2
        CALLA   #halAssertHandler
//  529 
//  530   HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
??osal_mem_free_2:
        MOV.W   SR, R14
        dint
        nop
//  531   hdr->hdr.inUse = FALSE;
        BIC.W   #0x8000, 0(R10)
//  532 
//  533   if (ff1 > hdr)
        CMP.W   &ff1, R10
        JC      ??osal_mem_free_3
//  534   {
//  535     ff1 = hdr;
        MOV.W   R10, &ff1
//  536   }
//  537 
//  538 #if OSALMEM_PROFILER
//  539 #if !OSALMEM_PROFILER_LL
//  540   if (osalMemStat != 0)  // Don't profile until after the LL block is filled.
//  541 #endif
//  542   {
//  543     uint8 idx;
//  544 
//  545     for (idx = 0; idx < OSALMEM_PROMAX; idx++)
//  546     {
//  547       if (hdr->hdr.len <= proCnt[idx])
//  548       {
//  549         break;
//  550       }
//  551     }
//  552 
//  553     proCur[idx]--;
//  554   }
//  555 
//  556   (void)osal_memset((uint8 *)(hdr+1), OSALMEM_REIN, (hdr->hdr.len - OSALMEM_HDRSZ) );
//  557 #endif
//  558 #if OSALMEM_METRICS
//  559   memAlo -= hdr->hdr.len;
//  560   blkFree++;
//  561 #endif
//  562 
//  563   HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
??osal_mem_free_3:
        MOV.W   R14, SR
        NOP
//  564 }
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
//  565 
//  566 #if OSALMEM_METRICS
//  567 /*********************************************************************
//  568  * @fn      osal_heap_block_max
//  569  *
//  570  * @brief   Return the maximum number of blocks ever allocated at once.
//  571  *
//  572  * @param   none
//  573  *
//  574  * @return  Maximum number of blocks ever allocated at once.
//  575  */
//  576 uint16 osal_heap_block_max( void )
//  577 {
//  578   return blkMax;
//  579 }
//  580 
//  581 /*********************************************************************
//  582  * @fn      osal_heap_block_cnt
//  583  *
//  584  * @brief   Return the current number of blocks now allocated.
//  585  *
//  586  * @param   none
//  587  *
//  588  * @return  Current number of blocks now allocated.
//  589  */
//  590 uint16 osal_heap_block_cnt( void )
//  591 {
//  592   return blkCnt;
//  593 }
//  594 
//  595 /*********************************************************************
//  596  * @fn      osal_heap_block_free
//  597  *
//  598  * @brief   Return the current number of free blocks.
//  599  *
//  600  * @param   none
//  601  *
//  602  * @return  Current number of free blocks.
//  603  */
//  604 uint16 osal_heap_block_free( void )
//  605 {
//  606   return blkFree;
//  607 }
//  608 
//  609 /*********************************************************************
//  610  * @fn      osal_heap_mem_used
//  611  *
//  612  * @brief   Return the current number of bytes allocated.
//  613  *
//  614  * @param   none
//  615  *
//  616  * @return  Current number of bytes allocated.
//  617  */
//  618 uint16 osal_heap_mem_used( void )
//  619 {
//  620   return memAlo;
//  621 }
//  622 #endif
//  623 
//  624 #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
//  625 /*********************************************************************
//  626  * @fn      osal_heap_high_water
//  627  *
//  628  * @brief   Return the highest byte ever allocated in the heap.
//  629  *
//  630  * @param   none
//  631  *
//  632  * @return  Highest number of bytes ever used by the stack.
//  633  */
//  634 uint16 osal_heap_high_water( void )
//  635 {
//  636 #if ( OSALMEM_METRICS )
//  637   return memMax;
//  638 #else
//  639   return MAXMEMHEAP;
//  640 #endif
//  641 }
//  642 #endif
//  643 
//  644 /**************************************************************************************************
//  645 */
// 
//   334 bytes in segment CODE
// 4 098 bytes in segment DATA16_N
//     1 byte  in segment DATA16_Z
// 
//   334 bytes of CODE memory
// 4 099 bytes of DATA memory
//
//Errors: none
//Warnings: none
