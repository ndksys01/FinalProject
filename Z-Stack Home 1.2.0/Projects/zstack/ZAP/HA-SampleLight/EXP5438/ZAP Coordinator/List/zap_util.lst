###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.60.5.50814/W32 for MSP430       08/Apr/2014  21:14:20 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\Z-Stack Home                       #
#                     1.2.0\Projects\zstack\ZAP\Source\zap_util.c             #
#    Command line  =  -f "C:\Texas Instruments\Z-Stack Home                   #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     Source\zap.cfg" (-DZAP_PHY_SPI=1                        #
#                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE    #
#                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                  #
#                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE               #
#                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE            #
#                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4) -f   #
#                     "C:\Texas Instruments\Z-Stack Home                      #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\Tools\MSP5438\f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE    #
#                     -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF                 #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU                 #
#                     -DZCL_DEVICE_MGMT) "C:\Texas Instruments\Z-Stack Home   #
#                     1.2.0\Projects\zstack\ZAP\Source\zap_util.c" -D         #
#                     FEATURE_GREEN_POWER -D FEATURE_ENHANCED_BEACON -D       #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -lC "C:\Texas  #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\ZAP Coordinator\List\" -lA           #
#                     "C:\Texas Instruments\Z-Stack Home                      #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP    #
#                     Coordinator\List\" --remarks --diag_suppress            #
#                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                    #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\ZAP Coordinator\Obj\" --debug        #
#                     -D__MSP430F5438__ -e --double=32 --clib -I "C:\Texas    #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\" -I "C:\Texas Instruments\Z-Stack   #
#                     Home 1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\. #
#                     .\Source\" -I "C:\Texas Instruments\Z-Stack Home        #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     Source\" -I "C:\Texas Instruments\Z-Stack Home          #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\hal\target\MSP5438ZAP\" -I          #
#                     "C:\Texas Instruments\Z-Stack Home                      #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\hal\include\" -I "C:\Texas          #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\mac\includ #
#                     e\" -I "C:\Texas Instruments\Z-Stack Home               #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\mt\" -I "C:\Texas                   #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\osal\inclu #
#                     de\" -I "C:\Texas Instruments\Z-Stack Home              #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\osal\mcu\msp430\" -I "C:\Texas      #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\services\s #
#                     addr\" -I "C:\Texas Instruments\Z-Stack Home            #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\services\sdata\" -I "C:\Texas       #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\stack\af\" #
#                      -I "C:\Texas Instruments\Z-Stack Home                  #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\stack\nwk\" -I "C:\Texas            #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\stack\sapi #
#                     \" -I "C:\Texas Instruments\Z-Stack Home                #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\stack\sec\" -I "C:\Texas            #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\stack\sys\ #
#                     " -I "C:\Texas Instruments\Z-Stack Home                 #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\stack\zcl\" -I "C:\Texas            #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\stack\zdo\ #
#                     " -I "C:\Texas Instruments\Z-Stack Home                 #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\zmac\" -I "C:\Texas                 #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\zmac\f8w\" #
#                      --core=430X --data_model=small -Ohz --multiplier=32    #
#                     --multiplier_location=4C0 --require_prototypes          #
#                     --hw_workaround=CPU40 --hw_workaround=CPU39             #
#    List file     =  C:\Texas Instruments\Z-Stack Home                       #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP    #
#                     Coordinator\List\zap_util.lst                           #
#    Object file   =  C:\Texas Instruments\Z-Stack Home                       #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP    #
#                     Coordinator\Obj\zap_util.r43                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\Source\zap_util.c
      1          /**************************************************************************************************
      2              Filename:       zap_util.c
      3              Revised:        $Date: 2013-11-15 17:25:09 -0800 (Fri, 15 Nov 2013) $
      4              Revision:       $Revision: 36131 $
      5          
      6              Description:
      7          
      8              This file declares the ZNP Application Processor UTIL API functions.
      9          
     10          
     11              Copyright 2010-2013 Texas Instruments Incorporated. All rights reserved.
     12          
     13              IMPORTANT: Your use of this Software is limited to those specific rights
     14              granted under the terms of a software license agreement between the user
     15              who downloaded the software, his/her employer (which must be your employer)
     16              and Texas Instruments Incorporated (the "License"). You may not use this
     17              Software unless you agree to abide by the terms of the License. The License
     18              limits your use, and you acknowledge, that the Software may not be modified,
     19              copied or distributed unless embedded on a Texas Instruments microcontroller
     20              or used solely and exclusively in conjunction with a Texas Instruments radio
     21              frequency transceiver, which is integrated into your product. Other than for
     22              the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23              works of, modify, distribute, perform, display or sell this Software and/or
     24              its documentation for any purpose.
     25          
     26              YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27              PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28              INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29              NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30              TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31              NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32              LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33              INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34              OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35              OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36              (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38              Should you have any questions regarding your right to use this Software,
     39              contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /* ------------------------------------------------------------------------------------------------
     43           *                                          Includes
     44           * ------------------------------------------------------------------------------------------------
     45           */
     46          
     47          #include "AddrMgr.h"
     48          #include "hal_board.h"
     49          #include "mt.h"
     50          #include "mt_rpc.h"
     51          #include "OSAL.h"
     52          #include "zap_app.h"
     53          #include "zap_phy.h"
     54          #include "zap_znp.h"
     55          #if defined ZCL_KEY_ESTABLISH
     56          #include "zcl_key_establish.h"
     57          #include "zcl_se.h"
     58          #endif
     59          #include "ZComDef.h"
     60          
     61          /* ------------------------------------------------------------------------------------------------
     62           *                                           Constants
     63           * ------------------------------------------------------------------------------------------------
     64           */
     65          

   \                                 In  segment DATA16_C, align 1, align-sorted
     66          const uint8 nullAddr[Z_EXTADDR_LEN] = { 0,0,0,0,0,0,0,0 };
   \                     nullAddr:
   \   000000   000000000000 DC8 0, 0, 0, 0, 0, 0, 0, 0
   \            0000        
     67          
     68          /* ------------------------------------------------------------------------------------------------
     69           *                                           Typedefs
     70           * ------------------------------------------------------------------------------------------------
     71           */
     72          
     73          /* ------------------------------------------------------------------------------------------------
     74           *                                           Macros
     75           * ------------------------------------------------------------------------------------------------
     76           */
     77          
     78          /* ------------------------------------------------------------------------------------------------
     79           *                                           Global Variables
     80           * ------------------------------------------------------------------------------------------------
     81           */
     82          
     83          /* ------------------------------------------------------------------------------------------------
     84           *                                           Local Variables
     85           * ------------------------------------------------------------------------------------------------
     86           */
     87          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     88          static associated_devices_t assocDevT;
   \                     assocDevT:
   \   000000                DS8 22

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     89          static BindingEntry_t bindEntryT;
   \                     bindEntryT:
   \   000000                DS8 14
     90          
     91          /* ------------------------------------------------------------------------------------------------
     92           *                                           Local Functions
     93           * ------------------------------------------------------------------------------------------------
     94           */
     95          
     96          static uint8 zapUtilParseAssocDevT(uint8 *pBuf);
     97          static uint8 zapUtilParseBindEntryT(uint8 *pBuf);
     98          #if defined ZCL_KEY_ESTABLISH
     99          static void zapUtilParseKeyInd(uint8 *pBuf);
    100          #endif
    101          
    102          #if defined (ZAP_UTIL_FUNC)
    103          /**************************************************************************************************
    104           * @fn          zapUtilProcessIncoming
    105           *
    106           * @brief       This function processes the UTIL sub-system response from the ZNP.
    107           *
    108           * input parameters
    109           *
    110           * @param       port - Port Id corresponding to the ZNP that sent the message.
    111           * @param       pBuf - A pointer to the RPC response.
    112           *
    113           * output parameters
    114           *
    115           * None.
    116           *
    117           * @return      None.
    118           **************************************************************************************************
    119           */

   \                                 In  segment CODE, align 2
    120          void zapUtilProcessIncoming(uint8 port, uint8 *pBuf)
   \                     zapUtilProcessIncoming:
    121          {
    122            uint8 cmd1 = pBuf[MT_RPC_POS_CMD1];
    123            pBuf += MT_RPC_FRAME_HDR_SZ;
    124          
    125            switch (cmd1)
   \   000000   FD90E0000200 CMP.B   #0xe0, 0x2(R13)
   \   000006   0220         JNE     ??zapUtilProcessIncoming_0
    126            {
    127            case MT_UTIL_SYNC_REQ:
    128              zapGotSync(port);
   \   000008   ........     CALLA   #zapGotSync
    129              break;
    130          
    131          #if defined ZCL_KEY_ESTABLISH
    132            case MT_UTIL_ZCL_KEY_ESTABLISH_IND:
    133              zapUtilParseKeyInd(pBuf);
    134              break;
    135          #endif
    136          
    137            default:
    138              break;
    139            }
    140          }
   \                     ??zapUtilProcessIncoming_0:
   \   00000C   1001         RETA
    141          #endif
    142          
    143          /**************************************************************************************************
    144           * @fn          AddrMgrEntryLookupNwk
    145           *
    146           * @brief       Lookup entry based on NWK address.
    147           *
    148           * input parameters
    149           *
    150           * @param       entry
    151           *                ::nwkAddr - [in] NWK address
    152           *
    153           * output parameters
    154           *
    155           * @param       entry
    156           *                ::extAddr - [out] EXT address
    157           *
    158           * @return      uint8 - success(TRUE:FALSE)
    159           **************************************************************************************************
    160           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   2153         ADD.W   #0x2, SP
   \   000002   3A41         POP.W   R10
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   7C404100     MOV.B   #0x41, R12
   \   000004                REQUIRE ??Subroutine1_0
   \   000004                // Fall through to label ??Subroutine1_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine1_0:
   \   000000   ........     CALLA   #zapUtilReq
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
    161          uint8 AddrMgrEntryLookupNwk(AddrMgrEntry_t* entry)
   \                     AddrMgrEntryLookupNwk:
    162          {
   \   000000   0A12         PUSH.W  R10
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4C         MOV.W   R12, R10
    163            uint8 args[2] = { LO_UINT16(entry->nwkAddr), HI_UINT16(entry->nwkAddr) };
   \   000006   D14C02000000 MOV.B   0x2(R12), 0(SP)
   \   00000C   D14C03000100 MOV.B   0x3(R12), 0x1(SP)
    164          
    165            if (SUCCESS == zapUtilReq(MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP, entry->extAddr, args))
   \   000012   0E41         MOV.W   SP, R14
   \   000014   0E53         ADD.W   #0x0, R14
   \   000016   0D4C         MOV.W   R12, R13
   \   000018   2D52         ADD.W   #0x4, R13
   \   00001A   ........     CALLA   #?Subroutine1
   \                     ??CrossCallReturnLabel_3:
   \   00001E   3E42         MOV.W   #0x8, R14
   \   000020   0620         JNE     ??AddrMgrEntryLookupNwk_4
    166            {
    167              return ((osal_memcmp(nullAddr, entry->extAddr, Z_EXTADDR_LEN)) ? FALSE : TRUE);
   \   000022   2A52         ADD.W   #0x4, R10
   \   000024   ........     CALLA   #?Subroutine2
    168            }
   \                     ??CrossCallReturnLabel_1:
   \   000028   0720         JNE     ??AddrMgrEntryLookupNwk_3
   \   00002A   5C43         MOV.B   #0x1, R12
   \   00002C   063C         JMP     ??AddrMgrEntryLookupNwk_1
    169            else
    170            {
    171              (void)osal_memset(entry->extAddr, 0, Z_EXTADDR_LEN);
   \                     ??AddrMgrEntryLookupNwk_4:
   \   00002E   4D43         MOV.B   #0x0, R13
   \   000030   2A52         ADD.W   #0x4, R10
   \   000032   0C4A         MOV.W   R10, R12
   \   000034   ........     CALLA   #osal_memset
    172              return FALSE;
   \                     ??AddrMgrEntryLookupNwk_3:
   \   000038   4C43         MOV.B   #0x0, R12
    173            }
   \                     ??AddrMgrEntryLookupNwk_1:
   \   00003A   ....         JMP     ?Subroutine0
   \   00003C   0343         NOP
    174          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   0D4A         MOV.W   R10, R13
   \   000002   3C40....     MOV.W   #nullAddr, R12
   \   000006   ........     CALLA   #osal_memcmp
   \   00000A   4C93         CMP.B   #0x0, R12
   \   00000C   1001         RETA
    175          
    176          /**************************************************************************************************
    177           * @fn          AddrMgrExtAddrLookup
    178           *
    179           * @brief       Lookup EXT address using the NWK address.
    180           *
    181           * input parameters
    182           *
    183           * @param       nwkAddr - [in] NWK address
    184           *
    185           * output parameters
    186           *
    187           * @param       extAddr - [out] EXT address
    188           *
    189           * @return      uint8 - success(TRUE:FALSE)
    190           **************************************************************************************************
    191           */

   \                                 In  segment CODE, align 2, keep-with-next
    192          uint8 AddrMgrExtAddrLookup(uint16 nwkAddr, uint8* extAddr)
   \                     AddrMgrExtAddrLookup:
    193          {
   \   000000   0A12         PUSH.W  R10
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4D         MOV.W   R13, R10
    194            uint8 args[2] = { LO_UINT16(nwkAddr), HI_UINT16(nwkAddr) };
   \   000006   C14C0000     MOV.B   R12, 0(SP)
   \   00000A                RPT     #0x8
   \   00000A   47190C10     RRUX.W  R12
   \   00000E   C14C0100     MOV.B   R12, 0x1(SP)
    195          
    196            if (SUCCESS == zapUtilReq(MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP, extAddr, args))
   \   000012   0E41         MOV.W   SP, R14
   \   000014   0E53         ADD.W   #0x0, R14
   \   000016   ........     CALLA   #?Subroutine1
   \                     ??CrossCallReturnLabel_2:
   \   00001A   3E42         MOV.W   #0x8, R14
   \   00001C   0520         JNE     ??AddrMgrExtAddrLookup_4
    197            {
    198              return ((osal_memcmp(nullAddr, extAddr, Z_EXTADDR_LEN)) ? FALSE : TRUE);
   \   00001E   ........     CALLA   #?Subroutine2
    199            }
   \                     ??CrossCallReturnLabel_0:
   \   000022   0620         JNE     ??AddrMgrExtAddrLookup_3
   \   000024   5C43         MOV.B   #0x1, R12
   \   000026   053C         JMP     ??AddrMgrExtAddrLookup_1
    200            else
    201            {
    202              (void)osal_memset(extAddr, 0, Z_EXTADDR_LEN);
   \                     ??AddrMgrExtAddrLookup_4:
   \   000028   4D43         MOV.B   #0x0, R13
   \   00002A   0C4A         MOV.W   R10, R12
   \   00002C   ........     CALLA   #osal_memset
    203              return FALSE;
   \                     ??AddrMgrExtAddrLookup_3:
   \   000030   4C43         MOV.B   #0x0, R12
    204            }
   \                     ??AddrMgrExtAddrLookup_1:
   \   000032   ....         JMP     ?Subroutine0
   \   000034   0343         NOP
    205          }
    206          
    207          /**************************************************************************************************
    208           * @fn          AddrMgrExtAddrSet
    209           *
    210           * @brief       Set destination address to source address or empty{0x00}.
    211           *
    212           * input parameters
    213           *
    214           * @param       dstExtAddr - Pointer to the buffer to which to copy.
    215           * @param       srcExtAddr - Pointer to the buffer from which to copy.
    216           *
    217           * output parameters
    218           *
    219           * @param       dstExtAddr - Pointer to the buffer to which to copy.
    220           *
    221           * @return      None.
    222           **************************************************************************************************
    223           */

   \                                 In  segment CODE, align 2, keep-with-next
    224          void AddrMgrExtAddrSet(uint8 *dstExtAddr, uint8 *srcExtAddr)
   \                     AddrMgrExtAddrSet:
    225          {
    226            if ( srcExtAddr != NULL )
   \   000000   0D93         CMP.W   #0x0, R13
   \   000002   0224         JEQ     ??AddrMgrExtAddrSet_0
    227            {
    228              osal_cpyExtAddr( dstExtAddr, srcExtAddr );
   \   000004   ........     BRA     #sAddrExtCpy
    229            }
    230            else
    231            {
    232              osal_memset( dstExtAddr, 0x00, Z_EXTADDR_LEN );
   \                     ??AddrMgrExtAddrSet_0:
   \   000008   3E42         MOV.W   #0x8, R14
   \   00000A   4D43         MOV.B   #0x0, R13
   \   00000C   ........     BRA     #osal_memset
    233            }
    234          }
    235          
    236          /**************************************************************************************************
    237           * @fn          AssocCount()
    238           *
    239           * @brief       Counts the number of entries in the device list.
    240           *
    241           * input parameters
    242           *
    243           * @param       startRelation - Device relation to start counting at.
    244           * @param       endRelation - Device relation to end counting at.
    245           *
    246           * output parameters
    247           *
    248           * None.
    249           *
    250           * @return      The number of devices within the relation parameters.
    251           **************************************************************************************************
    252           */

   \                                 In  segment CODE, align 2, keep-with-next
    253          uint16 AssocCount(uint8 startRelation, uint8 endRelation)
   \                     AssocCount:
    254          {
   \   000000   0A12         PUSH.W  R10
   \   000002   2183         SUB.W   #0x2, SP
    255            uint16 count = 0;
   \   000004   0A43         MOV.W   #0x0, R10
    256            uint8 pBuf[2] = { startRelation, endRelation };
   \   000006   C14C0000     MOV.B   R12, 0(SP)
   \   00000A   C14D0100     MOV.B   R13, 0x1(SP)
    257          
    258            if (SUCCESS == zapUtilReq(MT_UTIL_ASSOC_COUNT, pBuf, NULL))
   \   00000E   0E43         MOV.W   #0x0, R14
   \   000010   0D41         MOV.W   SP, R13
   \   000012   0D53         ADD.W   #0x0, R13
   \   000014   7C404800     MOV.B   #0x48, R12
   \   000018   ........     CALLA   #??Subroutine1_0
   \                     ??CrossCallReturnLabel_7:
   \   00001C   0620         JNE     ??AssocCount_0
    259            {
    260              count = BUILD_UINT16(pBuf[0], pBuf[1]);
   \   00001E   6A41         MOV.B   @SP, R10
   \   000020   5F410100     MOV.B   0x1(SP), R15
   \   000024                RPT     #0x8
   \   000024   47180F5F     RLAX.W  R15
   \   000028   0A5F         ADD.W   R15, R10
    261            }
    262          
    263            return count;
   \                     ??AssocCount_0:
   \   00002A   0C4A         MOV.W   R10, R12
   \   00002C                REQUIRE ?Subroutine0
   \   00002C                // Fall through to label ?Subroutine0
    264          }
    265          
    266          /**************************************************************************************************
    267           * @fn          AssocFindDevice()
    268           *
    269           * @brief       Finds Nth active entry in the device list.
    270           *
    271           * input parameters
    272           *
    273           * @param       number - Device index where 0 = first.
    274           *
    275           * output parameters
    276           *
    277           * None.
    278           *
    279           * @return      A pointer to associated_devices_t if device found, NULL if operation failed.
    280           **************************************************************************************************
    281           */

   \                                 In  segment CODE, align 2
    282          associated_devices_t *AssocFindDevice(uint16 number)
   \                     AssocFindDevice:
    283          {
   \   000000   31801800     SUB.W   #0x18, SP
    284            uint8 pBuf[sizeof(associated_devices_t)];
    285          
    286            /* ZNP can only handle one-byte index */
    287            if ( number < 256 )
   \   000004   3C900001     CMP.W   #0x100, R12
   \   000008   142C         JC      ??AssocFindDevice_0
    288            {
    289              uint8 index = number;
   \   00000A   C14C0000     MOV.B   R12, 0(SP)
    290          
    291              if ((SUCCESS == zapUtilReq(MT_UTIL_ASSOC_FIND_DEVICE, pBuf, &index)) &&
    292                  (SUCCESS == zapUtilParseAssocDevT(pBuf)))
   \   00000E   0E41         MOV.W   SP, R14
   \   000010   0E53         ADD.W   #0x0, R14
   \   000012   0D41         MOV.W   SP, R13
   \   000014   1D53         ADD.W   #0x1, R13
   \   000016   7C404900     MOV.B   #0x49, R12
   \   00001A   ........     CALLA   #??Subroutine1_0
   \                     ??CrossCallReturnLabel_6:
   \   00001E   0920         JNE     ??AssocFindDevice_0
   \   000020   0C41         MOV.W   SP, R12
   \   000022   1C53         ADD.W   #0x1, R12
   \   000024   ........     CALLA   #zapUtilParseAssocDevT
   \   000028   4C93         CMP.B   #0x0, R12
   \   00002A   0320         JNE     ??AssocFindDevice_0
    293              {
    294                return &assocDevT;
   \   00002C   3C40....     MOV.W   #assocDevT, R12
   \   000030   013C         JMP     ??AssocFindDevice_1
    295              }
    296            }
    297          
    298            return NULL;
   \                     ??AssocFindDevice_0:
   \   000032   0C43         MOV.W   #0x0, R12
   \                     ??AssocFindDevice_1:
   \   000034   31501800     ADD.W   #0x18, SP
   \   000038   1001         RETA
    299          }
    300          
    301          /**************************************************************************************************
    302           * @fn          AssocGetWithShort()
    303           *
    304           * @brief       Search the Device list using shortAddr.
    305           *
    306           * input parameters
    307           *
    308           * @param       shortAddr - look for this short address
    309           *
    310           * output parameters
    311           *
    312           * None.
    313           *
    314           * @return      A pointer to associated_devices_t if device found, NULL if operation failed.
    315           **************************************************************************************************
    316           */

   \                                 In  segment CODE, align 2
    317          associated_devices_t *AssocGetWithShort(uint16 shortAddr)
   \                     AssocGetWithShort:
    318          {
   \   000000   31801600     SUB.W   #0x16, SP
    319            uint8 pBuf[sizeof(associated_devices_t)];
    320            assocDevT.shortAddr = shortAddr;
   \   000004   824C....     MOV.W   R12, &assocDevT
    321          
    322            if ((SUCCESS == zapUtilReq(MT_UTIL_ASSOC_GET_WITH_ADDRESS, pBuf, NULL)) &&
    323                (SUCCESS == zapUtilParseAssocDevT(pBuf)))
   \   000008   0E43         MOV.W   #0x0, R14
   \   00000A   0D41         MOV.W   SP, R13
   \   00000C   0D53         ADD.W   #0x0, R13
   \   00000E   7C404A00     MOV.B   #0x4a, R12
   \   000012   ........     CALLA   #??Subroutine1_0
   \                     ??CrossCallReturnLabel_5:
   \   000016   0920         JNE     ??AssocGetWithShort_0
   \   000018   0C41         MOV.W   SP, R12
   \   00001A   0C53         ADD.W   #0x0, R12
   \   00001C   ........     CALLA   #zapUtilParseAssocDevT
   \   000020   4C93         CMP.B   #0x0, R12
   \   000022   0320         JNE     ??AssocGetWithShort_0
    324            {
    325              return &assocDevT;
   \   000024   3C40....     MOV.W   #assocDevT, R12
   \   000028   013C         JMP     ??AssocGetWithShort_1
    326            }
    327            else
    328            {
    329              return NULL;
   \                     ??AssocGetWithShort_0:
   \   00002A   0C43         MOV.W   #0x0, R12
   \                     ??AssocGetWithShort_1:
   \   00002C   31501600     ADD.W   #0x16, SP
   \   000030   1001         RETA
    330            }
    331          }
    332          
    333          /**************************************************************************************************
    334           * @fn          NLME_GetCoordShortAddr
    335           *
    336           * @brief       This function is a ZAP-side proxy for a Z-Stack accessor function. The
    337           *              concurrency of the information is assured by the ZAP task which queries the current
    338           *              values on a ZDO state change notification.
    339           *
    340           * input parameters
    341           *
    342           * None.
    343           *
    344           * output parameters
    345           *
    346           * None.
    347           *
    348           * @return      The ZigBee network address of the ZNP's parent device.
    349           **************************************************************************************************
    350           */

   \                                 In  segment CODE, align 2
    351          uint16 NLME_GetCoordShortAddr(void)
   \                     NLME_GetCoordShortAddr:
    352          {
    353            return znpParent;
   \   000000   1C42....     MOV.W   &znpParent, R12
   \   000004   1001         RETA
    354          }
    355          
    356          /**************************************************************************************************
    357           * @fn          NLME_GetExtAddr
    358           *
    359           * @brief       This function will return a pointer to the ZNP's IEEE 64-bit address.
    360           *
    361           * input parameters
    362           *
    363           * None.
    364           *
    365           * output parameters
    366           *
    367           * None.
    368           *
    369           * @return      Pointer to the ZNP 64-bit address.
    370           **************************************************************************************************
    371           */

   \                                 In  segment CODE, align 2
    372          uint8 *NLME_GetExtAddr(void)
   \                     NLME_GetExtAddr:
    373          {
    374            return znpIEEE;
   \   000000   3C40....     MOV.W   #znpIEEE, R12
   \   000004   1001         RETA
    375          }
    376          
    377          /**************************************************************************************************
    378           * @fn          NLME_GetShortAddr
    379           *
    380           * @brief       This function is a ZAP-side proxy for a Z-Stack accessor function. The
    381           *              concurrency of the information is assured by the ZAP task which queries the current
    382           *              values on a ZDO state change notification.
    383           *
    384           * input parameters
    385           *
    386           * None.
    387           *
    388           * output parameters
    389           *
    390           * None.
    391           *
    392           * @return      The ZigBee network address of the ZNP.
    393           **************************************************************************************************
    394           */

   \                                 In  segment CODE, align 2
    395          uint16 NLME_GetShortAddr(void)
   \                     NLME_GetShortAddr:
    396          {
    397            return znpAddr;
   \   000000   1C42....     MOV.W   &znpAddr, R12
   \   000004   1001         RETA
    398          }
    399          
    400          /**************************************************************************************************
    401           * @fn          NLME_RemoveChild
    402           *
    403           * @brief       This function is a ZAP-side proxy for a Z-Stack function to remove a child
    404           *              device and optionally re-use its network address.
    405           *
    406           * input parameters
    407           *
    408           * @param       newRate = number of milliseconds to do next poll.
    409           *                        0 will turn off the polling.
    410           *                        1 will do a one time poll.
    411           *
    412           * output parameters
    413           *
    414           * None.
    415           *
    416           * @return      None.
    417           **************************************************************************************************
    418           *
    419          void NLME_RemoveChild(uint8 *extAddr, uint8 dealloc)
    420          {
    421            (void)zapUtilReq(MT_NLME_REMOVE_CHILD, extAddr, &dealloc);
    422          }*/
    423          
    424          /**************************************************************************************************
    425           * @fn          NLME_SetPollRate
    426           *
    427           * @brief       This function is a ZAP-side proxy for a Z-Stack function to immediately set
    428           *              the poll rate of the ZNP.
    429           *
    430           * input parameters
    431           *
    432           * @param       newRate = number of milliseconds to do next poll.
    433           *                        0 will turn off the polling.
    434           *                        1 will do a one time poll.
    435           *
    436           * output parameters
    437           *
    438           * None.
    439           *
    440           * @return      None.
    441           **************************************************************************************************
    442           */

   \                                 In  segment CODE, align 2
    443          void NLME_SetPollRate(uint16 newRate)
   \                     NLME_SetPollRate:
    444          {
   \   000000   0C12         PUSH.W  R12
    445            (void)znp_nv_write(ZCD_NV_POLL_RATE, 0, 2, (uint8 *)(&newRate));
   \   000002   0F41         MOV.W   SP, R15
   \   000004   0F53         ADD.W   #0x0, R15
   \   000006   6E43         MOV.B   #0x2, R14
   \   000008   4D43         MOV.B   #0x0, R13
   \   00000A   3C402400     MOV.W   #0x24, R12
   \   00000E   ........     CALLA   #znp_nv_write
    446          }
   \   000012   2153         ADD.W   #0x2, SP
   \   000014   1001         RETA
    447          
    448          /**************************************************************************************************
    449           * @fn          NLME_PermitJoiningRequest
    450           *
    451           * @brief       This function is a ZAP-side proxy for a Z-Stack function to immediately set
    452           *              the coordinator device to permit devices to join its network for a fixed period.
    453           *
    454           * input parameters
    455           *
    456           * @param       PermitDuration - Length of time to allow for associates
    457           *                               0x00 - macAssociationPermit = FALSE
    458           *                               0xFF - macAssociationPermit = TRUE
    459           *                               0x01 - 0xFE number of seconds to remain
    460           *                                  TRUE.
    461           *
    462           * output parameters
    463           *
    464           * None.
    465           *
    466           * @return      ZStatus_t
    467           **************************************************************************************************
    468           */

   \                                 In  segment CODE, align 2
    469          ZStatus_t NLME_PermitJoiningRequest( byte PermitDuration )
   \                     NLME_PermitJoiningRequest:
    470          {
   \   000000   31800A00     SUB.W   #0xa, SP
    471            uint8 rtrn;
    472            zAddrType_t dstAddrLocal;
    473          
    474            dstAddrLocal.addr.shortAddr = NLME_GetShortAddr();
   \   000004   9142....0000 MOV.W   &znpAddr, 0(SP)
    475            dstAddrLocal.addrMode = afAddr16Bit;
   \   00000A   E1430800     MOV.B   #0x2, 0x8(SP)
    476          
    477            rtrn = ZDP_MgmtPermitJoinReq( &dstAddrLocal, PermitDuration, TRUE, FALSE );
    478          
    479            return (ZStatus_t)rtrn;
   \   00000E   4F43         MOV.B   #0x0, R15
   \   000010   5E43         MOV.B   #0x1, R14
   \   000012   4D4C         MOV.B   R12, R13
   \   000014   0C41         MOV.W   SP, R12
   \   000016   0C53         ADD.W   #0x0, R12
   \   000018   ........     CALLA   #ZDP_MgmtPermitJoinReq
   \   00001C   31500A00     ADD.W   #0xa, SP
   \   000020   1001         RETA
    480          }
    481          
    482          /**************************************************************************************************
    483           * @fn      bindAddEntry()
    484           *
    485           * @brief   This function is a ZAP-side proxy for a Z-Stack function to
    486           *          Add an entry to the binding table
    487           *
    488           * input parameters
    489           *
    490           * @param       srcEpInt - source endpoint
    491           * @param       dstAddr - destination Address
    492           * @param       dstEpInt - destination endpoint
    493           * @param       numClusterIds - number of cluster Ids in the list
    494           * @param       clusterIds - pointer to the Object ID list
    495           *
    496           * output parameters
    497           *
    498           * None.
    499           *
    500           * @return  pointer to binding table entry, NULL if not added
    501           **************************************************************************************************
    502           */

   \                                 In  segment CODE, align 2
    503          BindingEntry_t *bindAddEntry( byte srcEpInt,
   \                     bindAddEntry:
    504                                        zAddrType_t *dstAddr, byte dstEpInt,
    505                                        byte numClusterIds, uint16 *clusterIds )
    506          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   4B4C         MOV.B   R12, R11
   \   000006   094D         MOV.W   R13, R9
   \   000008   484E         MOV.B   R14, R8
   \   00000A   4A4F         MOV.B   R15, R10
    507            uint8 *pData = NULL;
    508            uint8 *pBuf;
    509            uint8 len;
    510          
    511            len = 1 + sizeof(zAddrType_t) + 1 + 1 + ( numClusterIds * sizeof(uint16) );
   \   00000C   4C4F         MOV.B   R15, R12
   \   00000E   4C5C         RLA.B   R12
   \   000010   7C500D00     ADD.B   #0xd, R12
   \   000014   C14C0000     MOV.B   R12, 0(SP)
    512          
    513            pData = (uint8 *)osal_mem_alloc( len );
   \   000018   ........     CALLA   #osal_mem_alloc
   \   00001C   064C         MOV.W   R12, R6
    514          
    515            if ( pData != NULL )
   \   00001E   0C93         CMP.W   #0x0, R12
   \   000020   3D24         JEQ     ??bindAddEntry_0
    516            {
    517              pBuf = pData;
   \   000022   074C         MOV.W   R12, R7
    518          
    519              *pBuf++ = srcEpInt;
   \   000024   CC4B0000     MOV.B   R11, 0(R12)
   \   000028   1753         ADD.W   #0x1, R7
    520              *pBuf++ = dstAddr->addrMode;
   \   00002A   D74908000000 MOV.B   0x8(R9), 0(R7)
   \   000030   1753         ADD.W   #0x1, R7
    521          
    522              if ( dstAddr->addrMode == Addr64Bit )
   \   000032   F99003000800 CMP.B   #0x3, 0x8(R9)
   \   000038   0520         JNE     ??bindAddEntry_1
    523              {
    524                osal_cpyExtAddr( pBuf, dstAddr->addr.extAddr );
   \   00003A   0D49         MOV.W   R9, R13
   \   00003C   0C47         MOV.W   R7, R12
   \   00003E   ........     CALLA   #sAddrExtCpy
   \   000042   093C         JMP     ??bindAddEntry_2
    525              }
    526              else
    527              {
    528                *pBuf++ = LO_UINT16( dstAddr->addr.shortAddr );
   \                     ??bindAddEntry_1:
   \   000044   E7490000     MOV.B   @R9, 0(R7)
   \   000048   1753         ADD.W   #0x1, R7
    529                *pBuf++ = HI_UINT16( dstAddr->addr.shortAddr );
   \   00004A   D74901000000 MOV.B   0x1(R9), 0(R7)
   \   000050   1753         ADD.W   #0x1, R7
    530                pBuf += ( Z_EXTADDR_LEN - 2);
   \   000052   37500600     ADD.W   #0x6, R7
    531              }
    532          
    533              *pBuf++ = dstEpInt;
   \                     ??bindAddEntry_2:
   \   000056   C7480000     MOV.B   R8, 0(R7)
   \   00005A   1753         ADD.W   #0x1, R7
    534              *pBuf++ = numClusterIds;
   \   00005C   C74A0000     MOV.B   R10, 0(R7)
   \   000060   1753         ADD.W   #0x1, R7
    535              osal_memcpy( pBuf, clusterIds, numClusterIds * sizeof(uint16) );
   \   000062   4E4A         MOV.B   R10, R14
   \   000064   0E5E         RLA.W   R14
   \   000066   1D411200     MOV.W   0x12(SP), R13
   \   00006A   0C47         MOV.W   R7, R12
   \   00006C   ........     CALLA   #osal_memcpy
    536          
    537              if ( ( SUCCESS == zapUtilReq( MT_UTIL_BIND_ADD_ENTRY, pData, &len ) ) &&
    538                   ( SUCCESS == zapUtilParseBindEntryT( pData ) ) )
   \   000070   0E41         MOV.W   SP, R14
   \   000072   0E53         ADD.W   #0x0, R14
   \   000074   0D46         MOV.W   R6, R13
   \   000076   7C404D00     MOV.B   #0x4d, R12
   \   00007A   ........     CALLA   #??Subroutine1_0
   \                     ??CrossCallReturnLabel_4:
   \   00007E   0B20         JNE     ??bindAddEntry_3
   \   000080   0C46         MOV.W   R6, R12
   \   000082   ........     CALLA   #zapUtilParseBindEntryT
   \   000086   4C93         CMP.B   #0x0, R12
   \   000088   0620         JNE     ??bindAddEntry_3
    539              {
    540                osal_mem_free( pData );
   \   00008A   0C46         MOV.W   R6, R12
   \   00008C   ........     CALLA   #osal_mem_free
    541          
    542                return &bindEntryT;
   \   000090   3C40....     MOV.W   #bindEntryT, R12
   \   000094   043C         JMP     ??bindAddEntry_4
    543              }
    544          
    545              osal_mem_free( pData );
   \                     ??bindAddEntry_3:
   \   000096   0C46         MOV.W   R6, R12
   \   000098   ........     CALLA   #osal_mem_free
    546            }
    547          
    548            return NULL;
   \                     ??bindAddEntry_0:
   \   00009C   0C43         MOV.W   #0x0, R12
   \                     ??bindAddEntry_4:
   \   00009E   2153         ADD.W   #0x2, SP
   \   0000A0   5617         POPM.W  #0x6, R11
   \   0000A2   1001         RETA
    549          }
    550          
    551          #if defined ZCL_KEY_ESTABLISH
    552          /**************************************************************************************************
    553           * @fn          zclGeneral_KeyEstablish_InitiateKeyEstablishment
    554           *
    555           *
    556           * @brief       This function is a ZAP-side proxy for a Z-Stack function to initiate
    557           *              key establishment with partner device.
    558           *
    559           * input parameters
    560           *
    561           * @param       appTaskID - task ID of the application that initates the key establish
    562           * @param       partnerAddr - short address and endpoint of the partner to establish key with
    563           * @param       seqNum - pointer to the sequence number of application (ZCL)
    564           *
    565           * output parameters
    566           *
    567           * None.
    568           *
    569           * @return      ZStatus_t ZSuccess or ZFailure
    570           **************************************************************************************************
    571           */
    572          ZStatus_t zclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 appTaskID,
    573                                                                     afAddrType_t *partnerAddr, uint8 seqNum)
    574          {
    575            uint8 req[12], rtrn;
    576          
    577            req[0] = appTaskID;
    578            req[1] = seqNum;
    579            req[2] = partnerAddr->endPoint;
    580            req[3] = partnerAddr->addrMode;
    581            if (afAddr64Bit == partnerAddr->addrMode)
    582            {
    583              (void)osal_memcpy(req+4, partnerAddr->addr.extAddr, Z_EXTADDR_LEN);
    584            }
    585            else
    586            {
    587              req[4] = LO_UINT16(partnerAddr->addr.shortAddr);
    588              req[5] = HI_UINT16(partnerAddr->addr.shortAddr);
    589            }
    590          
    591            zapPhyWait(zapAppPort, ZCL_KEY_EST_INIT_EST_WAIT);
    592            rtrn = zapUtilReq(MT_UTIL_ZCL_KEY_EST_INIT_EST, req, NULL);
    593            zapPhyWait(zapAppPort, 0);
    594            return rtrn;
    595          }
    596          
    597          /**************************************************************************************************
    598           * @fn          zclGeneral_KeyEstablishment_ECDSASign
    599           *
    600           * @brief       This function is a ZAP-side proxy for a Z-Stack function to creates an
    601           *              ECDSA signature of a message digest.
    602           *
    603           * input parameters
    604           *
    605           * @param       input - input data buffer
    606           * @param       inputLen - byte length of the input buffer
    607           * @param       output - output buffer (21x2 bytes: SE_PROFILE_SIGNATURE_LENGTH).
    608           *
    609           * output parameters
    610           *
    611           * None.
    612           *
    613           * @return      ZStatus_t - success.
    614           **************************************************************************************************
    615           */
    616          ZStatus_t zclGeneral_KeyEstablishment_ECDSASign(uint8 *input, uint8 inputLen, uint8 *output)
    617          {
    618            uint8 rtrn, *pBuf;
    619          
    620          #if defined SECURE
    621            if (SE_PROFILE_SIGNATURE_LENGTH > inputLen)
    622            {
    623              pBuf = output;
    624              (void)osal_memcpy(pBuf, input, inputLen);
    625            }
    626            else
    627            {
    628              pBuf = input;
    629            }
    630          
    631            rtrn = zapUtilReq(MT_UTIL_ZCL_KEY_EST_SIGN, pBuf, &inputLen);
    632          
    633            if (SE_PROFILE_SIGNATURE_LENGTH <= inputLen)
    634            {
    635              (void)osal_memcpy(output, pBuf, SE_PROFILE_SIGNATURE_LENGTH);
    636            }
    637          #endif
    638          
    639            return rtrn;
    640          }
    641          #endif
    642          
    643          #if SECURE
    644          /**************************************************************************************************
    645           * @fn          APSME_LinkKeyDataGet
    646           *
    647           *
    648           * @brief       This function is a ZAP-side proxy for a Z-Stack function to get the
    649           *              APS Link Key NV ID for a specified extended address.
    650           *
    651           * input parameters
    652           *
    653           * @param       extAddr - [in] EXT address
    654           *
    655           * output parameters
    656           *
    657           * @param       data    - [out] pKeyNvId
    658           *
    659           * @return      ZStatus_t
    660           **************************************************************************************************
    661           */
    662          ZStatus_t APSME_LinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
    663          {
    664            // query for the APS Link Key NV id
    665            if (SUCCESS == zapUtilReq(MT_UTIL_APSME_LINK_KEY_NV_ID_GET, extAddr, (uint8 *)pKeyNvId))
    666            {
    667              return ZSuccess;
    668            }
    669            else
    670            {
    671              return ZNwkUnknownDevice;
    672            }
    673          }
    674          
    675          
    676          /******************************************************************************
    677           * @fn          APSME_IsLinkKeyValid
    678           *
    679           * @brief       Verifies if Link Key in NV has been set.
    680           *
    681           * @param       extAddr - [in] EXT address
    682           *
    683           * @return      TRUE - Link Key has been established
    684           *              FALSE - Link Key in NV has default value.
    685           */
    686          uint8 APSME_IsLinkKeyValid(uint8* extAddr)
    687          {
    688            APSME_LinkKeyData_t *pKeyData = NULL;
    689            uint8 nullKey[SEC_KEY_LEN];
    690            uint8 status = FALSE;
    691            uint8 ret;
    692          
    693            // initialize default vealue to compare to
    694            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
    695          
    696            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
    697          
    698            if (pKeyData != NULL)
    699            {
    700              ret = zapUtilReq(MT_UTIL_APSME_LINK_KEY_DATA_GET, extAddr, (uint8 *)pKeyData);
    701          
    702              if (ret == SUCCESS)
    703              {
    704                // if stored key is different than default value, then a key has been established
    705                if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
    706                {
    707                  status = TRUE;
    708                }
    709              }
    710            }
    711          
    712            return status;
    713          }
    714          #endif
    715          
    716          /**************************************************************************************************
    717           * @fn          zapUtilReq
    718           *
    719           * @brief       This function packs and sends an RPC NWK request.
    720           *
    721           * input parameters
    722           *
    723           * @param       cmd - A valid NWK command.
    724           * @param       req - A buffer containing the contents of the request/response, or NULL.
    725           * @param       args - Valid argument(s) corresponding to the NWK command.
    726           *
    727           * output parameters
    728           *
    729           * @param       req - The buffer filled with the contents or success of a response.
    730           * @param       args - The buffer filled with the contents or success of a response.
    731           *
    732           * @return      SUCCESS or FAILURE.
    733           **************************************************************************************************
    734           */

   \                                 In  segment CODE, align 2
    735          uint8 zapUtilReq(uint8 cmd, uint8 *req, uint8 *args)
   \                     zapUtilReq:
    736          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   494C         MOV.B   R12, R9
   \   000006   0B4D         MOV.W   R13, R11
   \   000008   084E         MOV.W   R14, R8
    737            uint8 len, cmd0 = (uint8)MT_RPC_CMD_SREQ;
   \   00000A   7D402000     MOV.B   #0x20, R13
    738            uint8 rtrn = SUCCESS;
    739            uint8 *pBuf;
    740          
    741            if (DEV_STATE_INVALID <= devState)
   \   00000E   F290FC00.... CMP.B   #0xfc, &devState
   \   000014   282C         JC      ??zapUtilReq_0
    742            {
    743              return FAILURE;
    744            }
    745          
    746            switch (cmd)
   \   000016   4E4C         MOV.B   R12, R14
   \   000018   7E804100     SUB.B   #0x41, R14
   \   00001C   1124         JEQ     ??zapUtilReq_2
   \   00001E   7E800700     SUB.B   #0x7, R14
   \   000022   0E24         JEQ     ??zapUtilReq_2
   \   000024   5E83         SUB.B   #0x1, R14
   \   000026   0E24         JEQ     ??zapUtilReq_3
   \   000028   5E83         SUB.B   #0x1, R14
   \   00002A   0724         JEQ     ??zapUtilReq_4
   \   00002C   7E800300     SUB.B   #0x3, R14
   \   000030   0B24         JEQ     ??zapUtilReq_5
   \   000032   7E809300     SUB.B   #0x93, R14
   \   000036   0A24         JEQ     ??zapUtilReq_6
   \   000038   163C         JMP     ??zapUtilReq_0
    747            {
    748            // SREQ's to ZNP.
    749          
    750            case MT_UTIL_ASSOC_GET_WITH_ADDRESS:
    751              len = Z_EXTADDR_LEN + 2;
   \                     ??zapUtilReq_4:
   \   00003A   7A400A00     MOV.B   #0xa, R10
    752              break;
   \   00003E   093C         JMP     ??zapUtilReq_7
    753          
    754            case MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP:
    755            case MT_UTIL_ASSOC_COUNT:
    756              len = 2;
   \                     ??zapUtilReq_2:
   \   000040   6A43         MOV.B   #0x2, R10
    757              break;
   \   000042   073C         JMP     ??zapUtilReq_7
    758          
    759          #if SECURE
    760            case MT_UTIL_APSME_LINK_KEY_DATA_GET:
    761              len = Z_EXTADDR_LEN;
    762              break;
    763          
    764            case MT_UTIL_APSME_LINK_KEY_NV_ID_GET:
    765              len = Z_EXTADDR_LEN;
    766              break;
    767          #endif
    768          
    769            case MT_UTIL_ASSOC_FIND_DEVICE:
    770              len = 1;
   \                     ??zapUtilReq_3:
   \   000044   5A43         MOV.B   #0x1, R10
    771              break;
   \   000046   053C         JMP     ??zapUtilReq_7
    772          
    773          #if defined ZCL_KEY_ESTABLISH
    774            case MT_UTIL_ZCL_KEY_EST_INIT_EST:
    775              len = 12;
    776              break;
    777          
    778            case MT_UTIL_ZCL_KEY_EST_SIGN:
    779              len = *args +1;
    780              break;
    781          #endif
    782          
    783            case MT_UTIL_BIND_ADD_ENTRY:
    784              len = *args;
   \                     ??zapUtilReq_5:
   \   000048   6A48         MOV.B   @R8, R10
    785              break;
   \   00004A   033C         JMP     ??zapUtilReq_7
    786          
    787            // AREQ's to ZNP.
    788          
    789            case MT_UTIL_SYNC_REQ:
    790              cmd0 = (uint8)MT_RPC_CMD_AREQ;
   \                     ??zapUtilReq_6:
   \   00004C   7D404000     MOV.B   #0x40, R13
    791              len = 0;
   \   000050   4A43         MOV.B   #0x0, R10
    792              break;
    793          
    794            default:
    795              return FAILURE;
    796            }
    797            cmd0 |= (uint8)MT_RPC_SYS_UTIL;
    798          
    799            if (NULL == (pBuf = zap_msg_allocate(len, cmd0, cmd)))
   \                     ??zapUtilReq_7:
   \   000052   4E4C         MOV.B   R12, R14
   \   000054   7DD00700     BIS.B   #0x7, R13
   \   000058   4C4A         MOV.B   R10, R12
   \   00005A   ........     CALLA   #zap_msg_allocate
   \   00005E   814C0000     MOV.W   R12, 0(SP)
   \   000062   0C93         CMP.W   #0x0, R12
   \   000064   0220         JNE     ??zapUtilReq_8
    800            {
    801              return FAILURE;
   \                     ??zapUtilReq_0:
   \   000066   5C43         MOV.B   #0x1, R12
   \   000068   5D3C         JMP     ??zapUtilReq_9
    802            }
    803          
    804            switch (cmd)
   \                     ??zapUtilReq_8:
   \   00006A   4E49         MOV.B   R9, R14
   \   00006C   7E804100     SUB.B   #0x41, R14
   \   000070   0B24         JEQ     ??zapUtilReq_10
   \   000072   7E800700     SUB.B   #0x7, R14
   \   000076   0E24         JEQ     ??zapUtilReq_11
   \   000078   5E83         SUB.B   #0x1, R14
   \   00007A   0E24         JEQ     ??zapUtilReq_12
   \   00007C   5E83         SUB.B   #0x1, R14
   \   00007E   0F24         JEQ     ??zapUtilReq_13
   \   000080   7E800300     SUB.B   #0x3, R14
   \   000084   1F24         JEQ     ??zapUtilReq_14
   \   000086   223C         JMP     ??zapUtilReq_15
    805            {
    806            // SREQ's to ZNP.
    807          
    808            case MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP:
    809              pBuf[0] = *args++;
   \                     ??zapUtilReq_10:
   \   000088   FC480000     MOV.B   @R8+, 0(R12)
    810              pBuf[1] = *args;
   \   00008C   2F41         MOV.W   @SP, R15
   \   00008E   EF480100     MOV.B   @R8, 0x1(R15)
    811              break;
   \   000092   1C3C         JMP     ??zapUtilReq_15
    812          
    813          #if SECURE
    814            case MT_UTIL_APSME_LINK_KEY_DATA_GET:
    815              (void)osal_memcpy(pBuf, req, Z_EXTADDR_LEN);
    816              break;
    817          
    818            case MT_UTIL_APSME_LINK_KEY_NV_ID_GET:
    819              (void)osal_memcpy(pBuf, req, Z_EXTADDR_LEN);
    820              break;
    821          #endif
    822          
    823            case MT_UTIL_ASSOC_COUNT:
    824              (void)osal_memcpy(pBuf, req, 2);
   \                     ??zapUtilReq_11:
   \   000094   2E43         MOV.W   #0x2, R14
   \   000096   173C         JMP     ??zapUtilReq_16
    825              break;
    826          
    827            case MT_UTIL_ASSOC_FIND_DEVICE:
    828              pBuf[0] = *args;
   \                     ??zapUtilReq_12:
   \   000098   EC480000     MOV.B   @R8, 0(R12)
    829              break;
   \   00009C   173C         JMP     ??zapUtilReq_15
    830          
    831            case MT_UTIL_ASSOC_GET_WITH_ADDRESS:
    832              if (NULL == args)
   \                     ??zapUtilReq_13:
   \   00009E   0893         CMP.W   #0x0, R8
   \   0000A0   3E42         MOV.W   #0x8, R14
   \   0000A2   0420         JNE     ??zapUtilReq_17
    833              {
    834                (void)osal_memset(pBuf, 0, Z_EXTADDR_LEN);
   \   0000A4   4D43         MOV.B   #0x0, R13
   \   0000A6   ........     CALLA   #osal_memset
   \   0000AA   033C         JMP     ??zapUtilReq_18
    835              }
    836              else
    837              {
    838                (void)osal_memcpy(pBuf, args, Z_EXTADDR_LEN);
   \                     ??zapUtilReq_17:
   \   0000AC   0D48         MOV.W   R8, R13
   \   0000AE   ........     CALLA   #osal_memcpy
    839              }
    840              pBuf[Z_EXTADDR_LEN] = LO_UINT16(assocDevT.shortAddr);
   \                     ??zapUtilReq_18:
   \   0000B2   2F41         MOV.W   @SP, R15
   \   0000B4   DF42....0800 MOV.B   &assocDevT, 0x8(R15)
    841              pBuf[Z_EXTADDR_LEN+1] = HI_UINT16(assocDevT.shortAddr);
   \   0000BA   2F41         MOV.W   @SP, R15
   \   0000BC   DF42....0900 MOV.B   &assocDevT + 1, 0x9(R15)
    842              break;
   \   0000C2   043C         JMP     ??zapUtilReq_15
    843          
    844          #if defined ZCL_KEY_ESTABLISH
    845            case MT_UTIL_ZCL_KEY_EST_INIT_EST:
    846              (void)osal_memcpy(pBuf, req, 12);
    847              break;
    848          
    849            case MT_UTIL_ZCL_KEY_EST_SIGN:
    850              *pBuf = *args;
    851              (void)osal_memcpy(pBuf+1, req, *args);
    852              break;
    853          #endif
    854          
    855            case MT_UTIL_BIND_ADD_ENTRY:
    856              (void)osal_memcpy(pBuf, req, len);
   \                     ??zapUtilReq_14:
   \   0000C4   4E4A         MOV.B   R10, R14
   \                     ??zapUtilReq_16:
   \   0000C6   0D4B         MOV.W   R11, R13
   \   0000C8   ........     CALLA   #osal_memcpy
    857              break;
    858          
    859            // AREQ's to ZNP.
    860          
    861            default:
    862              break;
    863            }
    864          
    865            if (zapPhySend(zapAppPort, pBuf) == FAILURE)
   \                     ??zapUtilReq_15:
   \   0000CC   2D41         MOV.W   @SP, R13
   \   0000CE   5C42....     MOV.B   &zapAppPort, R12
   \   0000D2   ........     CALLA   #zapPhySend
   \   0000D6   5C93         CMP.B   #0x1, R12
   \   0000D8   0520         JNE     ??zapUtilReq_19
    866            {
    867              zap_msg_deallocate(&pBuf);
   \   0000DA   0C41         MOV.W   SP, R12
   \   0000DC   0C53         ADD.W   #0x0, R12
   \   0000DE   ........     CALLA   #zap_msg_deallocate
   \   0000E2   C13F         JMP     ??zapUtilReq_0
    868              return FAILURE;
    869            }
    870          
    871            switch (cmd)
   \                     ??zapUtilReq_19:
   \   0000E4   79804100     SUB.B   #0x41, R9
   \   0000E8   0B24         JEQ     ??zapUtilReq_20
   \   0000EA   79800700     SUB.B   #0x7, R9
   \   0000EE   0A24         JEQ     ??zapUtilReq_21
   \   0000F0   5983         SUB.B   #0x1, R9
   \   0000F2   0A24         JEQ     ??zapUtilReq_22
   \   0000F4   5983         SUB.B   #0x1, R9
   \   0000F6   0824         JEQ     ??zapUtilReq_22
   \   0000F8   79800300     SUB.B   #0x3, R9
   \   0000FC   0824         JEQ     ??zapUtilReq_23
   \   0000FE   0D3C         JMP     ??zapUtilReq_24
    872            {
    873            // SREQ's to ZNP.
    874          
    875            case MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP:
    876              (void)osal_memcpy(req, pBuf, Z_EXTADDR_LEN);
   \                     ??zapUtilReq_20:
   \   000100   3E42         MOV.W   #0x8, R14
   \   000102   073C         JMP     ??zapUtilReq_1
    877              break;
    878          
    879          #if SECURE
    880            case MT_UTIL_APSME_LINK_KEY_DATA_GET:
    881              if (SUCCESS == (rtrn = *pBuf))
    882              {
    883                APSME_LinkKeyData_t *pData = (APSME_LinkKeyData_t *)args;
    884                uint8 *ptr = pBuf+1;
    885          
    886                // copy key data
    887                (void)osal_memcpy(pData->key, ptr, SEC_KEY_LEN);
    888                ptr += SEC_KEY_LEN;
    889                pData->txFrmCntr = BUILD_UINT32(ptr[0], ptr[1], ptr[2], ptr[3]);
    890                ptr += 4;
    891                pData->rxFrmCntr = BUILD_UINT32(ptr[0], ptr[1], ptr[2], ptr[3]);
    892              }
    893              break;
    894          
    895            case MT_UTIL_APSME_LINK_KEY_NV_ID_GET:
    896              if (SUCCESS == (rtrn = *pBuf))
    897              {
    898                uint16 *pNvId = (uint16 *)args;
    899                uint8 *ptr = pBuf+1;
    900          
    901                *pNvId = BUILD_UINT16(ptr[0], ptr[1]);
    902              }
    903              break;
    904          #endif
    905          
    906            case MT_UTIL_ASSOC_COUNT:
    907              (void)osal_memcpy(req, pBuf, 2);
   \                     ??zapUtilReq_21:
   \   000104   2E43         MOV.W   #0x2, R14
   \   000106   053C         JMP     ??zapUtilReq_1
    908              break;
    909          
    910            case MT_UTIL_ASSOC_FIND_DEVICE:
    911            case MT_UTIL_ASSOC_GET_WITH_ADDRESS:
    912              (void)osal_memcpy(req, pBuf, sizeof(associated_devices_t));
   \                     ??zapUtilReq_22:
   \   000108   3E401600     MOV.W   #0x16, R14
   \   00010C   023C         JMP     ??zapUtilReq_1
    913              break;
    914          
    915              case MT_UTIL_BIND_ADD_ENTRY:
    916              (void)osal_memcpy(req, pBuf, sizeof(BindingEntry_t));
   \                     ??zapUtilReq_23:
   \   00010E   3E400E00     MOV.W   #0xe, R14
   \                     ??zapUtilReq_1:
   \   000112   2D41         MOV.W   @SP, R13
   \   000114   0C4B         MOV.W   R11, R12
   \   000116   ........     CALLA   #osal_memcpy
    917              break;
    918          
    919          #if defined ZCL_KEY_ESTABLISH
    920            case MT_UTIL_ZCL_KEY_EST_SIGN:
    921          #if defined SECURE
    922              (void)osal_memcpy(req, pBuf+1, SE_PROFILE_SIGNATURE_LENGTH);
    923          #endif
    924            case MT_UTIL_ZCL_KEY_EST_INIT_EST:
    925              rtrn = *pBuf;
    926              break;
    927          #endif
    928          
    929            // AREQ's to ZNP.
    930          
    931            default:
    932              break;
    933            }
    934          
    935            zap_msg_deallocate(&pBuf);
   \                     ??zapUtilReq_24:
   \   00011A   0C41         MOV.W   SP, R12
   \   00011C   0C53         ADD.W   #0x0, R12
   \   00011E   ........     CALLA   #zap_msg_deallocate
    936            return rtrn;
   \   000122   4C43         MOV.B   #0x0, R12
   \                     ??zapUtilReq_9:
   \   000124   2153         ADD.W   #0x2, SP
   \   000126   3817         POPM.W  #0x4, R11
   \   000128   1001         RETA
    937          }
    938          
    939          /**************************************************************************************************
    940           * @fn          zapUtilParseAssocDevT
    941           *
    942           * @brief       This function parses a packed associated_devices_t.
    943           *
    944           * input parameters
    945           *
    946           * @param       pBuf - A buffer containing a packed associated_devices_t.
    947           *
    948           * output parameters
    949           *
    950           * None.
    951           *
    952           * @return      SUCCESS if the parsed shortAddr is not invalid, otherwise FAILURE.
    953           **************************************************************************************************
    954           */

   \                                 In  segment CODE, align 2
    955          static uint8 zapUtilParseAssocDevT(uint8 *pBuf)
   \                     zapUtilParseAssocDevT:
    956          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0F4C         MOV.W   R12, R15
    957            assocDevT.shortAddr = BUILD_UINT16(pBuf[0], pBuf[1]);
   \   000004   6E4C         MOV.B   @R12, R14
   \   000006   5B4C0100     MOV.B   0x1(R12), R11
   \   00000A                RPT     #0x8
   \   00000A   47180B5B     RLAX.W  R11
   \   00000E   0E5B         ADD.W   R11, R14
   \   000010   824E....     MOV.W   R14, &assocDevT
    958            assocDevT.addrIdx = BUILD_UINT16(pBuf[2], pBuf[3]);
   \   000014   5E4C0200     MOV.B   0x2(R12), R14
   \   000018   5B4C0300     MOV.B   0x3(R12), R11
   \   00001C                RPT     #0x8
   \   00001C   47180B5B     RLAX.W  R11
   \   000020   0E5B         ADD.W   R11, R14
   \   000022   824E....     MOV.W   R14, &assocDevT + 2
    959            pBuf += 4;
   \   000026   2F52         ADD.W   #0x4, R15
    960            assocDevT.nodeRelation = *pBuf++;
   \   000028   F24F....     MOV.B   @R15+, &assocDevT + 4
    961            assocDevT.devStatus = *pBuf++;
   \   00002C   F24F....     MOV.B   @R15+, &assocDevT + 5
    962            assocDevT.assocCnt = *pBuf++;
   \   000030   F24F....     MOV.B   @R15+, &assocDevT + 6
    963            assocDevT.age = *pBuf++;
   \   000034   F24F....     MOV.B   @R15+, &assocDevT + 7
    964            assocDevT.linkInfo.txCounter = *pBuf++;
   \   000038   F24F....     MOV.B   @R15+, &assocDevT + 8
    965            assocDevT.linkInfo.txCost = *pBuf++;
   \   00003C   F24F....     MOV.B   @R15+, &assocDevT + 9
    966            assocDevT.linkInfo.rxLqi = *pBuf++;
   \   000040   F24F....     MOV.B   @R15+, &assocDevT + 10
    967            assocDevT.linkInfo.inKeySeqNum = *pBuf++;
   \   000044   F24F....     MOV.B   @R15+, &assocDevT + 11
    968            assocDevT.linkInfo.inFrmCntr = BUILD_UINT32(pBuf[0], pBuf[1], pBuf[2], pBuf[3]);
   \   000048   6A4F         MOV.B   @R15, R10
   \   00004A   0B43         MOV.W   #0x0, R11
   \   00004C   5C4F0100     MOV.B   0x1(R15), R12
   \   000050   0D43         MOV.W   #0x0, R13
   \   000052   ........     CALLA   #?ShiftLeft32_8
   \   000056   0A5C         ADD.W   R12, R10
   \   000058   0B6D         ADDC.W  R13, R11
   \   00005A   5D4F0200     MOV.B   0x2(R15), R13
   \   00005E   0B5D         ADD.W   R13, R11
   \   000060   5C4F0300     MOV.B   0x3(R15), R12
   \   000064                RPT     #0x8
   \   000064   47180C5C     RLAX.W  R12
   \   000068   0B5C         ADD.W   R12, R11
   \   00006A   824A....     MOV.W   R10, &assocDevT + 12
   \   00006E   824B....     MOV.W   R11, &assocDevT + 14
    969            assocDevT.linkInfo.txFailure = BUILD_UINT16(pBuf[4], pBuf[5]);
   \   000072   5B4F0400     MOV.B   0x4(R15), R11
   \   000076   5F4F0500     MOV.B   0x5(R15), R15
   \   00007A                RPT     #0x8
   \   00007A   47180F5F     RLAX.W  R15
   \   00007E   0B5F         ADD.W   R15, R11
   \   000080   824B....     MOV.W   R11, &assocDevT + 16
    970          
    971            return ((INVALID_NODE_ADDR != assocDevT.shortAddr) ? SUCCESS : FAILURE);
   \   000084   B290FEFF.... CMP.W   #0xfffe, &assocDevT
   \   00008A   0120         JNE     ??zapUtilParseAssocDevT_0
   \   00008C   5C43         MOV.B   #0x1, R12
   \                     ??zapUtilParseAssocDevT_0:
   \   00008E   1A17         POPM.W  #0x2, R11
   \   000090   1001         RETA
    972          }
    973          
    974          /**************************************************************************************************
    975           * @fn          zapUtilParseBindEntryT
    976           *
    977           * @brief       This function parses a packed BindingEntry_t.
    978           *
    979           * input parameters
    980           *
    981           * @param       pBuf - A buffer containing a packed BindingEntry_t.
    982           *
    983           * output parameters
    984           *
    985           * None.
    986           *
    987           * @return      SUCCESS if the parsed dstIdx is valid, otherwise FAILURE.
    988           **************************************************************************************************
    989           */

   \                                 In  segment CODE, align 2
    990          static uint8 zapUtilParseBindEntryT(uint8 *pBuf)
   \                     zapUtilParseBindEntryT:
    991          {
    992            bindEntryT.srcEP = *pBuf++;
   \   000000   F24C....     MOV.B   @R12+, &bindEntryT
    993            bindEntryT.dstGroupMode = *pBuf++;
   \   000004   F24C....     MOV.B   @R12+, &bindEntryT + 1
    994            bindEntryT.dstIdx = BUILD_UINT16(pBuf[0], pBuf[1]);
   \   000008   6E4C         MOV.B   @R12, R14
   \   00000A   5F4C0100     MOV.B   0x1(R12), R15
   \   00000E                RPT     #0x8
   \   00000E   47180F5F     RLAX.W  R15
   \   000012   0E5F         ADD.W   R15, R14
   \   000014   824E....     MOV.W   R14, &bindEntryT + 2
    995            pBuf += 2;
   \   000018   2C53         ADD.W   #0x2, R12
    996            bindEntryT.dstEP = *pBuf++;
   \   00001A   F24C....     MOV.B   @R12+, &bindEntryT + 4
    997            bindEntryT.numClusterIds = *pBuf++;
   \   00001E   7E4C         MOV.B   @R12+, R14
    998          
    999            if ( bindEntryT.numClusterIds > MAX_BINDING_CLUSTER_IDS )
   \   000020   7E900500     CMP.B   #0x5, R14
   \   000024   0128         JNC     ??zapUtilParseBindEntryT_0
   1000            {
   1001              bindEntryT.numClusterIds = MAX_BINDING_CLUSTER_IDS;
   \   000026   6E42         MOV.B   #0x4, R14
   \                     ??zapUtilParseBindEntryT_0:
   \   000028   C24E....     MOV.B   R14, &bindEntryT + 5
   1002            }
   1003          
   1004            osal_memcpy( bindEntryT.clusterIdList, pBuf, bindEntryT.numClusterIds * sizeof(uint16));
   \   00002C   0E5E         RLA.W   R14
   \   00002E   0D4C         MOV.W   R12, R13
   \   000030   3C40....     MOV.W   #bindEntryT + 6, R12
   \   000034   ........     CALLA   #osal_memcpy
   1005          
   1006            return ((INVALID_NODE_ADDR != bindEntryT.dstIdx) ? SUCCESS : FAILURE);
   \   000038   B290FEFF.... CMP.W   #0xfffe, &bindEntryT + 2
   \   00003E   0220         JNE     ??zapUtilParseBindEntryT_1
   \   000040   5C43         MOV.B   #0x1, R12
   \   000042   1001         RETA
   \                     ??zapUtilParseBindEntryT_1:
   \   000044   4C43         MOV.B   #0x0, R12
   \   000046   1001         RETA
   1007          }
   1008          
   1009          #if defined ZCL_KEY_ESTABLISH
   1010          /**************************************************************************************************
   1011           * @fn          zapUtilParseKeyInd
   1012           *
   1013           * @brief       This function parses a packed keyEstablishmentInd_t.
   1014           *
   1015           * input parameters
   1016           *
   1017           * @param       pBuf - A buffer containing a packed keyEstablishmentInd_t.
   1018           *
   1019           * output parameters
   1020           *
   1021           * None.
   1022           *
   1023           * @return      None.
   1024           **************************************************************************************************
   1025           */
   1026          static void zapUtilParseKeyInd(uint8 *pBuf)
   1027          {
   1028            keyEstablishmentInd_t *pInd;
   1029          
   1030            // Send osal message to the application.
   1031            if (NULL != (pInd = (keyEstablishmentInd_t *)osal_msg_allocate(sizeof(keyEstablishmentInd_t))))
   1032            {
   1033              pInd->hdr.event = pBuf[1];
   1034              pInd->hdr.status = pBuf[2];
   1035              pInd->waitTime = pBuf[3];
   1036              pInd->keyEstablishmentSuite = BUILD_UINT16(pBuf[4], pBuf[5]);
   1037              osal_msg_send(pBuf[0], (uint8 *)pInd);
   1038            }
   1039          }
   1040          #endif
   1041          
   1042          /**************************************************************************************************
   1043          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      8   AddrMgrEntryLookupNwk
        8   -> osal_memcmp
        8   -> osal_memset
        8   -> zapUtilReq
      8   AddrMgrExtAddrLookup
        8   -> osal_memcmp
        8   -> osal_memset
        8   -> zapUtilReq
      4   AddrMgrExtAddrSet
        4   -> osal_memset
        4   -> sAddrExtCpy
      8   AssocCount
        8   -> zapUtilReq
     28   AssocFindDevice
       28   -> zapUtilParseAssocDevT
       28   -> zapUtilReq
     26   AssocGetWithShort
       26   -> zapUtilParseAssocDevT
       26   -> zapUtilReq
      4   NLME_GetCoordShortAddr
      4   NLME_GetExtAddr
      4   NLME_GetShortAddr
     14   NLME_PermitJoiningRequest
       14   -> ZDP_MgmtPermitJoinReq
      6   NLME_SetPollRate
        6   -> znp_nv_write
     18   bindAddEntry
       18   -> osal_mem_alloc
       18   -> osal_mem_free
       18   -> osal_memcpy
       18   -> sAddrExtCpy
       18   -> zapUtilParseBindEntryT
       18   -> zapUtilReq
      8   zapUtilParseAssocDevT
      4   zapUtilParseBindEntryT
        4   -> osal_memcpy
      4   zapUtilProcessIncoming
        4   -> zapGotSync
     14   zapUtilReq
       14   -> osal_memcpy
       14   -> osal_memset
       14   -> zapPhySend
       14   -> zap_msg_allocate
       14   -> zap_msg_deallocate


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??Subroutine1_0
       6  ?Subroutine0
       4  ?Subroutine1
      14  ?Subroutine2
      62  AddrMgrEntryLookupNwk
      54  AddrMgrExtAddrLookup
      16  AddrMgrExtAddrSet
      44  AssocCount
      58  AssocFindDevice
      50  AssocGetWithShort
       6  NLME_GetCoordShortAddr
       6  NLME_GetExtAddr
       6  NLME_GetShortAddr
      34  NLME_PermitJoiningRequest
      22  NLME_SetPollRate
      22  assocDevT
     164  bindAddEntry
      14  bindEntryT
       8  nullAddr
     146  zapUtilParseAssocDevT
      72  zapUtilParseBindEntryT
      14  zapUtilProcessIncoming
     298  zapUtilReq

 
 1 084 bytes in segment CODE
     8 bytes in segment DATA16_C
    36 bytes in segment DATA16_Z
 
 1 084 bytes of CODE  memory
     8 bytes of CONST memory
    36 bytes of DATA  memory

Errors: none
Warnings: none
