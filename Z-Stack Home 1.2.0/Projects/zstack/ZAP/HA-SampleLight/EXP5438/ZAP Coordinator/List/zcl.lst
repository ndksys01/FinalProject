###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.60.5.50814/W32 for MSP430       08/Apr/2014  21:14:23 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\Z-Stack Home                       #
#                     1.2.0\Components\stack\zcl\zcl.c                        #
#    Command line  =  -f "C:\Texas Instruments\Z-Stack Home                   #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     Source\zap.cfg" (-DZAP_PHY_SPI=1                        #
#                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE    #
#                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                  #
#                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE               #
#                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE            #
#                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4) -f   #
#                     "C:\Texas Instruments\Z-Stack Home                      #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\Tools\MSP5438\f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE    #
#                     -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF                 #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU                 #
#                     -DZCL_DEVICE_MGMT) "C:\Texas Instruments\Z-Stack Home   #
#                     1.2.0\Components\stack\zcl\zcl.c" -D                    #
#                     FEATURE_GREEN_POWER -D FEATURE_ENHANCED_BEACON -D       #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -lC "C:\Texas  #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\ZAP Coordinator\List\" -lA           #
#                     "C:\Texas Instruments\Z-Stack Home                      #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP    #
#                     Coordinator\List\" --remarks --diag_suppress            #
#                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                    #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\ZAP Coordinator\Obj\" --debug        #
#                     -D__MSP430F5438__ -e --double=32 --clib -I "C:\Texas    #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\" -I "C:\Texas Instruments\Z-Stack   #
#                     Home 1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\. #
#                     .\Source\" -I "C:\Texas Instruments\Z-Stack Home        #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     Source\" -I "C:\Texas Instruments\Z-Stack Home          #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\hal\target\MSP5438ZAP\" -I          #
#                     "C:\Texas Instruments\Z-Stack Home                      #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\hal\include\" -I "C:\Texas          #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\mac\includ #
#                     e\" -I "C:\Texas Instruments\Z-Stack Home               #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\mt\" -I "C:\Texas                   #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\osal\inclu #
#                     de\" -I "C:\Texas Instruments\Z-Stack Home              #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\osal\mcu\msp430\" -I "C:\Texas      #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\services\s #
#                     addr\" -I "C:\Texas Instruments\Z-Stack Home            #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\services\sdata\" -I "C:\Texas       #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\stack\af\" #
#                      -I "C:\Texas Instruments\Z-Stack Home                  #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\stack\nwk\" -I "C:\Texas            #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\stack\sapi #
#                     \" -I "C:\Texas Instruments\Z-Stack Home                #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\stack\sec\" -I "C:\Texas            #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\stack\sys\ #
#                     " -I "C:\Texas Instruments\Z-Stack Home                 #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\stack\zcl\" -I "C:\Texas            #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\stack\zdo\ #
#                     " -I "C:\Texas Instruments\Z-Stack Home                 #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\zmac\" -I "C:\Texas                 #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\zmac\f8w\" #
#                      --core=430X --data_model=small -Ohz --multiplier=32    #
#                     --multiplier_location=4C0 --require_prototypes          #
#                     --hw_workaround=CPU40 --hw_workaround=CPU39             #
#    List file     =  C:\Texas Instruments\Z-Stack Home                       #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP    #
#                     Coordinator\List\zcl.lst                                #
#    Object file   =  C:\Texas Instruments\Z-Stack Home                       #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP    #
#                     Coordinator\Obj\zcl.r43                                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\Z-Stack Home 1.2.0\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2013-11-22 17:43:52 -0800 (Fri, 22 Nov 2013) $
      4            Revision:       $Revision: 36225 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "AF.h"
     45          
     46          #include "zcl.h"
     47          #include "zcl_general.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52          
     53          /*********************************************************************
     54           * MACROS
     55           */
     56          /*** Frame Control ***/
     57          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     58          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     59          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     60          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     61          
     62          /*** Attribute Access Control ***/
     63          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     64          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     65          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     66          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     67          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     68          
     69          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     70          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     71          
     72          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     73                                                  (zclHdr).fc.manuSpecific == 0          && \
     74                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     75          
     76          // Commands that have corresponding responses
     77          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     78                                                  (cmd) == ZCL_CMD_WRITE                  || \
     79                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     80                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     81                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     82                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     83                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     84                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     85                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     86                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     87          
     88          /*********************************************************************
     89           * CONSTANTS
     90           */
     91          
     92          /*********************************************************************
     93           * TYPEDEFS
     94           */
     95          typedef struct zclLibPlugin
     96          {
     97            struct zclLibPlugin *next;
     98            uint16              startClusterID;    // starting cluster ID
     99            uint16              endClusterID;      // ending cluster ID
    100            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    101          } zclLibPlugin_t;
    102          
    103          // Command record list
    104          typedef struct zclCmdRecsList
    105          {
    106            struct zclCmdRecsList *pNext;
    107            uint8                 endpoint;
    108            uint8                 numCommands;
    109            CONST zclCommandRec_t *pCmdRecs;
    110          } zclCmdRecsList_t;
    111          
    112          // Attribute record list item
    113          typedef struct zclAttrRecsList
    114          {
    115            struct zclAttrRecsList *next;
    116            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    117            zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
    118            zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
    119            uint8                  numAttributes; // Number of the following records
    120            CONST zclAttrRec_t     *attrs;        // attribute records
    121          } zclAttrRecsList;
    122          
    123          // Cluster option list item
    124          typedef struct zclClusterOptionList
    125          {
    126            struct zclClusterOptionList *next;
    127            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    128            uint8                       numOptions; // Number of the following records
    129            zclOptionRec_t              *options;   // option records
    130          } zclClusterOptionList;
    131          
    132          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    133          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    134          
    135          typedef struct
    136          {
    137            zclParseInProfileCmd_t   pfnParseInProfile;
    138            zclProcessInProfileCmd_t pfnProcessInProfile;
    139          } zclCmdItems_t;
    140          
    141          
    142          /*********************************************************************
    143           * GLOBAL VARIABLES
    144           */
    145          
    146          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    147            uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS8 1
    148          
    149            // The task Id of the Application where the unprocessed Foundation
    150            // Command/Response messages will be sent to.

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    151            uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
    152          #endif
    153          
    154          // The Application should register its attribute data validation function

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    155          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS8 4
    156          
    157          // ZCL Sequence number

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    158          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS8 1
    159          
    160          /*********************************************************************
    161           * EXTERNAL VARIABLES
    162           */
    163          
    164          /*********************************************************************
    165           * EXTERNAL FUNCTIONS
    166           */
    167          
    168          /*********************************************************************
    169           * LOCAL VARIABLES
    170           */

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    171          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS8 2
    172          
    173          #if defined ( ZCL_DISCOVER )
    174            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
    175          #endif
    176          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    177          static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
   \                     attrList:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    178          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    179          static uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS8 1
    180          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    181          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS8 2
    182          
    183          /*********************************************************************
    184           * LOCAL FUNCTIONS
    185           */
    186          void zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt );  // Not static for ZNP build.
    187          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    188          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    189          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    190          
    191          #if defined ( ZCL_DISCOVER )
    192            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    193          #endif
    194          
    195          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    196          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    197          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    198          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    199          
    200          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    201          
    202          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    203          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    204          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    205          #endif // ZCL_READ || ZCL_WRITE
    206          
    207          #ifdef ZCL_READ
    208          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
    209          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    210          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    211                                                   uint8 *pAttrData, uint16 *pDataLen );
    212          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    213          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    214          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    215          #endif // ZCL_READ
    216          
    217          #ifdef ZCL_WRITE
    218          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    219                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    220          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    221                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    222          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    223          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    224          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    225          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    226          #endif // ZCL_WRITE
    227          
    228          #ifdef ZCL_REPORT
    229          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    230          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    231          #endif // ZCL_REPORT
    232          
    233          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    234          
    235          #ifdef ZCL_DISCOVER
    236          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    237          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    238          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    239          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    240          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    241          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    242          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    243          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    244          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    245          #endif // ZCL_DISCOVER
    246          
    247          /*********************************************************************
    248           * Parse Profile Command Function Table
    249           */
    250          

   \                                 In  segment DATA16_C, align 2, align-sorted
    251          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ............ DC32 zclParseInReadCmd, zclProcessInReadCmd, zclParseInReadRspCmd
   \            ............
   \   00000C   ............ DC32 zcl_HandleExternal, zclParseInWriteCmd, zclProcessInWriteCmd
   \            ............
   \   000018   ............ DC32 zclParseInWriteCmd, zclProcessInWriteUndividedCmd
   \            ....        
   \   000020   ............ DC32 zclParseInWriteRspCmd, zcl_HandleExternal, zclParseInWriteCmd
   \            ............
   \   00002C   ........0000 DC32 zclProcessInWriteCmd, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            0000        
   \   000058   ............ DC32 zclParseInDefaultRspCmd, zcl_HandleExternal, 0H, 0H, 0H, 0H, 0H
   \            ....00000000
   \            000000000000
   \            000000000000
   \            00000000    
   \   000074   000000000000 DC32 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            0000        
    252          {
    253          #ifdef ZCL_READ
    254            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    255            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    256          #else
    257            /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    258            /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    259          #endif // ZCL_READ
    260          
    261          #ifdef ZCL_WRITE
    262            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    263            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    264            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    265            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    266          #else
    267            /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    268            /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    269            /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    270            /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    271          #endif // ZCL_WRITE
    272          
    273          #ifdef ZCL_REPORT
    274            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    275            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    276            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    277            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    278            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    279          #else
    280            /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    281            /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    282            /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    283            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    284            /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    285          #endif // ZCL_REPORT
    286          
    287            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    288          
    289          #ifdef ZCL_DISCOVER
    290            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    291            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    292            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    293            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    294            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    295            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    296            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    297            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    298            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    299            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    300            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    301          #else
    302            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    303            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    304            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    305            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    306            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    307            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    308            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    309            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    310            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    311            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    312            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    313          #endif // ZCL_DISCOVER
    314          };
    315          
    316          /*********************************************************************
    317           * PUBLIC FUNCTIONS
    318           *********************************************************************/
    319          
    320          #if !defined ( ZCL_STANDALONE )
    321          /*********************************************************************
    322           * @fn          zcl_Init
    323           *
    324           * @brief       Initialization function for the zcl layer.
    325           *
    326           * @param       task_id - ZCL task id
    327           *
    328           * @return      none
    329           */

   \                                 In  segment CODE, align 2
    330          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    331          {
    332            zcl_TaskID = task_id;
   \   000000   C24C....     MOV.B   R12, &zcl_TaskID
    333          }
   \   000004   1001         RETA
    334          #endif
    335          
    336          #if !defined ( ZCL_STANDALONE )
    337          /*********************************************************************
    338           * @fn          zcl_event_loop
    339           *
    340           * @brief       Event Loop Processor for zcl.
    341           *
    342           * @param       task_id - task id
    343           * @param       events - event bitmap
    344           *
    345           * @return      unprocessed events
    346           */

   \                                 In  segment CODE, align 2
    347          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    348          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4D         MOV.W   R13, R10
    349            uint8 *msgPtr;
    350          
    351            (void)task_id;  // Intentionally unreferenced parameter
    352          
    353            if ( events & SYS_EVENT_MSG )
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   1C34         JGE     ??zcl_event_loop_3
    354            {
    355              msgPtr = osal_msg_receive( zcl_TaskID );
   \   000008   063C         JMP     ??zcl_event_loop_2
    356              while ( msgPtr != NULL )
    357              {
    358                uint8 dealloc = TRUE;
    359          
    360                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    361                {
    362                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_0:
   \   00000A   0C4B         MOV.W   R11, R12
   \   00000C   ........     CALLA   #zcl_ProcessMessageMSG
    363                }
    364                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    365                {
    366                  // send it to another task to process.
    367                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
    368                  dealloc = FALSE;
    369                }
    370          
    371                // Release the memory
    372                if ( dealloc )
    373                {
    374                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_1:
   \   000010   0C4B         MOV.W   R11, R12
   \   000012   ........     CALLA   #osal_msg_deallocate
    375                }
    376          
    377                // Next
    378                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_2:
   \   000016   5C42....     MOV.B   &zcl_TaskID, R12
   \   00001A   ........     CALLA   #osal_msg_receive
   \   00001E   0B4C         MOV.W   R12, R11
   \   000020   0B93         CMP.W   #0x0, R11
   \   000022   0A24         JEQ     ??zcl_event_loop_4
   \   000024   FB901A000000 CMP.B   #0x1a, 0(R11)
   \   00002A   EF27         JEQ     ??zcl_event_loop_0
   \   00002C   F293....     CMP.B   #0xff, &zcl_RegisteredMsgTaskID
   \   000030   EF27         JEQ     ??zcl_event_loop_1
   \   000032   ........     CALLA   #?Subroutine17
   \                     ??CrossCallReturnLabel_10:
   \   000036   EF3F         JMP     ??zcl_event_loop_2
    379              }
    380          
    381              // return unprocessed events
    382              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   000038   3AE00080     XOR.W   #0x8000, R10
   \   00003C   0C4A         MOV.W   R10, R12
   \   00003E   013C         JMP     ??zcl_event_loop_5
    383            }
    384          
    385            // Discard unknown events
    386            return 0;
   \                     ??zcl_event_loop_3:
   \   000040   0C43         MOV.W   #0x0, R12
   \                     ??zcl_event_loop_5:
   \   000042   1A17         POPM.W  #0x2, R11
   \   000044   1001         RETA
    387          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine17:
   \   000000   0D4B         MOV.W   R11, R13
   \   000002   5C42....     MOV.B   &zcl_RegisteredMsgTaskID, R12
   \   000006   ........     BRA     #osal_msg_send
    388          #endif
    389          
    390          #if !defined ( ZCL_STANDALONE )
    391          /*********************************************************************
    392           * @fn      zcl_registerForMsg
    393           *
    394           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    395           *          messages that aren't processed to one task (if a task is
    396           *          registered).
    397           *
    398           * @param   taskId - task Id of the Application where commands will be sent to
    399           *
    400           * @return  TRUE if task registeration successful, FALSE otherwise
    401           *********************************************************************/

   \                                 In  segment CODE, align 2
    402          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    403          {
    404            // Allow only the first task
    405            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000000   F293....     CMP.B   #0xff, &zcl_RegisteredMsgTaskID
   \   000004   0420         JNE     ??zcl_registerForMsg_0
    406            {
    407              zcl_RegisteredMsgTaskID = taskId;
   \   000006   C24C....     MOV.B   R12, &zcl_RegisteredMsgTaskID
    408          
    409              return ( true );
   \   00000A   5C43         MOV.B   #0x1, R12
   \   00000C   1001         RETA
    410            }
    411          
    412            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   00000E   4C43         MOV.B   #0x0, R12
   \   000010   1001         RETA
    413          }
    414          #endif
    415          
    416          #if !defined ( ZCL_STANDALONE )
    417          /*********************************************************************
    418           * @fn      zcl_HandleExternal
    419           *
    420           * @brief
    421           *
    422           * @param   pInMsg - incoming message to process
    423           *
    424           * @return  TRUE
    425           */

   \                                 In  segment CODE, align 2
    426          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    427          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
    428            zclIncomingMsg_t *pCmd;
    429          
    430            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000004   F293....     CMP.B   #0xff, &zcl_RegisteredMsgTaskID
   \   000008   2924         JEQ     ??zcl_HandleExternal_0
    431            {
    432              return ( TRUE );
    433            }
    434          
    435            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   00000A   3C401A00     MOV.W   #0x1a, R12
   \   00000E   ........     CALLA   #osal_msg_allocate
   \   000012   0B4C         MOV.W   R12, R11
    436            if ( pCmd != NULL )
   \   000014   0C93         CMP.W   #0x0, R12
   \   000016   2224         JEQ     ??zcl_HandleExternal_0
    437            {
    438              // fill in the message
    439              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   000018   FC4034000000 MOV.B   #0x34, 0(R12)
    440              pCmd->zclHdr    = pInMsg->hdr;
   \   00001E   0F4A         MOV.W   R10, R15
   \   000020   2F53         ADD.W   #0x2, R15
   \   000022   BC4F0200     MOV.W   @R15+, 0x2(R12)
   \   000026   BC4F0400     MOV.W   @R15+, 0x4(R12)
   \   00002A   BC4F0600     MOV.W   @R15+, 0x6(R12)
    441              pCmd->clusterId = pInMsg->msg->clusterId;
   \   00002E   2E4A         MOV.W   @R10, R14
   \   000030   9C4E04000800 MOV.W   0x4(R14), 0x8(R12)
    442              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \   000036   3C500A00     ADD.W   #0xa, R12
   \   00003A   3E500600     ADD.W   #0x6, R14
   \   00003E   3D400600     MOV.W   #0x6, R13
   \   000042   ........     CALLA   #?CopyMemoryWords
    443              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   000046   2F4A         MOV.W   @R10, R15
   \   000048   DB4F14001600 MOV.B   0x14(R15), 0x16(R11)
    444              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00004E   9B4A0C001800 MOV.W   0xc(R10), 0x18(R11)
    445          
    446              // Application will free the attrCmd buffer
    447              pInMsg->attrCmd = NULL;
   \   000054   8A430C00     MOV.W   #0x0, 0xc(R10)
    448          
    449              /* send message through task message */
    450              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   000058   ........     CALLA   #?Subroutine17
    451            }
    452          
    453            return ( TRUE );
   \                     ??zcl_HandleExternal_0:
   \   00005C   5C43         MOV.B   #0x1, R12
   \   00005E   1A17         POPM.W  #0x2, R11
   \   000060   1001         RETA
    454          }
    455          #endif
    456          
    457          
    458          /*********************************************************************
    459           * @fn          zcl_getRawAFMsg
    460           *
    461           * @brief       Call to get original unprocessed AF message
    462           *              (not parsed by ZCL).
    463           *
    464           *   NOTE:  This function can only be called during a ZCL callback function
    465           *          and the calling function must NOT change any data in the message.
    466           *
    467           * @param       none
    468           *
    469           * @return      pointer to original AF message, NULL if not processing
    470           *              AF message.
    471           */

   \                                 In  segment CODE, align 2
    472          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    473          {
    474            return ( rawAFMsg );
   \   000000   1C42....     MOV.W   &rawAFMsg, R12
   \   000004   1001         RETA
    475          }
    476          
    477          /*********************************************************************
    478           * @fn          zcl_registerPlugin
    479           *
    480           * @brief       Add a Cluster Library handler
    481           *
    482           * @param       startClusterID - starting cluster ID
    483           * @param       endClusterID - ending cluster ID
    484           * @param       pfnHdlr - function pointer to incoming message handler
    485           *
    486           * @return      ZSuccess if OK
    487           */

   \                                 In  segment CODE, align 2
    488          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    489                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    490          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   084C         MOV.W   R12, R8
   \   000004   094D         MOV.W   R13, R9
   \   000006   0A4E         MOV.W   R14, R10
   \   000008   0B4F         MOV.W   R15, R11
    491            zclLibPlugin_t *pNewItem;
    492            zclLibPlugin_t *pLoop;
    493          
    494            // Fill in the new profile list
    495            pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000A   3C400A00     MOV.W   #0xa, R12
   \   00000E   ........     CALLA   #??Subroutine5_0
    496            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_50:
   \   000012   0320         JNE     ??zcl_registerPlugin_3
    497            {
    498              return (ZMemError);
   \   000014   7C401000     MOV.B   #0x10, R12
   \   000018   183C         JMP     ??zcl_registerPlugin_4
    499            }
    500          
    501            // Fill in the plugin record.
    502            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_3:
   \   00001A   8C430000     MOV.W   #0x0, 0(R12)
    503            pNewItem->startClusterID = startClusterID;
   \   00001E   8C480200     MOV.W   R8, 0x2(R12)
    504            pNewItem->endClusterID = endClusterID;
   \   000022   8C490400     MOV.W   R9, 0x4(R12)
    505            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \   000026   8C4A0600     MOV.W   R10, 0x6(R12)
   \   00002A   8C4B0800     MOV.W   R11, 0x8(R12)
    506          
    507            // Find spot in list
    508            if (  plugins == NULL )
   \   00002E   1F42....     MOV.W   &plugins, R15
   \   000032   0F93         CMP.W   #0x0, R15
   \   000034   0420         JNE     ??zcl_registerPlugin_2
    509            {
    510              plugins = pNewItem;
   \   000036   824C....     MOV.W   R12, &plugins
   \   00003A   063C         JMP     ??zcl_registerPlugin_5
    511            }
    512            else
    513            {
    514              // Look for end of list
    515              pLoop = plugins;
    516              while ( pLoop->next != NULL )
    517              {
    518                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_0:
   \   00003C   0F4B         MOV.W   R11, R15
    519              }
   \                     ??zcl_registerPlugin_2:
   \   00003E   2B4F         MOV.W   @R15, R11
   \   000040   0B93         CMP.W   #0x0, R11
   \   000042   FC23         JNE     ??zcl_registerPlugin_0
    520          
    521              // Put new item at end of list
    522              pLoop->next = pNewItem;
   \   000044   8F4C0000     MOV.W   R12, 0(R15)
    523            }
    524          
    525            return ( ZSuccess );
   \                     ??zcl_registerPlugin_5:
   \   000048   4C43         MOV.B   #0x0, R12
   \                     ??zcl_registerPlugin_4:
   \   00004A   3817         POPM.W  #0x4, R11
   \   00004C   1001         RETA
    526          }

   \                                 In  segment CODE, align 2
   \                     ??Subroutine5_0:
   \   000000   ........     CALLA   #osal_mem_alloc
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   1001         RETA
    527          
    528          #ifdef ZCL_DISCOVER
    529          /*********************************************************************
    530           * @fn          zcl_registerCmdList
    531           *
    532           * @brief       Register a Command List with ZCL Foundation
    533           *
    534           * @param       endpoint - endpoint the attribute list belongs to
    535           * @param       newCmdList - array of command records
    536           *
    537           * @return      ZSuccess if OK
    538           */
    539          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 numAttrs, CONST zclCommandRec_t zclTestApp_Cmds[] );
    540          ZStatus_t zcl_registerCmdList( uint8 endpoint, uint8 zclCmdsArraySize, CONST zclCommandRec_t newCmdList[] )
    541          {
    542            zclCmdRecsList_t *pNewItem;
    543            zclCmdRecsList_t *pLoop;
    544          
    545            // Fill in the new profile list
    546            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
    547            if ( pNewItem == NULL )
    548            {
    549              return (ZMemError);
    550            }
    551          
    552            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
    553            pNewItem->endpoint = endpoint;
    554            pNewItem->numCommands = zclCmdsArraySize;
    555            pNewItem->pCmdRecs = newCmdList;
    556          
    557            // Find spot in list
    558            if ( gpCmdList == NULL )
    559            {
    560              gpCmdList = pNewItem;
    561            }
    562            else
    563            {
    564              // Look for end of list
    565              pLoop = gpCmdList;
    566              while ( pLoop->pNext != NULL )
    567              {
    568                pLoop = pLoop->pNext;
    569              }
    570          
    571              // Put new item at end of list
    572              pLoop->pNext = pNewItem;
    573            }
    574          
    575            return ( ZSuccess );
    576          }
    577          #endif  // ZCL_DISCOVER
    578          
    579          /*********************************************************************
    580           * @fn          zcl_registerAttrList
    581           *
    582           * @brief       Register an Attribute List with ZCL Foundation
    583           *
    584           * @param       endpoint - endpoint the attribute list belongs to
    585           * @param       numAttr - number of attributes in list
    586           * @param       newAttrList - array of Attribute records.
    587           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    588           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    589           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    590           *
    591           * @return      ZSuccess if OK
    592           */

   \                                 In  segment CODE, align 2
    593          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    594          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
   \   000006   084E         MOV.W   R14, R8
    595            zclAttrRecsList *pNewItem;
    596            zclAttrRecsList *pLoop;
    597          
    598            // Fill in the new profile list
    599            pNewItem = zcl_mem_alloc( sizeof( zclAttrRecsList ) );
   \   000008   3C401000     MOV.W   #0x10, R12
   \   00000C   ........     CALLA   #??Subroutine5_0
    600            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_49:
   \   000010   0320         JNE     ??zcl_registerAttrList_3
    601            {
    602              return (ZMemError);
   \   000012   7C401000     MOV.B   #0x10, R12
   \   000016   1A3C         JMP     ??zcl_registerAttrList_4
    603            }
    604          
    605            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_3:
   \   000018   8C430000     MOV.W   #0x0, 0(R12)
    606            pNewItem->endpoint = endpoint;
   \   00001C   CC4A0200     MOV.B   R10, 0x2(R12)
    607            pNewItem->pfnReadWriteCB = NULL;
   \   000020   8C430400     MOV.W   #0x0, 0x4(R12)
   \   000024   8C430600     MOV.W   #0x0, 0x6(R12)
    608            pNewItem->numAttributes = numAttr;
   \   000028   CC4B0C00     MOV.B   R11, 0xc(R12)
    609            pNewItem->attrs = newAttrList;
   \   00002C   8C480E00     MOV.W   R8, 0xe(R12)
    610          
    611            // Find spot in list
    612            if ( attrList == NULL )
   \   000030   1F42....     MOV.W   &attrList, R15
   \   000034   0F93         CMP.W   #0x0, R15
   \   000036   0420         JNE     ??zcl_registerAttrList_2
    613            {
    614              attrList = pNewItem;
   \   000038   824C....     MOV.W   R12, &attrList
   \   00003C   063C         JMP     ??zcl_registerAttrList_5
    615            }
    616            else
    617            {
    618              // Look for end of list
    619              pLoop = attrList;
    620              while ( pLoop->next != NULL )
    621              {
    622                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_0:
   \   00003E   0F4B         MOV.W   R11, R15
    623              }
   \                     ??zcl_registerAttrList_2:
   \   000040   2B4F         MOV.W   @R15, R11
   \   000042   0B93         CMP.W   #0x0, R11
   \   000044   FC23         JNE     ??zcl_registerAttrList_0
    624          
    625              // Put new item at end of list
    626              pLoop->next = pNewItem;
   \   000046   8F4C0000     MOV.W   R12, 0(R15)
    627            }
    628          
    629            return ( ZSuccess );
   \                     ??zcl_registerAttrList_5:
   \   00004A   4C43         MOV.B   #0x0, R12
   \                     ??zcl_registerAttrList_4:
   \   00004C   3817         POPM.W  #0x4, R11
   \   00004E   1001         RETA
    630          }
    631          
    632          /*********************************************************************
    633           * @fn          zcl_registerClusterOptionList
    634           *
    635           * @brief       Register a Cluster Option List with ZCL Foundation
    636           *
    637           * @param       endpoint - endpoint the option list belongs to
    638           * @param       numOption - number of options in list
    639           * @param       optionList - array of cluster option records.
    640           *
    641           *              NOTE: This API should be called to enable 'Application
    642           *                    Link Key' security and/or 'APS ACK' for a specific
    643           *                    Cluster. The 'Application Link Key' is discarded
    644           *                    if security isn't enabled on the device.
    645           *                    The default behavior is 'Network Key' when security
    646           *                    is enabled and no 'APS ACK' for the ZCL messages.
    647           *
    648           * @return      ZSuccess if OK
    649           */

   \                                 In  segment CODE, align 2
    650          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    651          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
   \   000006   084E         MOV.W   R14, R8
    652            zclClusterOptionList *pNewItem;
    653            zclClusterOptionList *pLoop;
    654          
    655            // Fill in the new profile list
    656            pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
   \   000008   3C400600     MOV.W   #0x6, R12
   \   00000C   ........     CALLA   #??Subroutine5_0
    657            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_48:
   \   000010   0320         JNE     ??zcl_registerClusterOptionList_3
    658            {
    659              return (ZMemError);
   \   000012   7C401000     MOV.B   #0x10, R12
   \   000016   163C         JMP     ??zcl_registerClusterOptionList_4
    660            }
    661          
    662            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_3:
   \   000018   8C430000     MOV.W   #0x0, 0(R12)
    663            pNewItem->endpoint = endpoint;
   \   00001C   CC4A0200     MOV.B   R10, 0x2(R12)
    664            pNewItem->numOptions = numOption;
   \   000020   CC4B0300     MOV.B   R11, 0x3(R12)
    665            pNewItem->options = optionList;
   \   000024   8C480400     MOV.W   R8, 0x4(R12)
    666          
    667            // Find spot in list
    668            if ( clusterOptionList == NULL )
   \   000028   1F42....     MOV.W   &clusterOptionList, R15
   \   00002C   0F93         CMP.W   #0x0, R15
   \   00002E   0420         JNE     ??zcl_registerClusterOptionList_2
    669            {
    670              clusterOptionList = pNewItem;
   \   000030   824C....     MOV.W   R12, &clusterOptionList
   \   000034   063C         JMP     ??zcl_registerClusterOptionList_5
    671            }
    672            else
    673            {
    674              // Look for end of list
    675              pLoop = clusterOptionList;
    676              while ( pLoop->next != NULL )
    677              {
    678                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_0:
   \   000036   0F4B         MOV.W   R11, R15
    679              }
   \                     ??zcl_registerClusterOptionList_2:
   \   000038   2B4F         MOV.W   @R15, R11
   \   00003A   0B93         CMP.W   #0x0, R11
   \   00003C   FC23         JNE     ??zcl_registerClusterOptionList_0
    680          
    681              // Put new item at end of list
    682              pLoop->next = pNewItem;
   \   00003E   8F4C0000     MOV.W   R12, 0(R15)
    683            }
    684          
    685            return ( ZSuccess );
   \                     ??zcl_registerClusterOptionList_5:
   \   000042   4C43         MOV.B   #0x0, R12
   \                     ??zcl_registerClusterOptionList_4:
   \   000044   3817         POPM.W  #0x4, R11
   \   000046   1001         RETA
    686          }
    687          
    688          /*********************************************************************
    689           * @fn          zcl_registerValidateAttrData
    690           *
    691           * @brief       Add a validation function for attribute data
    692           *
    693           * @param       pfnValidateAttrData - function pointer to validate routine
    694           *
    695           * @return      ZSuccess if OK
    696           */

   \                                 In  segment CODE, align 2
    697          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    698          {
    699            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000000   824C....     MOV.W   R12, &zcl_ValidateAttrDataCB
   \   000004   824D....     MOV.W   R13, &zcl_ValidateAttrDataCB + 2
    700          
    701            return ( ZSuccess );
   \   000008   4C43         MOV.B   #0x0, R12
   \   00000A   1001         RETA
    702          }
    703          
    704          /*********************************************************************
    705           * @fn          zcl_registerReadWriteCB
    706           *
    707           * @brief       Register the application's callback function to read/write
    708           *              attribute data, and authorize read/write operation.
    709           *
    710           *              Note: The pfnReadWriteCB callback function is only required
    711           *                    when the attribute data format is unknown to ZCL. The
    712           *                    callback function gets called when the pointer 'dataPtr'
    713           *                    to the attribute value is NULL in the attribute database
    714           *                    registered with the ZCL.
    715           *
    716           *              Note: The pfnAuthorizeCB callback function is only required
    717           *                    when the Read/Write operation on an attribute requires
    718           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
    719           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
    720           *
    721           * @param       endpoint - application's endpoint
    722           * @param       pfnReadWriteCB - function pointer to read/write routine
    723           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
    724           *
    725           * @return      ZSuccess if successful. ZFailure, otherwise.
    726           */

   \                                 In  segment CODE, align 2
    727          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
    728                                             zclAuthorizeCB_t pfnAuthorizeCB )
    729          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0B4F         MOV.W   R15, R11
    730            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000004   ........     CALLA   #zclFindAttrRecsList
    731          
    732            if ( pRec != NULL )
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0C24         JEQ     ??zcl_registerReadWriteCB_0
    733            {
    734              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   00000C   8C4E0400     MOV.W   R14, 0x4(R12)
   \   000010   8C4B0600     MOV.W   R11, 0x6(R12)
    735              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \   000014   9C4108000800 MOV.W   0x8(SP), 0x8(R12)
   \   00001A   9C410A000A00 MOV.W   0xa(SP), 0xa(R12)
    736          
    737              return ( ZSuccess );
   \   000020   4C43         MOV.B   #0x0, R12
   \   000022   013C         JMP     ??zcl_registerReadWriteCB_1
    738            }
    739          
    740            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000024   5C43         MOV.B   #0x1, R12
   \                     ??zcl_registerReadWriteCB_1:
   \   000026   1A17         POPM.W  #0x2, R11
   \   000028   1001         RETA
    741          }
    742          
    743          /*********************************************************************
    744           * @fn      zcl_DeviceOperational
    745           *
    746           * @brief   Used to see whether or not the device can send or respond
    747           *          to application level commands.
    748           *
    749           * @param   srcEP - source endpoint
    750           * @param   clusterID - cluster ID
    751           * @param   frameType - command type
    752           * @param   cmd - command ID
    753           *
    754           * @return  TRUE if device is operational, FALSE otherwise
    755           */

   \                                 In  segment CODE, align 2
    756          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
    757                                              uint8 frameType, uint8 cmd, uint16 profileID )
    758          {
   \   000000   31800A00     SUB.W   #0xa, SP
    759            zclAttrRec_t attrRec;
    760            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   000004   D1430000     MOV.B   #0x1, 0(SP)
    761          
    762            (void)profileID;  // Intentionally unreferenced parameter
    763          
    764            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    765            // cannot send or respond to application level commands, other than commands
    766            // to read or write attributes. Note that the Identify cluster cannot be
    767            // disabled, and remains functional regardless of this setting.
    768            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000008   4E93         CMP.B   #0x0, R14
   \   00000A   0320         JNE     ??zcl_DeviceOperational_4
   \   00000C   7F900600     CMP.B   #0x6, R15
   \   000010   1728         JNC     ??zcl_DeviceOperational_1
    769            {
    770              return ( TRUE );
    771            }
    772          
    773            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_4:
   \   000012   3D900300     CMP.W   #0x3, R13
   \   000016   1424         JEQ     ??zcl_DeviceOperational_1
    774            {
    775              return ( TRUE );
    776            }
    777          
    778            // Is device enabled?
    779            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
    780                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000018   0F41         MOV.W   SP, R15
   \   00001A   2F53         ADD.W   #0x2, R15
   \   00001C   3E401200     MOV.W   #0x12, R14
   \   000020   0D43         MOV.W   #0x0, R13
   \   000022   ........     CALLA   #??Subroutine9_0
   \                     ??CrossCallReturnLabel_44:
   \   000026   0724         JEQ     ??zcl_DeviceOperational_5
    781            {
    782          #ifdef ZCL_READ
    783              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   000028   0E43         MOV.W   #0x0, R14
   \   00002A   0D41         MOV.W   SP, R13
   \   00002C   2D53         ADD.W   #0x2, R13
   \   00002E   0C41         MOV.W   SP, R12
   \   000030   0C53         ADD.W   #0x0, R12
   \   000032   ........     CALLA   #zclReadAttrData
    784          #endif
    785            }
    786          
    787            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_5:
   \   000036   D1930000     CMP.B   #0x1, 0(SP)
   \   00003A   0224         JEQ     ??zcl_DeviceOperational_1
   \   00003C   4C43         MOV.B   #0x0, R12
   \   00003E   013C         JMP     ??zcl_DeviceOperational_0
   \                     ??zcl_DeviceOperational_1:
   \   000040   5C43         MOV.B   #0x1, R12
   \                     ??zcl_DeviceOperational_0:
   \   000042   31500A00     ADD.W   #0xa, SP
   \   000046   1001         RETA
    788          }

   \                                 In  segment CODE, align 2
   \                     ??Subroutine9_0:
   \   000000   ........     CALLA   #zclFindAttrRec
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   1001         RETA
    789          
    790          /*********************************************************************
    791           * @fn      zcl_SendCommand
    792           *
    793           * @brief   Used to send Profile and Cluster Specific Command messages.
    794           *
    795           *          NOTE: The calling application is responsible for incrementing
    796           *                the Sequence Number.
    797           *
    798           * @param   srcEp - source endpoint
    799           * @param   destAddr - destination address
    800           * @param   clusterID - cluster ID
    801           * @param   cmd - command ID
    802           * @param   specific - whether the command is Cluster Specific
    803           * @param   direction - client/server direction of the command
    804           * @param   disableDefaultRsp - disable Default Response command
    805           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    806           * @param   seqNumber - identification number for the transaction
    807           * @param   cmdFormatLen - length of the command to be sent
    808           * @param   cmdFormat - command to be sent
    809           *
    810           * @return  ZSuccess if OK
    811           */

   \                                 In  segment CODE, align 2
   \                     ?Subroutine6:
   \   000000   ........     CALLA   #osal_mem_alloc
   \   000004   064C         MOV.W   R12, R6
   \   000006   0C93         CMP.W   #0x0, R12
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
    812          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    813                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    814                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    815                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    816          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   31800600     SUB.W   #0x6, SP
   \   000006   4A4C         MOV.B   R12, R10
   \   000008   074D         MOV.W   R13, R7
   \   00000A   0B4E         MOV.W   R14, R11
   \   00000C   464F         MOV.B   R15, R6
    817            endPointDesc_t *epDesc;
    818            zclFrameHdr_t hdr;
    819            uint8 *msgBuf;
    820            uint16 msgLen;
    821            uint8 *pBuf;
    822            uint8 options;
    823            ZStatus_t status;
    824          
    825            epDesc = afFindEndPointDesc( srcEP );
   \   00000E   ........     CALLA   #afFindEndPointDesc
   \   000012   084C         MOV.W   R12, R8
    826            if ( epDesc == NULL )
   \   000014   0C93         CMP.W   #0x0, R12
   \   000016   0220         JNE     ??zcl_SendCommand_1
    827            {
    828              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000018   6C43         MOV.B   #0x2, R12
   \   00001A   813C         JMP     ??zcl_SendCommand_2
    829            }
    830          
    831          #if defined ( INTER_PAN )
    832            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    833            {
    834              options = AF_TX_OPTIONS_NONE;
    835            }
    836            else
    837          #endif
    838            {
    839              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_1:
   \   00001C   0D4B         MOV.W   R11, R13
   \   00001E   4C4A         MOV.B   R10, R12
   \   000020   ........     CALLA   #zclGetClusterOption
   \   000024   494C         MOV.B   R12, R9
    840          
    841              // The cluster might not have been defined to use security but if this message
    842              // is in response to another message that was using APS security this message
    843              // will be sent with APS security
    844              if ( !( options & AF_EN_SECURITY ) )
   \   000026   7CB04000     BIT.B   #0x40, R12
   \   00002A   092C         JC      ??zcl_SendCommand_3
    845              {
    846                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   00002C   1F42....     MOV.W   &rawAFMsg, R15
    847          
    848                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
   \   000030   0F93         CMP.W   #0x0, R15
   \   000032   0524         JEQ     ??zcl_SendCommand_3
   \   000034   DF931900     CMP.B   #0x1, 0x19(R15)
   \   000038   0220         JNE     ??zcl_SendCommand_3
    849                {
    850                  options |= AF_EN_SECURITY;
   \   00003A   79D04000     BIS.B   #0x40, R9
    851                }
    852              }
    853            }
    854          
    855            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_3:
   \   00003E   3E400600     MOV.W   #0x6, R14
   \   000042   4D43         MOV.B   #0x0, R13
   \   000044   0C41         MOV.W   SP, R12
   \   000046   0C53         ADD.W   #0x0, R12
   \   000048   ........     CALLA   #osal_memset
    856          
    857            // Not Profile wide command (like READ, WRITE)
    858            if ( specific )
   \   00004C   2F41         MOV.W   @SP, R15
   \   00004E   3FF0FCFF     AND.W   #0xfffc, R15
   \   000052   C1931A00     CMP.B   #0x0, 0x1a(SP)
   \   000056   0124         JEQ     ??zcl_SendCommand_0
    859            {
    860              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   000058   1FD3         BIS.W   #0x1, R15
    861            }
    862            else
    863            {
    864              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_0:
   \   00005A   814F0000     MOV.W   R15, 0(SP)
    865            }
    866          
    867            if ( ( epDesc->simpleDesc == NULL ) ||
    868                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
    869                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \   00005E   1F480400     MOV.W   0x4(R8), R15
   \   000062   0F93         CMP.W   #0x0, R15
   \   000064   0E24         JEQ     ??zcl_SendCommand_4
   \   000066   1F120200     PUSH.W  0x2(R15)
   \   00006A   4F46         MOV.B   R6, R15
   \   00006C   5E410200     MOV.B   0x2(SP), R14
   \   000070   7EF00300     AND.B   #0x3, R14
   \   000074   0D4B         MOV.W   R11, R13
   \   000076   4C4A         MOV.B   R10, R12
   \   000078   ........     CALLA   #zcl_DeviceOperational
   \   00007C   2153         ADD.W   #0x2, SP
   \   00007E   4C93         CMP.B   #0x0, R12
   \   000080   0220         JNE     ??zcl_SendCommand_5
    870            {
    871              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_4:
   \   000082   5C43         MOV.B   #0x1, R12
   \   000084   4C3C         JMP     ??zcl_SendCommand_2
    872            }
   \                     ??zcl_SendCommand_5:
   \   000086   1F412000     MOV.W   0x20(SP), R15
    873          
    874            // Fill in the Maufacturer Code
    875            if ( manuCode != 0 )
   \   00008A   0F93         CMP.W   #0x0, R15
   \   00008C   0424         JEQ     ??zcl_SendCommand_6
    876            {
    877              hdr.fc.manuSpecific = 1;
   \   00008E   A1D20000     BIS.W   #0x4, 0(SP)
    878              hdr.manuCode = manuCode;
   \   000092   814F0200     MOV.W   R15, 0x2(SP)
    879            }
    880          
    881            // Set the Command Direction
    882            if ( direction )
   \                     ??zcl_SendCommand_6:
   \   000096   C1931C00     CMP.B   #0x0, 0x1c(SP)
   \   00009A   0324         JEQ     ??zcl_SendCommand_7
    883            {
    884              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00009C   B1D20000     BIS.W   #0x8, 0(SP)
   \   0000A0   023C         JMP     ??zcl_SendCommand_8
    885            }
    886            else
    887            {
    888              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_7:
   \   0000A2   B1C20000     BIC.W   #0x8, 0(SP)
    889            }
    890          
    891            // Set the Disable Default Response field
    892            if ( disableDefaultRsp )
   \                     ??zcl_SendCommand_8:
   \   0000A6   C1931E00     CMP.B   #0x0, 0x1e(SP)
   \   0000AA   0424         JEQ     ??zcl_SendCommand_9
    893            {
    894              hdr.fc.disableDefaultRsp = 1;
   \   0000AC   B1D010000000 BIS.W   #0x10, 0(SP)
   \   0000B2   033C         JMP     ??zcl_SendCommand_10
    895            }
    896            else
    897            {
    898              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_9:
   \   0000B4   B1C010000000 BIC.W   #0x10, 0(SP)
    899            }
    900          
    901            // Fill in the Transaction Sequence Number
    902            hdr.transSeqNum = seqNum;
   \                     ??zcl_SendCommand_10:
   \   0000BA   D14122000400 MOV.B   0x22(SP), 0x4(SP)
    903          
    904            // Fill in the command
    905            hdr.commandID = cmd;
   \   0000C0   C1460500     MOV.B   R6, 0x5(SP)
    906          
    907            // calculate the needed buffer size
    908            msgLen = zclCalcHdrSize( &hdr );
   \   0000C4   7A400300     MOV.B   #0x3, R10
   \   0000C8   A1B20000     BIT.W   #0x4, 0(SP)
   \   0000CC   0228         JNC     ??zcl_SendCommand_11
   \   0000CE   7A400500     MOV.B   #0x5, R10
   \                     ??zcl_SendCommand_11:
   \   0000D2   14412400     MOV.W   0x24(SP), R4
    909            msgLen += cmdFormatLen;
   \   0000D6   0A54         ADD.W   R4, R10
    910          
    911            // Allocate the buffer needed
    912            msgBuf = zcl_mem_alloc( msgLen );
   \   0000D8   0C4A         MOV.W   R10, R12
   \   0000DA   ........     CALLA   #?Subroutine6
    913            if ( msgBuf != NULL )
   \                     ??CrossCallReturnLabel_2:
   \   0000DE   1C24         JEQ     ??zcl_SendCommand_12
    914            {
    915              // Fill in the ZCL Header
    916              pBuf = zclBuildHdr( &hdr, msgBuf );
   \   0000E0   0D4C         MOV.W   R12, R13
   \   0000E2   0C41         MOV.W   SP, R12
   \   0000E4   0C53         ADD.W   #0x0, R12
   \   0000E6   ........     CALLA   #zclBuildHdr
    917          
    918              // Fill in the command frame
    919              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   0000EA   0E44         MOV.W   R4, R14
   \   0000EC   1D412600     MOV.W   0x26(SP), R13
   \   0000F0   ........     CALLA   #osal_memcpy
    920          
    921              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
    922                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   0000F4   70121E00     PUSH.B  #0x1e
   \   0000F8   4912         PUSH.B  R9
   \   0000FA   3012....     PUSH.W  #zcl_TransID
   \   0000FE   0612         PUSH.W  R6
   \   000100   0F4A         MOV.W   R10, R15
   \   000102   0E4B         MOV.W   R11, R14
   \   000104   0D48         MOV.W   R8, R13
   \   000106   0C47         MOV.W   R7, R12
   \   000108   ........     CALLA   #AF_DataRequest
   \   00010C   4A4C         MOV.B   R12, R10
    923              zcl_mem_free ( msgBuf );
   \   00010E   0C46         MOV.W   R6, R12
   \   000110   ........     CALLA   #osal_mem_free
   \   000114   3152         ADD.W   #0x8, SP
   \   000116   023C         JMP     ??zcl_SendCommand_13
    924            }
    925            else
    926            {
    927              status = ZMemError;
   \                     ??zcl_SendCommand_12:
   \   000118   7A401000     MOV.B   #0x10, R10
    928            }
    929          
    930            return ( status );
   \                     ??zcl_SendCommand_13:
   \   00011C   4C4A         MOV.B   R10, R12
   \                     ??zcl_SendCommand_2:
   \   00011E   31500600     ADD.W   #0x6, SP
   \   000122   7417         POPM.W  #0x8, R11
   \   000124   1001         RETA
    931          }
    932          
    933          #ifdef ZCL_READ
    934          /*********************************************************************
    935           * @fn      zcl_SendRead
    936           *
    937           * @brief   Send a Read command
    938           *
    939           * @param   srcEP - Application's endpoint
    940           * @param   dstAddr - destination address
    941           * @param   clusterID - cluster ID
    942           * @param   readCmd - read command to be sent
    943           * @param   direction - direction of the command
    944           * @param   seqNum - transaction sequence number
    945           *
    946           * @return  ZSuccess if OK
    947           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   4C4A         MOV.B   R10, R12
   \   000002   5617         POPM.W  #0x6, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine20:
   \   000000   4C4A         MOV.B   R10, R12
   \   000002   ........     BRA     #zcl_SendCommand

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine14:
   \   000000   4A4C         MOV.B   R12, R10
   \   000002                REQUIRE ??Subroutine26_0
   \   000002                // Fall through to label ??Subroutine26_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine26_0:
   \   000000   0C48         MOV.W   R8, R12
   \   000002   ........     BRA     #osal_mem_free

   \                                 In  segment CODE, align 2
    948          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
    949                                  uint16 clusterID, zclReadCmd_t *readCmd,
    950                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    951          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   094D         MOV.W   R13, R9
   \   000006   064E         MOV.W   R14, R6
   \   000008   074F         MOV.W   R15, R7
    952            uint16 dataLen;
    953            uint8 *buf;
    954            uint8 *pBuf;
    955            ZStatus_t status;
    956          
    957            dataLen = readCmd->numAttr * 2; // Attribute ID
   \   00000A   6B4F         MOV.B   @R15, R11
   \   00000C   0B5B         RLA.W   R11
    958          
    959            buf = zcl_mem_alloc( dataLen );
   \   00000E   0C4B         MOV.W   R11, R12
   \   000010   ........     CALLA   #??Subroutine4_0
    960            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_37:
   \   000014   2024         JEQ     ??zcl_SendRead_1
    961            {
    962              uint8 i;
    963          
    964              // Load the buffer - serially
    965              pBuf = buf;
   \   000016   0F4C         MOV.W   R12, R15
    966              for (i = 0; i < readCmd->numAttr; i++)
   \   000018   4E43         MOV.B   #0x0, R14
   \   00001A   073C         JMP     ??zcl_SendRead_2
    967              {
    968                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_0:
   \   00001C   4C4E         MOV.B   R14, R12
   \   00001E   0C5C         RLA.W   R12
   \   000020   0D47         MOV.W   R7, R13
   \   000022   0D5C         ADD.W   R12, R13
   \   000024   2D53         ADD.W   #0x2, R13
   \   000026   ........     CALLA   #?Subroutine8
    969                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
    970              }
   \                     ??zcl_SendRead_2:
   \   00002A   6E97         CMP.B   @R7, R14
   \   00002C   F72B         JNC     ??zcl_SendRead_0
    971          
    972              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    973                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00002E   0812         PUSH.W  R8
   \   000030   0B12         PUSH.W  R11
   \   000032   51121A00     PUSH.B  0x1a(SP)
   \   000036   0312         PUSH.W  #0x0
   \   000038   51121C00     PUSH.B  0x1c(SP)
   \   00003C   51121C00     PUSH.B  0x1c(SP)
   \   000040   4312         PUSH.B  #0x0
   \   000042   4F43         MOV.B   #0x0, R15
   \   000044   0E46         MOV.W   R6, R14
   \   000046   0D49         MOV.W   R9, R13
   \   000048   ........     CALLA   #?Subroutine20
    974              zcl_mem_free( buf );
    975            }
   \                     ??CrossCallReturnLabel_13:
   \   00004C   ........     CALLA   #?Subroutine14
   \                     ??CrossCallReturnLabel_31:
   \   000050   31500E00     ADD.W   #0xe, SP
   \   000054   023C         JMP     ??zcl_SendRead_3
    976            else
    977            {
    978              status = ZMemError;
   \                     ??zcl_SendRead_1:
   \   000056   7A401000     MOV.B   #0x10, R10
    979            }
    980          
    981            return ( status );
   \                     ??zcl_SendRead_3:
   \   00005A   ....         JMP     ?Subroutine3
   \   00005C   0343         NOP
    982          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine8:
   \   000000   EF4D0000     MOV.B   @R13, 0(R15)
   \   000004   1F53         ADD.W   #0x1, R15
   \   000006   DF4D01000000 MOV.B   0x1(R13), 0(R15)
   \   00000C   1F53         ADD.W   #0x1, R15
   \   00000E   5E53         ADD.B   #0x1, R14
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ??Subroutine4_0:
   \   000000   ........     CALLA   #osal_mem_alloc
   \   000004   084C         MOV.W   R12, R8
   \   000006   0C93         CMP.W   #0x0, R12
   \   000008   1001         RETA
    983          
    984          /*********************************************************************
    985           * @fn      zcl_SendReadRsp
    986           *
    987           * @brief   Send a Read Response command.
    988           *
    989           * @param   srcEP - Application's endpoint
    990           * @param   dstAddr - destination address
    991           * @param   clusterID - cluster ID
    992           * @param   readRspCmd - read response command to be sent
    993           * @param   direction - direction of the command
    994           * @param   seqNum - transaction sequence number
    995           *
    996           * @return  ZSuccess if OK
    997           */

   \                                 In  segment CODE, align 2, keep-with-next
    998          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
    999                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
   1000                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1001          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   4A4C         MOV.B   R12, R10
   \   000006   054D         MOV.W   R13, R5
   \   000008   0B4E         MOV.W   R14, R11
   \   00000A   094F         MOV.W   R15, R9
   1002            uint8 *buf;
   1003            uint16 len = 0;
   \   00000C   0643         MOV.W   #0x0, R6
   1004            ZStatus_t status;
   1005            uint8 i;
   1006          
   1007            // calculate the size of the command
   1008            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   00000E   4743         MOV.B   #0x0, R7
   \   000010   073C         JMP     ??zcl_SendReadRsp_4
   1009            {
   1010              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1011          
   1012              len += 2 + 1; // Attribute ID + Status
   1013          
   1014              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1015              {
   1016                len++; // Attribute Data Type length
   1017          
   1018                // Attribute Data length
   1019                if ( statusRec->data != NULL )
   1020                {
   1021                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   1022                }
   1023                else
   1024                {
   1025                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_1:
   \   000012   2E4F         MOV.W   @R15, R14
   \   000014   0D4B         MOV.W   R11, R13
   \   000016   4C4A         MOV.B   R10, R12
   \   000018   ........     CALLA   #zclGetAttrDataLengthUsingCB
   \                     ??zcl_SendReadRsp_6:
   \   00001C   065C         ADD.W   R12, R6
   1026                }
   \                     ??zcl_SendReadRsp_0:
   \   00001E   5753         ADD.B   #0x1, R7
   \                     ??zcl_SendReadRsp_4:
   \   000020   6799         CMP.B   @R9, R7
   \   000022   152C         JC      ??zcl_SendReadRsp_5
   \   000024   0E47         MOV.W   R7, R14
   \   000026                RPT     #0x5
   \   000026   44180E57     ADDX.W  R7, R14
   \   00002A   0F49         MOV.W   R9, R15
   \   00002C   0F5E         ADD.W   R14, R15
   \   00002E   2F53         ADD.W   #0x2, R15
   \   000030   36500300     ADD.W   #0x3, R6
   \   000034   CF930200     CMP.B   #0x0, 0x2(R15)
   \   000038   F223         JNE     ??zcl_SendReadRsp_0
   \   00003A   1653         ADD.W   #0x1, R6
   \   00003C   1D4F0400     MOV.W   0x4(R15), R13
   \   000040   0D93         CMP.W   #0x0, R13
   \   000042   E727         JEQ     ??zcl_SendReadRsp_1
   \   000044   5C4F0300     MOV.B   0x3(R15), R12
   \   000048   ........     CALLA   #zclGetAttrDataLength
   \   00004C   E73F         JMP     ??zcl_SendReadRsp_6
   1027              }
   1028            }
   1029          
   1030            buf = zcl_mem_alloc( len );
   \                     ??zcl_SendReadRsp_5:
   \   00004E   0C46         MOV.W   R6, R12
   \   000050   ........     CALLA   #??Subroutine4_0
   1031            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_36:
   \   000054   4924         JEQ     ??zcl_SendReadRsp_7
   1032            {
   1033              // Load the buffer - serially
   1034              uint8 *pBuf = buf;
   \   000056   044C         MOV.W   R12, R4
   1035          
   1036              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000058   4743         MOV.B   #0x0, R7
   \   00005A   0D3C         JMP     ??zcl_SendReadRsp_8
   1037              {
   1038                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1039          
   1040                *pBuf++ = LO_UINT16( statusRec->attrID );
   1041                *pBuf++ = HI_UINT16( statusRec->attrID );
   1042                *pBuf++ = statusRec->status;
   1043          
   1044                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1045                {
   1046                  *pBuf++ = statusRec->dataType;
   1047          
   1048                  if ( statusRec->data != NULL )
   1049                  {
   1050                    // Copy attribute data to the buffer to be sent out
   1051                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   1052                  }
   1053                  else
   1054                  {
   1055                    uint16 dataLen;
   1056          
   1057                    // Read attribute data directly into the buffer to be sent out
   1058                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_3:
   \   00005C   0F41         MOV.W   SP, R15
   \   00005E   0F53         ADD.W   #0x0, R15
   \   000060   0F12         PUSH.W  R15
   \   000062   0F44         MOV.W   R4, R15
   \   000064   2E4C         MOV.W   @R12, R14
   \   000066   0D4B         MOV.W   R11, R13
   \   000068   4C4A         MOV.B   R10, R12
   \   00006A   ........     CALLA   #zclReadAttrDataUsingCB
   1059                    pBuf += dataLen;
   \   00006E   14510200     ADD.W   0x2(SP), R4
   \   000072   2153         ADD.W   #0x2, SP
   1060                  }
   \                     ??zcl_SendReadRsp_2:
   \   000074   5753         ADD.B   #0x1, R7
   \                     ??zcl_SendReadRsp_8:
   \   000076   6799         CMP.B   @R9, R7
   \   000078   232C         JC      ??zcl_SendReadRsp_9
   \   00007A   0F47         MOV.W   R7, R15
   \   00007C                RPT     #0x5
   \   00007C   44180F57     ADDX.W  R7, R15
   \   000080   0C49         MOV.W   R9, R12
   \   000082   0C5F         ADD.W   R15, R12
   \   000084   2C53         ADD.W   #0x2, R12
   \   000086   E44C0000     MOV.B   @R12, 0(R4)
   \   00008A   1453         ADD.W   #0x1, R4
   \   00008C   D44C01000000 MOV.B   0x1(R12), 0(R4)
   \   000092   1453         ADD.W   #0x1, R4
   \   000094   D44C02000000 MOV.B   0x2(R12), 0(R4)
   \   00009A   1453         ADD.W   #0x1, R4
   \   00009C   CC930200     CMP.B   #0x0, 0x2(R12)
   \   0000A0   E923         JNE     ??zcl_SendReadRsp_2
   \   0000A2   D44C03000000 MOV.B   0x3(R12), 0(R4)
   \   0000A8   1453         ADD.W   #0x1, R4
   \   0000AA   1D4C0400     MOV.W   0x4(R12), R13
   \   0000AE   0D93         CMP.W   #0x0, R13
   \   0000B0   D527         JEQ     ??zcl_SendReadRsp_3
   \   0000B2   0E44         MOV.W   R4, R14
   \   0000B4   5C4C0300     MOV.B   0x3(R12), R12
   \   0000B8   ........     CALLA   #zclSerializeData
   \   0000BC   044C         MOV.W   R12, R4
   \   0000BE   DA3F         JMP     ??zcl_SendReadRsp_2
   1061                }
   1062              } // for loop
   1063          
   1064              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
   1065                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_9:
   \   0000C0   0812         PUSH.W  R8
   \   0000C2   0612         PUSH.W  R6
   \   0000C4   51122000     PUSH.B  0x20(SP)
   \   0000C8   0312         PUSH.W  #0x0
   \   0000CA   51122200     PUSH.B  0x22(SP)
   \   0000CE   51122200     PUSH.B  0x22(SP)
   \   0000D2   4312         PUSH.B  #0x0
   \   0000D4   5F43         MOV.B   #0x1, R15
   \   0000D6   0E4B         MOV.W   R11, R14
   \   0000D8   0D45         MOV.W   R5, R13
   \   0000DA   ........     CALLA   #?Subroutine20
   1066              zcl_mem_free( buf );
   1067            }
   \                     ??CrossCallReturnLabel_14:
   \   0000DE   ........     CALLA   #?Subroutine14
   \                     ??CrossCallReturnLabel_32:
   \   0000E2   31500E00     ADD.W   #0xe, SP
   \   0000E6   023C         JMP     ??zcl_SendReadRsp_10
   1068            else
   1069            {
   1070              status = ZMemError;
   \                     ??zcl_SendReadRsp_7:
   \   0000E8   7A401000     MOV.B   #0x10, R10
   1071            }
   1072          
   1073            return ( status );
   \                     ??zcl_SendReadRsp_10:
   \   0000EC   4C4A         MOV.B   R10, R12
   \   0000EE   2153         ADD.W   #0x2, SP
   \   0000F0   7417         POPM.W  #0x8, R11
   \   0000F2   1001         RETA
   1074          }
   1075          #endif // ZCL_READ
   1076          
   1077          #ifdef ZCL_WRITE
   1078          /*********************************************************************
   1079           * @fn      sendWriteRequest
   1080           *
   1081           * @brief   Send a Write command
   1082           *
   1083           * @param   dstAddr - destination address
   1084           * @param   clusterID - cluster ID
   1085           * @param   writeCmd - write command to be sent
   1086           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
   1087           * @param   direction - direction of the command
   1088           * @param   seqNum - transaction sequence number
   1089           *
   1090           * @return  ZSuccess if OK
   1091           */

   \                                 In  segment CODE, align 2, keep-with-next
   1092          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
   1093                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
   1094                                          uint8 disableDefaultRsp, uint8 seqNum )
   1095          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   084D         MOV.W   R13, R8
   \   000006   094E         MOV.W   R14, R9
   \   000008   064F         MOV.W   R15, R6
   1096            uint8 *buf;
   1097            uint16 dataLen = 0;
   \   00000A   0743         MOV.W   #0x0, R7
   1098            ZStatus_t status;
   1099            uint8 i;
   1100          
   1101            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   00000C   4443         MOV.B   #0x0, R4
   \   00000E   103C         JMP     ??zcl_SendWriteRequest_2
   1102            {
   1103              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_0:
   \   000010   0B44         MOV.W   R4, R11
   \   000012                RPT     #0x5
   \   000012   44180B54     ADDX.W  R4, R11
   \   000016   0F46         MOV.W   R6, R15
   \   000018   0F5B         ADD.W   R11, R15
   \   00001A   2F53         ADD.W   #0x2, R15
   1104          
   1105              dataLen += 2 + 1; // Attribute ID + Attribute Type
   1106          
   1107              // Attribute Data
   1108              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \   00001C   1D4F0400     MOV.W   0x4(R15), R13
   \   000020   5C4F0200     MOV.B   0x2(R15), R12
   \   000024   ........     CALLA   #zclGetAttrDataLength
   \   000028   3C500300     ADD.W   #0x3, R12
   \   00002C   075C         ADD.W   R12, R7
   1109            }
   \   00002E   5453         ADD.B   #0x1, R4
   \                     ??zcl_SendWriteRequest_2:
   \   000030   6496         CMP.B   @R6, R4
   \   000032   EE2B         JNC     ??zcl_SendWriteRequest_0
   1110          
   1111            buf = zcl_mem_alloc( dataLen );
   \   000034   0C47         MOV.W   R7, R12
   \   000036   ........     CALLA   #osal_mem_alloc
   \   00003A   0B4C         MOV.W   R12, R11
   1112            if ( buf != NULL )
   \   00003C   0C93         CMP.W   #0x0, R12
   \   00003E   3524         JEQ     ??zcl_SendWriteRequest_3
   1113            {
   1114              // Load the buffer - serially
   1115              uint8 *pBuf = buf;
   \   000040   0E4C         MOV.W   R12, R14
   1116              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000042   4443         MOV.B   #0x0, R4
   \   000044   193C         JMP     ??zcl_SendWriteRequest_4
   1117              {
   1118                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_1:
   \   000046   0D44         MOV.W   R4, R13
   \   000048                RPT     #0x5
   \   000048   44180D54     ADDX.W  R4, R13
   \   00004C   0F46         MOV.W   R6, R15
   \   00004E   0F5D         ADD.W   R13, R15
   \   000050   2F53         ADD.W   #0x2, R15
   1119          
   1120                *pBuf++ = LO_UINT16( statusRec->attrID );
   \   000052   EE4F0000     MOV.B   @R15, 0(R14)
   \   000056   1E53         ADD.W   #0x1, R14
   1121                *pBuf++ = HI_UINT16( statusRec->attrID );
   \   000058   DE4F01000000 MOV.B   0x1(R15), 0(R14)
   \   00005E   1E53         ADD.W   #0x1, R14
   1122                *pBuf++ = statusRec->dataType;
   \   000060   DE4F02000000 MOV.B   0x2(R15), 0(R14)
   \   000066   1E53         ADD.W   #0x1, R14
   1123          
   1124                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   \   000068   1D4F0400     MOV.W   0x4(R15), R13
   \   00006C   5C4F0200     MOV.B   0x2(R15), R12
   \   000070   ........     CALLA   #zclSerializeData
   \   000074   0E4C         MOV.W   R12, R14
   1125              }
   \   000076   5453         ADD.B   #0x1, R4
   \                     ??zcl_SendWriteRequest_4:
   \   000078   6496         CMP.B   @R6, R4
   \   00007A   E52B         JNC     ??zcl_SendWriteRequest_1
   1126          
   1127              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
   1128                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00007C   0B12         PUSH.W  R11
   \   00007E   0712         PUSH.W  R7
   \   000080   51122000     PUSH.B  0x20(SP)
   \   000084   0312         PUSH.W  #0x0
   \   000086   51122200     PUSH.B  0x22(SP)
   \   00008A   51122200     PUSH.B  0x22(SP)
   \   00008E   4312         PUSH.B  #0x0
   \   000090   5F412200     MOV.B   0x22(SP), R15
   \   000094   0E49         MOV.W   R9, R14
   \   000096   0D48         MOV.W   R8, R13
   \   000098   ........     CALLA   #?Subroutine20
   \                     ??CrossCallReturnLabel_15:
   \   00009C   4A4C         MOV.B   R12, R10
   1129              zcl_mem_free( buf );
   \   00009E   0C4B         MOV.W   R11, R12
   \   0000A0   ........     CALLA   #osal_mem_free
   \   0000A4   31500E00     ADD.W   #0xe, SP
   \   0000A8   023C         JMP     ??zcl_SendWriteRequest_5
   1130            }
   1131            else
   1132            {
   1133              status = ZMemError;
   \                     ??zcl_SendWriteRequest_3:
   \   0000AA   7A401000     MOV.B   #0x10, R10
   1134            }
   1135          
   1136            return ( status);
   \                     ??zcl_SendWriteRequest_5:
   \   0000AE   4C4A         MOV.B   R10, R12
   \   0000B0   7417         POPM.W  #0x8, R11
   \   0000B2   1001         RETA
   1137          }
   1138          
   1139          /*********************************************************************
   1140           * @fn      zcl_SendWriteRsp
   1141           *
   1142           * @brief   Send a Write Response command
   1143           *
   1144           * @param   dstAddr - destination address
   1145           * @param   clusterID - cluster ID
   1146           * @param   wrtieRspCmd - write response command to be sent
   1147           * @param   direction - direction of the command
   1148           * @param   seqNum - transaction sequence number
   1149           *
   1150           * @return  ZSuccess if OK
   1151           */

   \                                 In  segment CODE, align 2, keep-with-next
   1152          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
   1153                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
   1154                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1155          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   \   000006   084E         MOV.W   R14, R8
   \   000008   064F         MOV.W   R15, R6
   1156            uint16 dataLen;
   1157            uint8 *buf;
   1158            ZStatus_t status;
   1159          
   1160            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   \   00000A   6F46         MOV.B   @R6, R15
   \   00000C   074F         MOV.W   R15, R7
   \   00000E                RPT     #0x2
   \   00000E   4118075F     ADDX.W  R15, R7
   1161          
   1162            buf = zcl_mem_alloc( dataLen );
   \   000012   0C47         MOV.W   R7, R12
   \   000014   ........     CALLA   #osal_mem_alloc
   \   000018   094C         MOV.W   R12, R9
   1163            if ( buf != NULL )
   \   00001A   0C93         CMP.W   #0x0, R12
   \   00001C   2D24         JEQ     ??zcl_SendWriteRsp_1
   1164            {
   1165              // Load the buffer - serially
   1166              uint8 i;
   1167              uint8 *pBuf = buf;
   \   00001E   0F4C         MOV.W   R12, R15
   1168              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   000020   4E43         MOV.B   #0x0, R14
   \   000022   0B3C         JMP     ??zcl_SendWriteRsp_2
   1169              {
   1170                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_0:
   \   000024   4C4E         MOV.B   R14, R12
   \   000026   5C06         RLAM.W  #0x2, R12
   \   000028   0D46         MOV.W   R6, R13
   \   00002A   0D5C         ADD.W   R12, R13
   \   00002C   DF4D02000000 MOV.B   0x2(R13), 0(R15)
   \   000032   1F53         ADD.W   #0x1, R15
   1171                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   \   000034   2D52         ADD.W   #0x4, R13
   \   000036   ........     CALLA   #?Subroutine8
   1172                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   1173              }
   \                     ??zcl_SendWriteRsp_2:
   \   00003A   6D46         MOV.B   @R6, R13
   \   00003C   4E9D         CMP.B   R13, R14
   \   00003E   F22B         JNC     ??zcl_SendWriteRsp_0
   1174          
   1175              // If there's only a single status record and its status field is set to
   1176              // SUCCESS then omit the attribute ID field.
   1177              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000040   5D93         CMP.B   #0x1, R13
   \   000042   0420         JNE     ??zcl_SendWriteRsp_3
   \   000044   C6930200     CMP.B   #0x0, 0x2(R6)
   \   000048   0120         JNE     ??zcl_SendWriteRsp_3
   1178              {
   1179                dataLen = 1;
   \   00004A   1743         MOV.W   #0x1, R7
   1180              }
   1181          
   1182              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1183                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_3:
   \   00004C   0912         PUSH.W  R9
   \   00004E   0712         PUSH.W  R7
   \   000050   51121A00     PUSH.B  0x1a(SP)
   \   000054   0312         PUSH.W  #0x0
   \   000056   51121C00     PUSH.B  0x1c(SP)
   \   00005A   51121C00     PUSH.B  0x1c(SP)
   \   00005E   4312         PUSH.B  #0x0
   \   000060   6F42         MOV.B   #0x4, R15
   \   000062   0E48         MOV.W   R8, R14
   \   000064   0D4B         MOV.W   R11, R13
   \   000066   ........     CALLA   #?Subroutine20
   \                     ??CrossCallReturnLabel_16:
   \   00006A   4A4C         MOV.B   R12, R10
   1184              zcl_mem_free( buf );
   \   00006C   0C49         MOV.W   R9, R12
   \   00006E   ........     CALLA   #osal_mem_free
   \   000072   31500E00     ADD.W   #0xe, SP
   \   000076   023C         JMP     ??zcl_SendWriteRsp_4
   1185            }
   1186            else
   1187            {
   1188              status = ZMemError;
   \                     ??zcl_SendWriteRsp_1:
   \   000078   7A401000     MOV.B   #0x10, R10
   1189            }
   1190          
   1191            return ( status );
   \                     ??zcl_SendWriteRsp_4:
   \   00007C                REQUIRE ?Subroutine3
   \   00007C                // Fall through to label ?Subroutine3
   1192          }
   1193          #endif // ZCL_WRITE
   1194          
   1195          #ifdef ZCL_REPORT
   1196          /*********************************************************************
   1197           * @fn      zcl_SendConfigReportCmd
   1198           *
   1199           * @brief   Send a Configure Reporting command
   1200           *
   1201           * @param   dstAddr - destination address
   1202           * @param   clusterID - cluster ID
   1203           * @param   cfgReportCmd - configure reporting command to be sent
   1204           * @param   direction - direction of the command
   1205           * @param   seqNum - transaction sequence number
   1206           *
   1207           * @return  ZSuccess if OK
   1208           */
   1209          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1210                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1211                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1212          {
   1213            uint8 *buf;
   1214            uint16 dataLen = 0;
   1215            ZStatus_t status;
   1216            uint8 i;
   1217          
   1218            // Find out the data length
   1219            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1220            {
   1221              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1222          
   1223              dataLen += 1 + 2; // Direction + Attribute ID
   1224          
   1225              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1226              {
   1227                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1228          
   1229                // Find out the size of the Reportable Change field (for Analog data types)
   1230                if ( zclAnalogDataType( reportRec->dataType ) )
   1231                {
   1232                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1233                }
   1234              }
   1235              else
   1236              {
   1237                dataLen += 2; // Timeout Period
   1238              }
   1239            }
   1240          
   1241            buf = zcl_mem_alloc( dataLen );
   1242            if ( buf != NULL )
   1243            {
   1244              // Load the buffer - serially
   1245              uint8 *pBuf = buf;
   1246          
   1247              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1248              {
   1249                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1250          
   1251                *pBuf++ = reportRec->direction;
   1252                *pBuf++ = LO_UINT16( reportRec->attrID );
   1253                *pBuf++ = HI_UINT16( reportRec->attrID );
   1254          
   1255                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1256                {
   1257                  *pBuf++ = reportRec->dataType;
   1258                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1259                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1260                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1261                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1262          
   1263                  if ( zclAnalogDataType( reportRec->dataType ) )
   1264                  {
   1265                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1266                  }
   1267                }
   1268                else
   1269                {
   1270                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   1271                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1272                }
   1273              } // for loop
   1274          
   1275              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1276                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1277              zcl_mem_free( buf );
   1278            }
   1279            else
   1280            {
   1281              status = ZMemError;
   1282            }
   1283          
   1284            return ( status );
   1285          }
   1286          
   1287          /*********************************************************************
   1288           * @fn      zcl_SendConfigReportRspCmd
   1289           *
   1290           * @brief   Send a Configure Reporting Response command
   1291           *
   1292           * @param   dstAddr - destination address
   1293           * @param   clusterID - cluster ID
   1294           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1295           * @param   direction - direction of the command
   1296           * @param   seqNum - transaction sequence number
   1297           *
   1298           * @return  ZSuccess if OK
   1299           */
   1300          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1301                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1302                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1303          {
   1304            uint16 dataLen;
   1305            uint8 *buf;
   1306            ZStatus_t status;
   1307          
   1308            // Atrribute list (Status, Direction and Attribute ID)
   1309            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   1310          
   1311            buf = zcl_mem_alloc( dataLen );
   1312            if ( buf != NULL )
   1313            {
   1314              // Load the buffer - serially
   1315              uint8 *pBuf = buf;
   1316              uint8 i;
   1317          
   1318              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   1319              {
   1320                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   1321                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   1322                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1323                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1324              }
   1325          
   1326              // If there's only a single status record and its status field is set to
   1327              // SUCCESS then omit the attribute ID field.
   1328              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   1329              {
   1330                dataLen = 1;
   1331              }
   1332          
   1333              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1334                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1335                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   1336              zcl_mem_free( buf );
   1337            }
   1338            else
   1339            {
   1340              status = ZMemError;
   1341            }
   1342          
   1343            return ( status );
   1344          }
   1345          
   1346          /*********************************************************************
   1347           * @fn      zcl_SendReadReportCfgCmd
   1348           *
   1349           * @brief   Send a Read Reporting Configuration command
   1350           *
   1351           * @param   dstAddr - destination address
   1352           * @param   clusterID - cluster ID
   1353           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1354           * @param   direction - direction of the command
   1355           * @param   seqNum - transaction sequence number
   1356           *
   1357           * @return  ZSuccess if OK
   1358           */
   1359          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1360                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1361                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1362          {
   1363            uint16 dataLen;
   1364            uint8 *buf;
   1365            ZStatus_t status;
   1366          
   1367            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1368          
   1369            buf = zcl_mem_alloc( dataLen );
   1370            if ( buf != NULL )
   1371            {
   1372              // Load the buffer - serially
   1373              uint8 *pBuf = buf;
   1374              uint8 i;
   1375          
   1376              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   1377              {
   1378                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   1379                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1380                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1381              }
   1382          
   1383              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1384                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1385              zcl_mem_free( buf );
   1386            }
   1387            else
   1388            {
   1389              status = ZMemError;
   1390            }
   1391          
   1392            return ( status );
   1393          }
   1394          
   1395          /*********************************************************************
   1396           * @fn      zcl_SendReadReportCfgRspCmd
   1397           *
   1398           * @brief   Send a Read Reporting Configuration Response command
   1399           *
   1400           * @param   dstAddr - destination address
   1401           * @param   clusterID - cluster ID
   1402           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1403           * @param   direction - direction of the command
   1404           * @param   seqNum - transaction sequence number
   1405           *
   1406           * @return  ZSuccess if OK
   1407           */
   1408          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1409                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1410                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1411          {
   1412            uint8 *buf;
   1413            uint16 dataLen = 0;
   1414            ZStatus_t status;
   1415            uint8 i;
   1416          
   1417            // Find out the data length
   1418            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1419            {
   1420              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1421          
   1422              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1423          
   1424              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1425              {
   1426                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1427                {
   1428                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1429          
   1430                  // Find out the size of the Reportable Change field (for Analog data types)
   1431                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1432                  {
   1433                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1434                  }
   1435                }
   1436                else
   1437                {
   1438                  dataLen += 2; // Timeout Period
   1439                }
   1440              }
   1441            }
   1442          
   1443            buf = zcl_mem_alloc( dataLen );
   1444            if ( buf != NULL )
   1445            {
   1446              // Load the buffer - serially
   1447              uint8 *pBuf = buf;
   1448          
   1449              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1450              {
   1451                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1452          
   1453                *pBuf++ = reportRspRec->status;
   1454                *pBuf++ = reportRspRec->direction;
   1455                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1456                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1457          
   1458                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1459                {
   1460                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1461                  {
   1462                    *pBuf++ = reportRspRec->dataType;
   1463                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1464                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1465                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1466                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1467          
   1468                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1469                    {
   1470                      pBuf = zclSerializeData( reportRspRec->dataType,
   1471                                               reportRspRec->reportableChange, pBuf );
   1472                    }
   1473                  }
   1474                  else
   1475                  {
   1476                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   1477                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1478                  }
   1479                }
   1480              }
   1481          
   1482              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1483                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1484                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1485              zcl_mem_free( buf );
   1486            }
   1487            else
   1488            {
   1489              status = ZMemError;
   1490            }
   1491          
   1492            return ( status );
   1493          }
   1494          
   1495          /*********************************************************************
   1496           * @fn      zcl_SendReportCmd
   1497           *
   1498           * @brief   Send a Report command
   1499           *
   1500           * @param   dstAddr - destination address
   1501           * @param   clusterID - cluster ID
   1502           * @param   reportCmd - report command to be sent
   1503           * @param   direction - direction of the command
   1504           * @param   seqNum - transaction sequence number
   1505           *
   1506           * @return  ZSuccess if OK
   1507           */
   1508          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1509                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1510                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1511          {
   1512            uint16 dataLen = 0;
   1513            uint8 *buf;
   1514            ZStatus_t status;
   1515            uint8 i;
   1516          
   1517            // calculate the size of the command
   1518            for ( i = 0; i < reportCmd->numAttr; i++ )
   1519            {
   1520              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   1521          
   1522              dataLen += 2 + 1; // Attribute ID + data type
   1523          
   1524              // Attribute Data
   1525              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1526            }
   1527          
   1528            buf = zcl_mem_alloc( dataLen );
   1529            if ( buf != NULL )
   1530            {
   1531              // Load the buffer - serially
   1532              uint8 *pBuf = buf;
   1533          
   1534              for ( i = 0; i < reportCmd->numAttr; i++ )
   1535              {
   1536                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   1537          
   1538                *pBuf++ = LO_UINT16( reportRec->attrID );
   1539                *pBuf++ = HI_UINT16( reportRec->attrID );
   1540                *pBuf++ = reportRec->dataType;
   1541          
   1542                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1543              }
   1544          
   1545              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1546                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1547              zcl_mem_free( buf );
   1548            }
   1549            else
   1550            {
   1551              status = ZMemError;
   1552            }
   1553          
   1554            return ( status );
   1555          }
   1556          #endif // ZCL_REPORT
   1557          
   1558          /*********************************************************************
   1559           * @fn      zcl_SendDefaultRspCmd
   1560           *
   1561           * @brief   Send a Default Response command
   1562           *
   1563           *          Note: The manufacturer code field should be set if this
   1564           *          command is being sent in response to a manufacturer specific
   1565           *          command.
   1566           *
   1567           * @param   dstAddr - destination address
   1568           * @param   clusterID - cluster ID
   1569           * @param   defaultRspCmd - default response command to be sent
   1570           * @param   direction - direction of the command
   1571           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1572           * @param   seqNum - transaction sequence number
   1573           *
   1574           * @return  ZSuccess if OK
   1575           */

   \                                 In  segment CODE, align 2
   1576          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1577                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1578                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1579          {
   \   000000   2183         SUB.W   #0x2, SP
   1580            uint8 buf[2]; // Command ID and Status;
   1581          
   1582            // Load the buffer - serially
   1583            buf[0] = defaultRspCmd->commandID;
   \   000002   E14F0000     MOV.B   @R15, 0(SP)
   1584            buf[1] = defaultRspCmd->statusCode;
   \   000006   D14F01000100 MOV.B   0x1(R15), 0x1(SP)
   1585          
   1586            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1587                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   00000C   0F41         MOV.W   SP, R15
   \   00000E   0F53         ADD.W   #0x0, R15
   \   000010   0F12         PUSH.W  R15
   \   000012   2312         PUSH.W  #0x2
   \   000014   51121200     PUSH.B  0x12(SP)
   \   000018   11121200     PUSH.W  0x12(SP)
   \   00001C   51121200     PUSH.B  0x12(SP)
   \   000020   51121200     PUSH.B  0x12(SP)
   \   000024   4312         PUSH.B  #0x0
   \   000026   7F400B00     MOV.B   #0xb, R15
   \   00002A   ........     CALLA   #zcl_SendCommand
   \   00002E   31501000     ADD.W   #0x10, SP
   \   000032   1001         RETA
   1588          }
   1589          
   1590          #ifdef ZCL_DISCOVER
   1591          /*********************************************************************
   1592           * @fn      zcl_SendDiscoverCmdsCmd
   1593           *
   1594           * @brief   Send a Discover Commands command
   1595           *
   1596           * @param   dstAddr - destination address
   1597           * @param   clusterID - cluster ID
   1598           * @param   cmdType - requesting command ID
   1599           * @param   pDiscoverCmd - discover command to be sent
   1600           * @param   direction - direction of the command
   1601           * @param   seqNum - transaction sequence number
   1602           *
   1603           * @return  ZSuccess if OK
   1604           */
   1605          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   1606                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1607                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1608          {
   1609            uint8 payload[2]; // size of startCmdID and maxCmdID
   1610            ZStatus_t status;
   1611          
   1612            payload[0] = pDiscoverCmd->startCmdID;
   1613            payload[1] = pDiscoverCmd->maxCmdID;
   1614          
   1615            // Send message for either commands received or generated
   1616            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1617            {
   1618              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1619                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1620            }
   1621            else  // generated
   1622            {
   1623              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1624                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1625            }
   1626          
   1627            return ( status );
   1628          }
   1629          
   1630          /*********************************************************************
   1631           * @fn      zcl_SendDiscoverCmdsRspCmd
   1632           *
   1633           * @brief   Send a Discover Commands Response command
   1634           *
   1635           * @param   dstAddr - destination address
   1636           * @param   clusterID - cluster ID
   1637           * @param   pDiscoverRspCmd - response command to be sent
   1638           * @param   direction - direction of the command
   1639           * @param   seqNum - transaction sequence number
   1640           *
   1641           * @return  ZSuccess if OK
   1642           */
   1643          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1644                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1645                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1646          {
   1647            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   1648            uint8 *pCmdBuf;
   1649            uint8 i;
   1650            ZStatus_t status = ZSuccess;
   1651          
   1652            // allocate memory
   1653            pCmdBuf = zcl_mem_alloc( payloadSize );
   1654            if ( pCmdBuf != NULL )
   1655            {
   1656              uint8 *pBuf = pCmdBuf;
   1657          
   1658              // Load the buffer - serially
   1659              *pBuf++ = pDiscoverRspCmd->discComplete;
   1660              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   1661              {
   1662                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   1663              }
   1664          
   1665              // Send response message for either commands received or generated
   1666              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1667              {
   1668                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1669                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1670              }
   1671              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   1672              {
   1673                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1674                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1675              }
   1676          
   1677              zcl_mem_free( pCmdBuf );
   1678            }
   1679            else
   1680            {
   1681              status = ZMemError;
   1682            }
   1683          
   1684            return ( status );
   1685          }
   1686          
   1687          /*********************************************************************
   1688           * @fn      zcl_SendDiscoverAttrsCmd
   1689           *
   1690           * @brief   Send a Discover Attributes command
   1691           *
   1692           * @param   dstAddr - destination address
   1693           * @param   clusterID - cluster ID
   1694           * @param   pDiscoverCmd - discover command to be sent
   1695           * @param   direction - direction of the command
   1696           * @param   seqNum - transaction sequence number
   1697           *
   1698           * @return  ZSuccess if OK
   1699           */
   1700          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1701                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1702                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1703          {
   1704            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1705            uint8 *buf;
   1706            ZStatus_t status;
   1707          
   1708            buf = zcl_mem_alloc( dataLen );
   1709            if ( buf != NULL )
   1710            {
   1711              // Load the buffer - serially
   1712              uint8 *pBuf = buf;
   1713              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   1714              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   1715              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   1716          
   1717              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   1718                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1719              zcl_mem_free( buf );
   1720            }
   1721            else
   1722            {
   1723              status = ZMemError;
   1724            }
   1725          
   1726            return ( status );
   1727          }
   1728          
   1729          /*********************************************************************
   1730           * @fn      zcl_SendDiscoverAttrsRspCmd
   1731           *
   1732           * @brief   Send a Discover Attributes Response command
   1733           *
   1734           * @param   dstAddr - destination address
   1735           * @param   clusterID - cluster ID
   1736           * @param   reportRspCmd - report response command to be sent
   1737           * @param   direction - direction of the command
   1738           * @param   seqNum - transaction sequence number
   1739           *
   1740           * @return  ZSuccess if OK
   1741           */
   1742          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1743                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   1744                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1745          {
   1746            uint16 dataLen = 1; // Discovery complete
   1747            uint8 *buf;
   1748            ZStatus_t status;
   1749          
   1750            // calculate the size of the command
   1751            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1752          
   1753            buf = zcl_mem_alloc( dataLen );
   1754            if ( buf != NULL )
   1755            {
   1756              // Load the buffer - serially
   1757              uint8 i;
   1758              uint8 *pBuf = buf;
   1759          
   1760              *pBuf++ = pDiscoverRspCmd->discComplete;
   1761          
   1762              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1763              {
   1764                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1765                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1766                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   1767              }
   1768          
   1769              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   1770                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1771              zcl_mem_free( buf );
   1772            }
   1773            else
   1774            {
   1775              status = ZMemError;
   1776            }
   1777          
   1778            return ( status );
   1779          }
   1780          
   1781          /*********************************************************************
   1782           * @fn      zcl_SendDiscoverAttrsExt
   1783           *
   1784           * @brief   Send a Discover Attributes Extended command
   1785           *
   1786           * @param   dstAddr - destination address
   1787           * @param   clusterID - cluster ID
   1788           * @param   pDiscoverAttrsExt:
   1789           *            - startAttrID: the first attribute to be selected
   1790           *            - maxAttrIDs: maximum number of returned attributes
   1791           * @param   direction - direction of the command
   1792           * @param   seqNum - transaction sequence number
   1793           *
   1794           * @return  ZSuccess if OK
   1795           */
   1796          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   1797                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   1798                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1799          {
   1800            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   1801            ZStatus_t status;
   1802          
   1803            // Load the buffer - serially
   1804            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   1805            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   1806            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   1807          
   1808            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   1809                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   1810          
   1811            return ( status );
   1812          }
   1813          
   1814          /*********************************************************************
   1815           * @fn      zcl_SendDiscoverAttrsExtRsp
   1816           *
   1817           * @brief   Send a Discover Attributes Extended Response command
   1818           *
   1819           * @param   dstAddr - destination address
   1820           * @param   clusterID - cluster ID
   1821           * @param   pDiscoverRspCmd:
   1822           *            - discComplete: indicates whether all requested attributes returned
   1823           *            - attrID: attribute ID
   1824           *            - attrDataType: data type of the given attribute
   1825           *            - attrAccessControl: access control of the given attribute
   1826           * @param   direction - direction of the command
   1827           * @param   seqNum - transaction sequence number
   1828           *
   1829           * @return  ZSuccess if OK
   1830           */
   1831          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   1832                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   1833                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1834          {
   1835            uint8 *buf;
   1836            uint8 i;
   1837            uint16 dataLen = 1; // Discovery complete
   1838            ZStatus_t status;
   1839          
   1840            // calculate the size of the command
   1841            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   1842          
   1843            buf = zcl_mem_alloc( dataLen );
   1844            if ( buf != NULL )
   1845            {
   1846              // Load the buffer - serially
   1847              uint8 *pBuf = buf;
   1848              *pBuf++ = pDiscoverRspCmd->discComplete;
   1849              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1850              {
   1851                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1852                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1853                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   1854                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   1855              }
   1856          
   1857              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   1858                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1859              zcl_mem_free( buf );
   1860            }
   1861            else
   1862            {
   1863              status = ZMemError;
   1864            }
   1865          
   1866            return ( status );
   1867          }
   1868          #endif // ZCL_DISCOVER
   1869          
   1870          /*********************************************************************
   1871           * @fn      zcl_ProcessMessageMSG
   1872           *
   1873           * @brief   Data message processor callback.  This function processes
   1874           *          any incoming data - probably from other devices.  So, based
   1875           *          on cluster ID, perform the intended action.
   1876           *
   1877           * @param   pkt - incoming message
   1878           *
   1879           * @return  none
   1880           */

   \                                 In  segment CODE, align 2
   \                     ??Subroutine15_0:
   \   000000   4E7E         SUBC.B  R14, R14
   \   000002   5E53         ADD.B   #0x1, R14
   \   000004   5EE3         XOR.B   #0x1, R14
   \   000006   5EF3         AND.B   #0x1, R14
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
   1881          void zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   1882          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801600     SUB.W   #0x16, SP
   \   000006   084C         MOV.W   R12, R8
   1883            endPointDesc_t *epDesc;
   1884            zclIncoming_t inMsg;
   1885            zclLibPlugin_t *pInPlugin;
   1886            zclDefaultRspCmd_t defautlRspCmd;
   1887            uint8 options;
   1888            uint8 securityEnable;
   1889            uint8 interPanMsg;
   1890            ZStatus_t status = ZFailure;
   1891          
   1892            if ( pkt->cmd.DataLength == 0 )
   \   000008   8C932200     CMP.W   #0x0, 0x22(R12)
   \   00000C   2D25         JEQ     ??zcl_ProcessMessageMSG_2
   1893            {
   1894              return;   // Error, ignore the message
   1895            }
   1896          
   1897            // Initialize
   1898            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \   00000E   824C....     MOV.W   R12, &rawAFMsg
   1899            inMsg.msg = pkt;
   \   000012   814C0200     MOV.W   R12, 0x2(SP)
   1900            inMsg.attrCmd = NULL;
   \   000016   81430E00     MOV.W   #0x0, 0xe(SP)
   1901            inMsg.pData = NULL;
   \   00001A   81430A00     MOV.W   #0x0, 0xa(SP)
   1902            inMsg.pDataLen = 0;
   \   00001E   81430C00     MOV.W   #0x0, 0xc(SP)
   1903          
   1904            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   000022   0A41         MOV.W   SP, R10
   \   000024   2A53         ADD.W   #0x2, R10
   \   000026   1D4C2400     MOV.W   0x24(R12), R13
   \   00002A   0C4A         MOV.W   R10, R12
   \   00002C   2C53         ADD.W   #0x2, R12
   \   00002E   ........     CALLA   #zclParseHdr
   \   000032   814C0A00     MOV.W   R12, 0xa(SP)
   1905            inMsg.pDataLen = pkt->cmd.DataLength;
   1906            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \   000036   1F482200     MOV.W   0x22(R8), R15
   \   00003A   0F8C         SUB.W   R12, R15
   \   00003C   1F582400     ADD.W   0x24(R8), R15
   \   000040   814F0C00     MOV.W   R15, 0xc(SP)
   1907          
   1908            // Find the wanted endpoint
   1909            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   000044   0B48         MOV.W   R8, R11
   \   000046   3B501400     ADD.W   #0x14, R11
   \   00004A   6C4B         MOV.B   @R11, R12
   \   00004C   ........     CALLA   #afFindEndPointDesc
   1910            if ( epDesc == NULL )
   \   000050   0C93         CMP.W   #0x0, R12
   \   000052   0825         JEQ     ??zcl_ProcessMessageMSG_3
   1911            {
   1912              rawAFMsg = NULL;
   1913              return;   // Error, ignore the message
   1914            }
   1915          
   1916            if ( ( epDesc->simpleDesc == NULL ) ||
   1917                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   1918                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \   000054   1F4C0400     MOV.W   0x4(R12), R15
   \   000058   0F93         CMP.W   #0x0, R15
   \   00005A   0425         JEQ     ??zcl_ProcessMessageMSG_3
   \   00005C   0948         MOV.W   R8, R9
   \   00005E   2952         ADD.W   #0x4, R9
   \   000060   1F120200     PUSH.W  0x2(R15)
   \   000064   5F410B00     MOV.B   0xb(SP), R15
   \   000068   5E410600     MOV.B   0x6(SP), R14
   \   00006C   7EF00300     AND.B   #0x3, R14
   \   000070   2D49         MOV.W   @R9, R13
   \   000072   6C4B         MOV.B   @R11, R12
   \   000074   ........     CALLA   #zcl_DeviceOperational
   \   000078   2153         ADD.W   #0x2, SP
   \   00007A   4C93         CMP.B   #0x0, R12
   \   00007C   F324         JEQ     ??zcl_ProcessMessageMSG_3
   1919            {
   1920              rawAFMsg = NULL;
   1921              return; // Error, ignore the message
   1922            }
   1923          
   1924          #if defined ( INTER_PAN )
   1925            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   1926            {
   1927              // No foundation command is supported thru Inter-PAN communication.
   1928              // But the Light Link cluster uses a different Frame Control format
   1929              // for it's Inter-PAN messages, where the messages could be confused
   1930              // with the foundation commands.
   1931              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1932              {
   1933                rawAFMsg = NULL;
   1934                return;
   1935              }
   1936          
   1937              interPanMsg = TRUE;
   1938              options = AF_TX_OPTIONS_NONE;
   1939            }
   1940            else
   1941          #endif
   1942            {
   1943              interPanMsg = FALSE;
   1944              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \   00007E   2D49         MOV.W   @R9, R13
   \   000080   6C4B         MOV.B   @R11, R12
   \   000082   ........     CALLA   #zclGetClusterOption
   \   000086   2F49         MOV.W   @R9, R15
   \   000088   1E42....     MOV.W   &plugins, R14
   \   00008C   013C         JMP     ??zcl_ProcessMessageMSG_4
   \                     ??zcl_ProcessMessageMSG_0:
   \   00008E   2E4E         MOV.W   @R14, R14
   \                     ??zcl_ProcessMessageMSG_4:
   \   000090   0E93         CMP.W   #0x0, R14
   \   000092   4624         JEQ     ??zcl_ProcessMessageMSG_5
   \   000094   1F9E0200     CMP.W   0x2(R14), R15
   \   000098   FA2B         JNC     ??zcl_ProcessMessageMSG_0
   \   00009A   8E9F0400     CMP.W   R15, 0x4(R14)
   \   00009E   F72B         JNC     ??zcl_ProcessMessageMSG_0
   \   0000A0   F1B007000400 BIT.B   #0x7, 0x4(SP)
   \   0000A6   0420         JNE     ??zcl_ProcessMessageMSG_6
   \   0000A8   F1900B000900 CMP.B   #0xb, 0x9(SP)
   \   0000AE   3924         JEQ     ??zcl_ProcessMessageMSG_7
   1945            }
   1946          
   1947            // Find the appropriate plugin
   1948            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   1949          
   1950            // Local and remote Security options must match except for Default Response command
   1951            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   1952            {
   1953              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zcl_ProcessMessageMSG_6:
   \   0000B0   7CB04000     BIT.B   #0x40, R12
   \   0000B4   3628         JNC     ??zcl_ProcessMessageMSG_7
   \   0000B6   C8931900     CMP.B   #0x0, 0x19(R8)
   \   0000BA   3320         JNE     ??zcl_ProcessMessageMSG_7
   1954          
   1955              // Make sure that Clusters specifically defined to use security are received secure,
   1956              // any other cluster that wants to use APS security will be allowed
   1957              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   1958              {
   1959                if ( UNICAST_MSG( inMsg.msg ) )
   \   0000BC   1F410200     MOV.W   0x2(SP), R15
   \   0000C0   CF931500     CMP.B   #0x0, 0x15(R15)
   \   0000C4   CF20         JNE     ??zcl_ProcessMessageMSG_3
   \   0000C6   8F930200     CMP.W   #0x0, 0x2(R15)
   \   0000CA   CC20         JNE     ??zcl_ProcessMessageMSG_3
   1960                {
   1961                  // Send a Default Response command back with no Application Link Key security
   1962                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   0000CC   4E43         MOV.B   #0x0, R14
   \   0000CE   2D49         MOV.W   @R9, R13
   \   0000D0   6C4B         MOV.B   @R11, R12
   \   0000D2   ........     CALLA   #zclSetSecurityOption
   1963          
   1964                  defautlRspCmd.statusCode = status;
   \   0000D6   D1430100     MOV.B   #0x1, 0x1(SP)
   1965                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0000DA   D14109000000 MOV.B   0x9(SP), 0(SP)
   1966                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1967                                         inMsg.msg->clusterId, &defautlRspCmd,
   1968                                         !inMsg.hdr.fc.direction, true,
   1969                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \   0000E0   51120A00     PUSH.B  0xa(SP)
   \   0000E4   11120A00     PUSH.W  0xa(SP)
   \   0000E8   5312         PUSH.B  #0x1
   \   0000EA   B1B20A00     BIT.W   #0x8, 0xa(SP)
   \   0000EE   ........     CALLA   #??Subroutine15_0
   \                     ??CrossCallReturnLabel_19:
   \   0000F2   4E12         PUSH.B  R14
   \   0000F4   0F41         MOV.W   SP, R15
   \   0000F6   3F52         ADD.W   #0x8, R15
   \   0000F8   1E410A00     MOV.W   0xa(SP), R14
   \   0000FC   1E4E0400     MOV.W   0x4(R14), R14
   \   000100   1D410A00     MOV.W   0xa(SP), R13
   \   000104   3D500600     ADD.W   #0x6, R13
   \   000108   1A410A00     MOV.W   0xa(SP), R10
   \   00010C   5C4A1400     MOV.B   0x14(R10), R12
   \   000110   ........     CALLA   #zcl_SendDefaultRspCmd
   1970          
   1971                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   000114   5E43         MOV.B   #0x1, R14
   \   000116   2D49         MOV.W   @R9, R13
   \   000118   6C4B         MOV.B   @R11, R12
   \   00011A   ........     CALLA   #zclSetSecurityOption
   \   00011E   A13C         JMP     ??zcl_ProcessMessageMSG_8
   1972                }
   1973          
   1974                rawAFMsg = NULL;
   1975                return;   // Error, ignore the message
   1976              }
   1977            }
   \                     ??zcl_ProcessMessageMSG_5:
   \   000120   0E43         MOV.W   #0x0, R14
   1978          
   1979            // Is this a foundation type message
   1980            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zcl_ProcessMessageMSG_7:
   \   000122   F1B003000400 BIT.B   #0x3, 0x4(SP)
   \   000128   6120         JNE     ??zcl_ProcessMessageMSG_9
   1981            {
   1982              if ( inMsg.hdr.fc.manuSpecific )
   \   00012A   A1B20400     BIT.W   #0x4, 0x4(SP)
   \   00012E   0328         JNC     ??zcl_ProcessMessageMSG_10
   1983              {
   1984                // We don't support any manufacturer specific command
   1985                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   000130   7C408400     MOV.B   #0x84, R12
   \   000134   733C         JMP     ??zcl_ProcessMessageMSG_11
   1986              }
   1987              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   1988                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zcl_ProcessMessageMSG_10:
   \   000136   5F410900     MOV.B   0x9(SP), R15
   \   00013A   7F901700     CMP.B   #0x17, R15
   \   00013E   532C         JC      ??zcl_ProcessMessageMSG_12
   \   000140   5F0A         RLAM.W  #0x3, R15
   \   000142   1E4F....     MOV.W   zclCmdTable(R15), R14
   \   000146   1EDF....     BIS.W   zclCmdTable + 2(R15), R14
   \   00014A   0E93         CMP.W   #0x0, R14
   \   00014C   4C24         JEQ     ??zcl_ProcessMessageMSG_12
   1989              {
   1990                zclParseCmd_t parseCmd;
   1991          
   1992                parseCmd.endpoint = pkt->endPoint;
   \   00014E   E14B1000     MOV.B   @R11, 0x10(SP)
   1993                parseCmd.dataLen = inMsg.pDataLen;
   \   000152   91410C001200 MOV.W   0xc(SP), 0x12(SP)
   1994                parseCmd.pData = inMsg.pData;
   \   000158   91410A001400 MOV.W   0xa(SP), 0x14(SP)
   1995          
   1996                // Parse the command, remember that the return value is a pointer to allocated memory
   1997                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \   00015E   0C41         MOV.W   SP, R12
   \   000160   3C501000     ADD.W   #0x10, R12
   \   000164   5F410900     MOV.B   0x9(SP), R15
   \   000168   5F0A         RLAM.W  #0x3, R15
   \   00016A   1E4F....     MOV.W   zclCmdTable(R15), R14
   \   00016E   1F4F....     MOV.W   zclCmdTable + 2(R15), R15
   \   000172   ........     CALLA   #?IndCallR15
   \   000176   814C0E00     MOV.W   R12, 0xe(SP)
   1998                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \   00017A   0C93         CMP.W   #0x0, R12
   \   00017C   1524         JEQ     ??zcl_ProcessMessageMSG_13
   \   00017E   5F410900     MOV.B   0x9(SP), R15
   \   000182   5F0A         RLAM.W  #0x3, R15
   \   000184   1E4F....     MOV.W   zclCmdTable + 4(R15), R14
   \   000188   1F4F....     MOV.W   zclCmdTable + 6(R15), R15
   \   00018C   0B4E         MOV.W   R14, R11
   \   00018E   0BDF         BIS.W   R15, R11
   \   000190   0B93         CMP.W   #0x0, R11
   \   000192   0624         JEQ     ??zcl_ProcessMessageMSG_14
   1999                {
   2000                  // Process the command
   2001                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   000194   0C4A         MOV.W   R10, R12
   \   000196   ........     CALLA   #?IndCallR15
   2002                  {
   2003                    // Couldn't find attribute in the table.
   2004                  }
   2005                }
   2006          
   2007                // Free the buffer
   2008                if ( inMsg.attrCmd )
   \   00019A   81930E00     CMP.W   #0x0, 0xe(SP)
   \   00019E   0424         JEQ     ??zcl_ProcessMessageMSG_13
   2009                {
   2010                  zcl_mem_free( inMsg.attrCmd );
   \                     ??zcl_ProcessMessageMSG_14:
   \   0001A0   1C410E00     MOV.W   0xe(SP), R12
   \   0001A4   ........     CALLA   #osal_mem_free
   2011                }
   2012          
   2013                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zcl_ProcessMessageMSG_13:
   \   0001A8   5E410900     MOV.B   0x9(SP), R14
   \   0001AC   4E93         CMP.B   #0x0, R14
   \   0001AE   5A24         JEQ     ??zcl_ProcessMessageMSG_3
   \   0001B0   6E93         CMP.B   #0x2, R14
   \   0001B2   5824         JEQ     ??zcl_ProcessMessageMSG_3
   \   0001B4   7E900300     CMP.B   #0x3, R14
   \   0001B8   5524         JEQ     ??zcl_ProcessMessageMSG_3
   \   0001BA   7E900600     CMP.B   #0x6, R14
   \   0001BE   5224         JEQ     ??zcl_ProcessMessageMSG_3
   \   0001C0   7E92         CMP.B   #0x8, R14
   \   0001C2   5024         JEQ     ??zcl_ProcessMessageMSG_3
   \   0001C4   7E900C00     CMP.B   #0xc, R14
   \   0001C8   4D24         JEQ     ??zcl_ProcessMessageMSG_3
   \   0001CA   7E901100     CMP.B   #0x11, R14
   \   0001CE   4A24         JEQ     ??zcl_ProcessMessageMSG_3
   \   0001D0   7E901300     CMP.B   #0x13, R14
   \   0001D4   4724         JEQ     ??zcl_ProcessMessageMSG_3
   \   0001D6   7E901500     CMP.B   #0x15, R14
   \   0001DA   4424         JEQ     ??zcl_ProcessMessageMSG_3
   \   0001DC   7E900B00     CMP.B   #0xb, R14
   \   0001E0   4124         JEQ     ??zcl_ProcessMessageMSG_3
   2014                {
   2015                  rawAFMsg = NULL;
   2016                  return; // We're done
   2017                }
   2018          
   2019                status = ZSuccess;
   \   0001E2   4C43         MOV.B   #0x0, R12
   \   0001E4   1B3C         JMP     ??zcl_ProcessMessageMSG_11
   2020              }
   2021              else
   2022              {
   2023                // Unsupported message
   2024                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_12:
   \   0001E6   7C408200     MOV.B   #0x82, R12
   \   0001EA   183C         JMP     ??zcl_ProcessMessageMSG_11
   2025              }
   2026            }
   2027            else  // Not a foundation type message, so it must be specific to the cluster ID.
   2028            {
   2029              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zcl_ProcessMessageMSG_9:
   \   0001EC   0E93         CMP.W   #0x0, R14
   \   0001EE   1024         JEQ     ??zcl_ProcessMessageMSG_15
   \   0001F0   0F4E         MOV.W   R14, R15
   \   0001F2   1E4F0600     MOV.W   0x6(R15), R14
   \   0001F6   1F4F0800     MOV.W   0x8(R15), R15
   \   0001FA   0B4E         MOV.W   R14, R11
   \   0001FC   0BDF         BIS.W   R15, R11
   \   0001FE   0B93         CMP.W   #0x0, R11
   \   000200   0724         JEQ     ??zcl_ProcessMessageMSG_15
   2030              {
   2031                // The return value of the plugin function will be
   2032                //  ZSuccess - Supported and need default response
   2033                //  ZFailure - Unsupported
   2034                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   2035                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   2036                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   2037                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   2038                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   000202   0C4A         MOV.W   R10, R12
   \   000204   ........     CALLA   #?IndCallR15
   2039                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   000208   7C93         CMP.B   #0xff, R12
   \   00020A   2C24         JEQ     ??zcl_ProcessMessageMSG_3
   2040                {
   2041                  rawAFMsg = NULL;
   2042                  return; // We're done
   2043                }
   2044              }
   2045          
   2046              if ( status == ZFailure )
   \   00020C   5C93         CMP.B   #0x1, R12
   \   00020E   0620         JNE     ??zcl_ProcessMessageMSG_11
   2047              {
   2048                // Unsupported message
   2049                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zcl_ProcessMessageMSG_15:
   \   000210   A1B20400     BIT.W   #0x4, 0x4(SP)
   \   000214   4C7C         SUBC.B  R12, R12
   \   000216   4C5C         RLA.B   R12
   \   000218   7C508300     ADD.B   #0x83, R12
   2050                {
   2051                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   2052                }
   2053                else
   2054                {
   2055                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   2056                }
   2057              }
   2058            }
   2059          
   2060            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_11:
   \   00021C   1F410200     MOV.W   0x2(SP), R15
   \   000220   CF931500     CMP.B   #0x0, 0x15(R15)
   \   000224   1F20         JNE     ??zcl_ProcessMessageMSG_3
   \   000226   8F930200     CMP.W   #0x0, 0x2(R15)
   \   00022A   1C20         JNE     ??zcl_ProcessMessageMSG_3
   \   00022C   B1B010000400 BIT.W   #0x10, 0x4(SP)
   \   000232   182C         JC      ??zcl_ProcessMessageMSG_3
   2061            {
   2062              // Send a Default Response command back
   2063              defautlRspCmd.statusCode = status;
   \   000234   C14C0100     MOV.B   R12, 0x1(SP)
   2064              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   000238   D14109000000 MOV.B   0x9(SP), 0(SP)
   2065              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2066                                     inMsg.msg->clusterId, &defautlRspCmd,
   2067                                     !inMsg.hdr.fc.direction, true,
   2068                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \   00023E   51120A00     PUSH.B  0xa(SP)
   \   000242   11120A00     PUSH.W  0xa(SP)
   \   000246   5312         PUSH.B  #0x1
   \   000248   B1B20A00     BIT.W   #0x8, 0xa(SP)
   \   00024C   ........     CALLA   #??Subroutine15_0
   2069            }
   \                     ??CrossCallReturnLabel_20:
   \   000250   4E12         PUSH.B  R14
   \   000252   0F41         MOV.W   SP, R15
   \   000254   3F52         ADD.W   #0x8, R15
   \   000256   1B410A00     MOV.W   0xa(SP), R11
   \   00025A   ........     CALLA   #?Subroutine16
   \                     ??CrossCallReturnLabel_9:
   \   00025E   ........     CALLA   #zcl_SendDefaultRspCmd
   \                     ??zcl_ProcessMessageMSG_8:
   \   000262   3152         ADD.W   #0x8, SP
   2070          
   2071            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_3:
   \   000264   8243....     MOV.W   #0x0, &rawAFMsg
   2072          }
   \                     ??zcl_ProcessMessageMSG_2:
   \   000268   31501600     ADD.W   #0x16, SP
   \   00026C   3817         POPM.W  #0x4, R11
   \   00026E   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine16:
   \   000000   1E4B0400     MOV.W   0x4(R11), R14
   \   000004   0D4B         MOV.W   R11, R13
   \   000006   3D500600     ADD.W   #0x6, R13
   \   00000A   5C4B1400     MOV.B   0x14(R11), R12
   \   00000E   1001         RETA
   2073          
   2074          /*********************************************************************
   2075           * PRIVATE FUNCTIONS
   2076           *********************************************************************/
   2077          
   2078          /*********************************************************************
   2079           * @fn      zclParseHdr
   2080           *
   2081           * @brief   Parse header of the ZCL format
   2082           *
   2083           * @param   hdr - place to put the frame control information
   2084           * @param   pData - incoming buffer to parse
   2085           *
   2086           * @return  pointer past the header
   2087           */

   \                                 In  segment CODE, align 2
   2088          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   2089          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   2090            // Clear the header
   2091            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   000006   3E400600     MOV.W   #0x6, R14
   \   00000A   4D43         MOV.B   #0x0, R13
   \   00000C   ........     CALLA   #osal_memset
   2092          
   2093            // Parse the Frame Control
   2094            hdr->fc.type = zcl_FCType( *pData );
   \   000010   6F4B         MOV.B   @R11, R15
   \   000012   3FF00300     AND.W   #0x3, R15
   \   000016   2E4A         MOV.W   @R10, R14
   \   000018   3EF0FCFF     AND.W   #0xfffc, R14
   \   00001C   0EDF         BIS.W   R15, R14
   \   00001E   8A4E0000     MOV.W   R14, 0(R10)
   2095            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \   000022   EBB20000     BIT.B   #0x4, 0(R11)
   \   000026   4E7E         SUBC.B  R14, R14
   \   000028   5E53         ADD.B   #0x1, R14
   \   00002A   1EB3         BIT.W   #0x1, R14
   \   00002C   032C         JC      ??zclParseHdr_0
   \   00002E   AAC20000     BIC.W   #0x4, 0(R10)
   \   000032   023C         JMP     ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000034   AAD20000     BIS.W   #0x4, 0(R10)
   2096            if ( zcl_FCDirection( *pData ) )
   \                     ??zclParseHdr_1:
   \   000038   FBB20000     BIT.B   #0x8, 0(R11)
   \   00003C   0328         JNC     ??zclParseHdr_2
   2097            {
   2098              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00003E   BAD20000     BIS.W   #0x8, 0(R10)
   \   000042   023C         JMP     ??zclParseHdr_3
   2099            }
   2100            else
   2101            {
   2102              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000044   BAC20000     BIC.W   #0x8, 0(R10)
   2103            }
   2104          
   2105            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??zclParseHdr_3:
   \   000048   0F4B         MOV.W   R11, R15
   \   00004A   1B53         ADD.W   #0x1, R11
   \   00004C   FFB010000000 BIT.B   #0x10, 0(R15)
   \   000052   4E7E         SUBC.B  R14, R14
   \   000054   5E53         ADD.B   #0x1, R14
   \   000056   1EB3         BIT.W   #0x1, R14
   \   000058   042C         JC      ??zclParseHdr_4
   \   00005A   BAC010000000 BIC.W   #0x10, 0(R10)
   \   000060   033C         JMP     ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   000062   BAD010000000 BIS.W   #0x10, 0(R10)
   2106            pData++;  // move past the frame control field
   2107          
   2108            // parse the manfacturer code
   2109            if ( hdr->fc.manuSpecific )
   \                     ??zclParseHdr_5:
   \   000068   AAB20000     BIT.W   #0x4, 0(R10)
   \   00006C   0928         JNC     ??zclParseHdr_6
   2110            {
   2111              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   00006E   6E4B         MOV.B   @R11, R14
   \   000070   5F4B0100     MOV.B   0x1(R11), R15
   \   000074                RPT     #0x8
   \   000074   47180F5F     RLAX.W  R15
   \   000078   0E5F         ADD.W   R15, R14
   \   00007A   8A4E0200     MOV.W   R14, 0x2(R10)
   2112              pData += 2;
   \   00007E   2B53         ADD.W   #0x2, R11
   2113            }
   2114          
   2115            // parse the Transaction Sequence Number
   2116            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   000080   FA4B0400     MOV.B   @R11+, 0x4(R10)
   2117          
   2118            // parse the Cluster's command ID
   2119            hdr->commandID = *pData++;
   \   000084   FA4B0500     MOV.B   @R11+, 0x5(R10)
   2120          
   2121            // Should point to the frame payload
   2122            return ( pData );
   \   000088   0C4B         MOV.W   R11, R12
   \   00008A   1A17         POPM.W  #0x2, R11
   \   00008C   1001         RETA
   2123          }
   2124          
   2125          /*********************************************************************
   2126           * @fn      zclBuildHdr
   2127           *
   2128           * @brief   Build header of the ZCL format
   2129           *
   2130           * @param   hdr - outgoing header information
   2131           * @param   pData - outgoing header space
   2132           *
   2133           * @return  pointer past the header
   2134           */

   \                                 In  segment CODE, align 2
   2135          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   2136          {
   2137            // Build the Frame Control byte
   2138            *pData = hdr->fc.type;
   \   000000   6E4C         MOV.B   @R12, R14
   \   000002   7EF00300     AND.B   #0x3, R14
   \   000006   CD4E0000     MOV.B   R14, 0(R13)
   2139            *pData |= hdr->fc.manuSpecific << 2;
   \   00000A   6E4C         MOV.B   @R12, R14
   \   00000C   6EF2         AND.B   #0x4, R14
   \   00000E   CDDE0000     BIS.B   R14, 0(R13)
   2140            *pData |= hdr->fc.direction << 3;
   \   000012   6E4C         MOV.B   @R12, R14
   \   000014   7EF2         AND.B   #0x8, R14
   \   000016   CDDE0000     BIS.B   R14, 0(R13)
   2141            *pData |= hdr->fc.disableDefaultRsp << 4;
   \   00001A   6E4C         MOV.B   @R12, R14
   \   00001C   7EF01000     AND.B   #0x10, R14
   \   000020   CDDE0000     BIS.B   R14, 0(R13)
   2142            pData++;  // move past the frame control field
   \   000024   1D53         ADD.W   #0x1, R13
   2143          
   2144            // Add the manfacturer code
   2145            if ( hdr->fc.manuSpecific )
   \   000026   ACB20000     BIT.W   #0x4, 0(R12)
   \   00002A   0828         JNC     ??zclBuildHdr_0
   2146            {
   2147              *pData++ = LO_UINT16( hdr->manuCode );
   \   00002C   DD4C02000000 MOV.B   0x2(R12), 0(R13)
   \   000032   1D53         ADD.W   #0x1, R13
   2148              *pData++ = HI_UINT16( hdr->manuCode );
   \   000034   DD4C03000000 MOV.B   0x3(R12), 0(R13)
   \   00003A   1D53         ADD.W   #0x1, R13
   2149            }
   2150          
   2151            // Add the Transaction Sequence Number
   2152            *pData++ = hdr->transSeqNum;
   \                     ??zclBuildHdr_0:
   \   00003C   DD4C04000000 MOV.B   0x4(R12), 0(R13)
   \   000042   1D53         ADD.W   #0x1, R13
   2153          
   2154            // Add the Cluster's command ID
   2155            *pData++ = hdr->commandID;
   \   000044   DD4C05000000 MOV.B   0x5(R12), 0(R13)
   \   00004A   1D53         ADD.W   #0x1, R13
   2156          
   2157            // Should point to the frame payload
   2158            return ( pData );
   \   00004C   0C4D         MOV.W   R13, R12
   \   00004E   1001         RETA
   2159          }
   2160          
   2161          /*********************************************************************
   2162           * @fn      zclCalcHdrSize
   2163           *
   2164           * @brief   Calculate the number of bytes needed for an outgoing
   2165           *          ZCL header.
   2166           *
   2167           * @param   hdr - outgoing header information
   2168           *
   2169           * @return  returns the number of bytes needed
   2170           */
   2171          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   2172          {
   2173            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   2174          
   2175            // Add the manfacturer code
   2176            if ( hdr->fc.manuSpecific )
   2177            {
   2178              needed += 2;
   2179            }
   2180          
   2181            return ( needed );
   2182          }
   2183          
   2184          /*********************************************************************
   2185           * @fn      zclFindPlugin
   2186           *
   2187           * @brief   Find the right plugin for a cluster ID
   2188           *
   2189           * @param   clusterID - cluster ID to look for
   2190           * @param   profileID - profile ID
   2191           *
   2192           * @return  pointer to plugin, NULL if not found
   2193           */
   2194          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   2195          {
   2196            zclLibPlugin_t *pLoop = plugins;
   2197          
   2198            (void)profileID;  // Intentionally unreferenced parameter
   2199          
   2200            while ( pLoop != NULL )
   2201            {
   2202              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   2203              {
   2204                return ( pLoop );
   2205              }
   2206          
   2207              pLoop = pLoop->next;
   2208            }
   2209          
   2210            return ( (zclLibPlugin_t *)NULL );
   2211          }
   2212          
   2213          #ifdef ZCL_DISCOVER
   2214          /*********************************************************************
   2215           * @fn      zclFindCmdRecsList
   2216           *
   2217           * @brief   Find the right command record list for an endpoint
   2218           *
   2219           * @param   endpoint - endpoint to look for
   2220           *
   2221           * @return  pointer to record list, NULL if not found
   2222           */
   2223          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   2224          {
   2225            zclCmdRecsList_t *pLoop = gpCmdList;
   2226          
   2227            while ( pLoop != NULL )
   2228            {
   2229              if ( pLoop->endpoint == endpoint )
   2230              {
   2231                return ( pLoop );
   2232              }
   2233          
   2234              pLoop = pLoop->pNext;
   2235            }
   2236          
   2237            return ( NULL );
   2238          }
   2239          
   2240          /*********************************************************************
   2241           * @fn      zclFindCmdRec
   2242           *
   2243           * @brief   Find the command record that matchs the parameters
   2244           *
   2245           * @param   endpoint - Application's endpoint
   2246           * @param   clusterID - cluster ID
   2247           * @param   attrId - attribute looking for
   2248           * @param   pAttr - attribute record to be returned
   2249           *
   2250           * @return  TRUE if record found. FALSE, otherwise.
   2251           */
   2252          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   2253          {
   2254            uint8 i;
   2255            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2256          
   2257            if ( pRec != NULL )
   2258            {
   2259              for ( i = 0; i < pRec->numCommands; i++ )
   2260              {
   2261                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   2262                {
   2263                  *pCmd = pRec->pCmdRecs[i];
   2264          
   2265                  return ( TRUE ); // EMBEDDED RETURN
   2266                }
   2267              }
   2268            }
   2269          
   2270            return ( FALSE );
   2271          }
   2272          #endif // ZCL_DISCOVER
   2273          
   2274          /*********************************************************************
   2275           * @fn      zclFindAttrRecsList
   2276           *
   2277           * @brief   Find the right attribute record list for an endpoint
   2278           *
   2279           * @param   clusterID - endpointto look for
   2280           *
   2281           * @return  pointer to record list, NULL if not found
   2282           */

   \                                 In  segment CODE, align 2
   2283          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   2284          {
   2285            zclAttrRecsList *pLoop = attrList;
   \   000000   1F42....     MOV.W   &attrList, R15
   \   000004   013C         JMP     ??zclFindAttrRecsList_1
   2286          
   2287            while ( pLoop != NULL )
   2288            {
   2289              if ( pLoop->endpoint == endpoint )
   2290              {
   2291                return ( pLoop );
   2292              }
   2293          
   2294              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_0:
   \   000006   2F4F         MOV.W   @R15, R15
   \                     ??zclFindAttrRecsList_1:
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   0524         JEQ     ??zclFindAttrRecsList_2
   \   00000C   CF9C0200     CMP.B   R12, 0x2(R15)
   \   000010   FA23         JNE     ??zclFindAttrRecsList_0
   \   000012   0C4F         MOV.W   R15, R12
   \   000014   1001         RETA
   2295            }
   2296          
   2297            return ( NULL );
   \                     ??zclFindAttrRecsList_2:
   \   000016   0C43         MOV.W   #0x0, R12
   \   000018   1001         RETA
   2298          }
   2299          
   2300          /*********************************************************************
   2301           * @fn      zclFindAttrRec
   2302           *
   2303           * @brief   Find the attribute record that matchs the parameters
   2304           *
   2305           * @param   endpoint - Application's endpoint
   2306           * @param   clusterID - cluster ID
   2307           * @param   attrId - attribute looking for
   2308           * @param   pAttr - attribute record to be returned
   2309           *
   2310           * @return  TRUE if record found. FALSE, otherwise.
   2311           */

   \                                 In  segment CODE, align 2
   2312          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   2313          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4D         MOV.W   R13, R10
   \   000004   0B4E         MOV.W   R14, R11
   \   000006   084F         MOV.W   R15, R8
   2314            uint8 x;
   2315            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000008   ........     CALLA   #zclFindAttrRecsList
   2316          
   2317            if ( pRec != NULL )
   \   00000C   0C93         CMP.W   #0x0, R12
   \   00000E   1B24         JEQ     ??zclFindAttrRec_1
   2318            {
   2319              for ( x = 0; x < pRec->numAttributes; x++ )
   \   000010   4E43         MOV.B   #0x0, R14
   \   000012   013C         JMP     ??zclFindAttrRec_2
   \                     ??zclFindAttrRec_0:
   \   000014   5E53         ADD.B   #0x1, R14
   \                     ??zclFindAttrRec_2:
   \   000016   5E9C0C00     CMP.B   0xc(R12), R14
   \   00001A   152C         JC      ??zclFindAttrRec_1
   2320              {
   2321                if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
   \   00001C   1F4C0E00     MOV.W   0xe(R12), R15
   \   000020   4D4E         MOV.B   R14, R13
   \   000022   5D0A         RLAM.W  #0x3, R13
   \   000024   0F5D         ADD.W   R13, R15
   \   000026   8F9A0000     CMP.W   R10, 0(R15)
   \   00002A   F423         JNE     ??zclFindAttrRec_0
   \   00002C   8F9B0200     CMP.W   R11, 0x2(R15)
   \   000030   F123         JNE     ??zclFindAttrRec_0
   2322                {
   2323                  *pAttr = pRec->attrs[x];
   \   000032   B84F0000     MOV.W   @R15+, 0(R8)
   \   000036   B84F0200     MOV.W   @R15+, 0x2(R8)
   \   00003A   B84F0400     MOV.W   @R15+, 0x4(R8)
   \   00003E   B84F0600     MOV.W   @R15+, 0x6(R8)
   2324          
   2325                  return ( TRUE ); // EMBEDDED RETURN
   \   000042   5C43         MOV.B   #0x1, R12
   \   000044   013C         JMP     ??zclFindAttrRec_3
   2326                }
   2327              }
   2328            }
   2329          
   2330            return ( FALSE );
   \                     ??zclFindAttrRec_1:
   \   000046   4C43         MOV.B   #0x0, R12
   \                     ??zclFindAttrRec_3:
   \   000048   3817         POPM.W  #0x4, R11
   \   00004A   1001         RETA
   2331          }
   2332          
   2333          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   2334          /*********************************************************************
   2335           * @fn      zclGetReadWriteCB
   2336           *
   2337           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   2338           *
   2339           * @param   endpoint - Application's endpoint
   2340           *
   2341           * @return  Read/Write CB, NULL if not found
   2342           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   0C43         MOV.W   #0x0, R12
   \   000002   0D43         MOV.W   #0x0, R13
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
   2343          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   2344          {
   2345            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000000   ........     CALLA   #zclFindAttrRecsList
   2346          
   2347            if ( pRec != NULL )
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0624         JEQ     ??zclGetReadWriteCB_0
   2348            {
   2349              return ( pRec->pfnReadWriteCB );
   \   000008   0D4C         MOV.W   R12, R13
   \   00000A   1C4D0400     MOV.W   0x4(R13), R12
   \   00000E   1D4D0600     MOV.W   0x6(R13), R13
   \   000012   1001         RETA
   2350            }
   2351          
   2352            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   000014   ....         JMP     ?Subroutine2
   \   000016   0343         NOP
   2353          }
   2354          
   2355          /*********************************************************************
   2356           * @fn      zclGetAuthorizeCB
   2357           *
   2358           * @brief   Get the Read/Write Authorization callback function pointer
   2359           *          for a given endpoint.
   2360           *
   2361           * @param   endpoint - Application's endpoint
   2362           *
   2363           * @return  Authorization CB, NULL if not found
   2364           */

   \                                 In  segment CODE, align 2, keep-with-next
   2365          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   2366          {
   2367            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000000   ........     CALLA   #zclFindAttrRecsList
   2368          
   2369            if ( pRec != NULL )
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0624         JEQ     ??zclGetAuthorizeCB_0
   2370            {
   2371              return ( pRec->pfnAuthorizeCB );
   \   000008   0D4C         MOV.W   R12, R13
   \   00000A   1C4D0800     MOV.W   0x8(R13), R12
   \   00000E   1D4D0A00     MOV.W   0xa(R13), R13
   \   000012   1001         RETA
   2372            }
   2373          
   2374            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   000014                REQUIRE ?Subroutine2
   \   000014                // Fall through to label ?Subroutine2
   2375          }
   2376          #endif // ZCL_READ || ZCL_WRITE
   2377          
   2378          /*********************************************************************
   2379           * @fn      zclFindClusterOption
   2380           *
   2381           * @brief   Find the option record that matchs the cluster id
   2382           *
   2383           * @param   endpoint - Application's endpoint
   2384           * @param   clusterID - cluster ID looking for
   2385           *
   2386           * @return  pointer to clutser option, NULL if not found
   2387           */

   \                                 In  segment CODE, align 2
   2388          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   2389          {
   \   000000   1B15         PUSHM.W #0x2, R11
   2390            zclClusterOptionList *pLoop;
   2391          
   2392            pLoop = clusterOptionList;
   \   000002   1A42....     MOV.W   &clusterOptionList, R10
   \   000006   013C         JMP     ??zclFindClusterOption_2
   2393            while ( pLoop != NULL )
   2394            {
   2395              if ( pLoop->endpoint == endpoint )
   2396              {
   2397                uint8 x;
   2398                for ( x = 0; x < pLoop->numOptions; x++ )
   2399                {
   2400                  if ( pLoop->options[x].clusterID == clusterID )
   2401                  {
   2402                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   2403                  }
   2404                }
   2405              }
   2406          
   2407              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_0:
   \   000008   2A4A         MOV.W   @R10, R10
   \                     ??zclFindClusterOption_2:
   \   00000A   0A93         CMP.W   #0x0, R10
   \   00000C   1324         JEQ     ??zclFindClusterOption_3
   \   00000E   CA9C0200     CMP.B   R12, 0x2(R10)
   \   000012   FA23         JNE     ??zclFindClusterOption_0
   \   000014   4E43         MOV.B   #0x0, R14
   \   000016   013C         JMP     ??zclFindClusterOption_4
   \                     ??zclFindClusterOption_1:
   \   000018   5E53         ADD.B   #0x1, R14
   \                     ??zclFindClusterOption_4:
   \   00001A   5E9A0300     CMP.B   0x3(R10), R14
   \   00001E   F42F         JC      ??zclFindClusterOption_0
   \   000020   1F4A0400     MOV.W   0x4(R10), R15
   \   000024   4B4E         MOV.B   R14, R11
   \   000026   5B06         RLAM.W  #0x2, R11
   \   000028   0F5B         ADD.W   R11, R15
   \   00002A   8F9D0000     CMP.W   R13, 0(R15)
   \   00002E   F423         JNE     ??zclFindClusterOption_1
   \   000030   0C4F         MOV.W   R15, R12
   \   000032   013C         JMP     ??zclFindClusterOption_5
   2408            }
   2409          
   2410            return ( NULL );
   \                     ??zclFindClusterOption_3:
   \   000034   0C43         MOV.W   #0x0, R12
   \                     ??zclFindClusterOption_5:
   \   000036   1A17         POPM.W  #0x2, R11
   \   000038   1001         RETA
   2411          }
   2412          
   2413          /*********************************************************************
   2414           * @fn      zclGetClusterOption
   2415           *
   2416           * @brief   Get the option record that matchs the cluster id
   2417           *
   2418           * @param   endpoint - Application's endpoint
   2419           * @param   clusterID - cluster ID looking for
   2420           *
   2421           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2422           */

   \                                 In  segment CODE, align 2
   2423          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2424          {
   2425            uint8 option;
   2426            zclOptionRec_t *pOption;
   2427          
   2428            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000000   ........     CALLA   #zclFindClusterOption
   2429            if ( pOption != NULL )
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0524         JEQ     ??zclGetClusterOption_0
   2430            {
   2431              option = pOption->option;
   2432              if ( !ZG_SECURE_ENABLED )
   2433              {
   2434                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2435              }
   2436          
   2437              return ( option ); // EMBEDDED RETURN
   \   000008   5C4C0200     MOV.B   0x2(R12), R12
   \   00000C   7CF0BF00     AND.B   #0xbf, R12
   \   000010   1001         RETA
   2438            }
   2439          
   2440            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   000012   4C43         MOV.B   #0x0, R12
   \   000014   1001         RETA
   2441          }
   2442          
   2443          /*********************************************************************
   2444           * @fn      zclSetSecurityOption
   2445           *
   2446           * @brief   Set the security option for the cluster id
   2447           *
   2448           * @param   endpoint - Application's endpoint
   2449           * @param   clusterID - cluster ID looking for
   2450           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2451           *
   2452           * @return  none
   2453           */

   \                                 In  segment CODE, align 2
   2454          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2455          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4E         MOV.B   R14, R10
   2456            zclOptionRec_t *pOption;
   2457          
   2458            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000004   ........     CALLA   #zclFindClusterOption
   2459            if ( pOption != NULL )
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0924         JEQ     ??zclSetSecurityOption_0
   2460            {
   2461              if ( enable )
   \   00000C   4A93         CMP.B   #0x0, R10
   \   00000E   0424         JEQ     ??zclSetSecurityOption_1
   2462              {
   2463                pOption->option |= AF_EN_SECURITY;
   \   000010   FCD040000200 BIS.B   #0x40, 0x2(R12)
   \   000016   033C         JMP     ??zclSetSecurityOption_0
   2464              }
   2465              else
   2466              {
   2467                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000018   FCC040000200 BIC.B   #0x40, 0x2(R12)
   2468              }
   2469            }
   2470          }
   \                     ??zclSetSecurityOption_0:
   \   00001E   3A41         POP.W   R10
   \   000020   1001         RETA
   2471          
   2472          #ifdef ZCL_DISCOVER
   2473          /*********************************************************************
   2474           * @fn      zclFindNextCmdRec
   2475           *
   2476           * @brief   Find the command (or next) record that matchs the parameters
   2477           *
   2478           * @param   endpoint - Application's endpoint
   2479           * @param   clusterID - cluster ID
   2480           * @param   commandID - command ID from requesting command
   2481           * @param   direction- direction of received command
   2482           * @param   pCmdID - command looking for
   2483           * @param   pCmd - command information within command record list
   2484           *
   2485           * @return  pointer to command record, NULL no more records of this cluster
   2486           */
   2487          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   2488                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2489          {
   2490            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2491            uint8 i;
   2492          
   2493            if ( pRec != NULL )
   2494            {
   2495              for ( i = 0; i < pRec->numCommands; i++ )
   2496              {
   2497                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2498                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   2499                {
   2500                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   2501                  {
   2502                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   2503                    {
   2504                      *pCmd = pRec->pCmdRecs[i];
   2505          
   2506                      // Update command ID
   2507                      *pCmdID = pCmd->cmdID;
   2508          
   2509                      return ( TRUE ); // EMBEDDED RETURN
   2510                    }
   2511                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   2512                    {
   2513                      *pCmd = pRec->pCmdRecs[i];
   2514          
   2515                      // Update command ID
   2516                      *pCmdID = pCmd->cmdID;
   2517          
   2518                      return ( TRUE ); // EMBEDDED RETURN
   2519                    }
   2520                  }
   2521                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   2522                  {
   2523                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   2524                    {
   2525                      *pCmd = pRec->pCmdRecs[i];
   2526          
   2527                      // Update command ID
   2528                      *pCmdID = pCmd->cmdID;
   2529          
   2530                      return ( TRUE ); // EMBEDDED RETURN
   2531                    }
   2532                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   2533                    {
   2534                      *pCmd = pRec->pCmdRecs[i];
   2535          
   2536                      // Update command ID
   2537                      *pCmdID = pCmd->cmdID;
   2538          
   2539                      return ( TRUE ); // EMBEDDED RETURN
   2540                    }
   2541                  }
   2542                  else
   2543                  {
   2544                    return ( FALSE ); // Incorrect Command ID
   2545                  }
   2546                }
   2547              }
   2548            }
   2549          
   2550            return ( FALSE );
   2551          }
   2552          
   2553          /*********************************************************************
   2554           * @fn      zclFindNextAttrRec
   2555           *
   2556           * @brief   Find the attribute (or next) record that matchs the parameters
   2557           *
   2558           * @param   endpoint - Application's endpoint
   2559           * @param   clusterID - cluster ID
   2560           * @param   attr - attribute looking for
   2561           *
   2562           * @return  pointer to attribute record, NULL if not found
   2563           */
   2564          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   2565                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2566          {
   2567            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2568            uint8 attrDir;
   2569          
   2570            if ( pRec != NULL )
   2571            {
   2572              for ( uint16 x = 0; x < pRec->numAttributes; x++ )
   2573              {
   2574                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2575                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2576                {
   2577                  // also make sure direction is right
   2578                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   2579                  if ( attrDir == direction )
   2580                  {
   2581                    // return attribute and found attribute ID
   2582                    *pAttr = pRec->attrs[x];
   2583                    *attrId = pAttr->attr.attrId;
   2584          
   2585                    return ( TRUE ); // EMBEDDED RETURN
   2586                  }
   2587                }
   2588              }
   2589            }
   2590          
   2591            return ( FALSE );
   2592          }
   2593          #endif // ZCL_DISCOVER
   2594          
   2595          /*********************************************************************
   2596           * @fn      zclSerializeData
   2597           *
   2598           * @brief   Builds a buffer from the attribute data to sent out over
   2599           *          the air.
   2600           *          NOTE - Not compatible with application's attributes callbacks.
   2601           *
   2602           * @param   dataType - data types defined in zcl.h
   2603           * @param   attrData - pointer to the attribute data
   2604           * @param   buf - where to put the serialized data
   2605           *
   2606           * @return  pointer to end of destination buffer
   2607           */

   \                                 In  segment CODE, align 2, keep-with-next
   2608          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2609          {
   \   000000   4F4C         MOV.B   R12, R15
   \   000002   0C4E         MOV.W   R14, R12
   2610            uint8 *pStr;
   2611            uint16 len;
   2612          
   2613            if ( attrData == NULL )
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   7D24         JEQ     ??zclSerializeData_0
   2614            {
   2615              return ( buf );
   2616            }
   2617          
   2618            switch ( dataType )
   \   000008   7F82         SUB.B   #0x8, R15
   \   00000A   4D24         JEQ     ??zclSerializeData_1
   \   00000C   5F83         SUB.B   #0x1, R15
   \   00000E   4F24         JEQ     ??zclSerializeData_2
   \   000010   5F83         SUB.B   #0x1, R15
   \   000012   4F24         JEQ     ??zclSerializeData_3
   \   000014   5F83         SUB.B   #0x1, R15
   \   000016   5524         JEQ     ??zclSerializeData_4
   \   000018   7F800500     SUB.B   #0x5, R15
   \   00001C   4424         JEQ     ??zclSerializeData_1
   \   00001E   7F82         SUB.B   #0x8, R15
   \   000020   4224         JEQ     ??zclSerializeData_1
   \   000022   5F83         SUB.B   #0x1, R15
   \   000024   4424         JEQ     ??zclSerializeData_2
   \   000026   5F83         SUB.B   #0x1, R15
   \   000028   4424         JEQ     ??zclSerializeData_3
   \   00002A   5F83         SUB.B   #0x1, R15
   \   00002C   4A24         JEQ     ??zclSerializeData_4
   \   00002E   7F800500     SUB.B   #0x5, R15
   \   000032   3924         JEQ     ??zclSerializeData_1
   \   000034   5F83         SUB.B   #0x1, R15
   \   000036   3B24         JEQ     ??zclSerializeData_2
   \   000038   5F83         SUB.B   #0x1, R15
   \   00003A   3B24         JEQ     ??zclSerializeData_3
   \   00003C   5F83         SUB.B   #0x1, R15
   \   00003E   4124         JEQ     ??zclSerializeData_4
   \   000040   5F83         SUB.B   #0x1, R15
   \   000042   4324         JEQ     ??zclSerializeData_5
   \   000044   5F83         SUB.B   #0x1, R15
   \   000046   4524         JEQ     ??zclSerializeData_6
   \   000048   7F800300     SUB.B   #0x3, R15
   \   00004C   2C24         JEQ     ??zclSerializeData_1
   \   00004E   5F83         SUB.B   #0x1, R15
   \   000050   2E24         JEQ     ??zclSerializeData_2
   \   000052   5F83         SUB.B   #0x1, R15
   \   000054   2E24         JEQ     ??zclSerializeData_3
   \   000056   5F83         SUB.B   #0x1, R15
   \   000058   3424         JEQ     ??zclSerializeData_4
   \   00005A   7F800500     SUB.B   #0x5, R15
   \   00005E   2324         JEQ     ??zclSerializeData_1
   \   000060   5F83         SUB.B   #0x1, R15
   \   000062   2524         JEQ     ??zclSerializeData_2
   \   000064   7F800700     SUB.B   #0x7, R15
   \   000068   2224         JEQ     ??zclSerializeData_2
   \   00006A   5F83         SUB.B   #0x1, R15
   \   00006C   2A24         JEQ     ??zclSerializeData_4
   \   00006E   7F82         SUB.B   #0x8, R15
   \   000070   3724         JEQ     ??zclSerializeData_7
   \   000072   5F83         SUB.B   #0x1, R15
   \   000074   3524         JEQ     ??zclSerializeData_7
   \   000076   5F83         SUB.B   #0x1, R15
   \   000078   3724         JEQ     ??zclSerializeData_8
   \   00007A   5F83         SUB.B   #0x1, R15
   \   00007C   3524         JEQ     ??zclSerializeData_8
   \   00007E   7F809C00     SUB.B   #0x9c, R15
   \   000082   1F24         JEQ     ??zclSerializeData_4
   \   000084   5F83         SUB.B   #0x1, R15
   \   000086   1D24         JEQ     ??zclSerializeData_4
   \   000088   5F83         SUB.B   #0x1, R15
   \   00008A   1B24         JEQ     ??zclSerializeData_4
   \   00008C   7F800600     SUB.B   #0x6, R15
   \   000090   0E24         JEQ     ??zclSerializeData_2
   \   000092   5F83         SUB.B   #0x1, R15
   \   000094   0C24         JEQ     ??zclSerializeData_2
   \   000096   5F83         SUB.B   #0x1, R15
   \   000098   1424         JEQ     ??zclSerializeData_4
   \   00009A   7F800600     SUB.B   #0x6, R15
   \   00009E   1D24         JEQ     ??zclSerializeData_9
   \   0000A0   5F83         SUB.B   #0x1, R15
   \   0000A2   2B24         JEQ     ??zclSerializeData_10
   \   0000A4   1001         RETA
   2619            {
   2620              case ZCL_DATATYPE_DATA8:
   2621              case ZCL_DATATYPE_BOOLEAN:
   2622              case ZCL_DATATYPE_BITMAP8:
   2623              case ZCL_DATATYPE_INT8:
   2624              case ZCL_DATATYPE_UINT8:
   2625              case ZCL_DATATYPE_ENUM8:
   2626                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_1:
   \   0000A6   EE4D0000     MOV.B   @R13, 0(R14)
   \   0000AA   1C53         ADD.W   #0x1, R12
   2627                 break;
   \   0000AC   1001         RETA
   2628          
   2629              case ZCL_DATATYPE_DATA16:
   2630              case ZCL_DATATYPE_BITMAP16:
   2631              case ZCL_DATATYPE_UINT16:
   2632              case ZCL_DATATYPE_INT16:
   2633              case ZCL_DATATYPE_ENUM16:
   2634              case ZCL_DATATYPE_SEMI_PREC:
   2635              case ZCL_DATATYPE_CLUSTER_ID:
   2636              case ZCL_DATATYPE_ATTR_ID:
   2637                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_2:
   \   0000AE   ........     BRA     #?Subroutine21
   2638                *buf++ = HI_UINT16( *((uint16*)attrData) );
   2639                break;
   2640          
   2641              case ZCL_DATATYPE_DATA24:
   2642              case ZCL_DATATYPE_BITMAP24:
   2643              case ZCL_DATATYPE_UINT24:
   2644              case ZCL_DATATYPE_INT24:
   2645                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_3:
   \   0000B2   ........     CALLA   #?Subroutine21
   2646                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   2647                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_17:
   \   0000B6   3E4D         MOV.W   @R13+, R14
   \   0000B8   3F4D         MOV.W   @R13+, R15
   \   0000BA   CC4F0000     MOV.B   R15, 0(R12)
   \   0000BE   1C53         ADD.W   #0x1, R12
   2648                break;
   \   0000C0   1001         RETA
   2649          
   2650              case ZCL_DATATYPE_DATA32:
   2651              case ZCL_DATATYPE_BITMAP32:
   2652              case ZCL_DATATYPE_UINT32:
   2653              case ZCL_DATATYPE_INT32:
   2654              case ZCL_DATATYPE_SINGLE_PREC:
   2655              case ZCL_DATATYPE_TOD:
   2656              case ZCL_DATATYPE_DATE:
   2657              case ZCL_DATATYPE_UTC:
   2658              case ZCL_DATATYPE_BAC_OID:
   2659                buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_4:
   \   0000C2   3E4D         MOV.W   @R13+, R14
   \   0000C4   3F4D         MOV.W   @R13+, R15
   \   0000C6   ........     BRA     #osal_buffer_uint32
   2660                break;
   2661          
   2662              case ZCL_DATATYPE_UINT40:
   2663                pStr = (uint8*)attrData;
   2664                buf = zcl_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_5:
   \   0000CA   3E400500     MOV.W   #0x5, R14
   \   0000CE   ........     BRA     #osal_memcpy
   2665                break;
   2666          
   2667              case ZCL_DATATYPE_UINT48:
   2668                pStr = (uint8*)attrData;
   2669                buf = zcl_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_6:
   \   0000D2   3E400600     MOV.W   #0x6, R14
   \   0000D6   ........     BRA     #osal_memcpy
   2670                break;
   2671          
   2672              case ZCL_DATATYPE_IEEE_ADDR:
   2673                pStr = (uint8*)attrData;
   2674                buf = zcl_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_9:
   \   0000DA   3E42         MOV.W   #0x8, R14
   \   0000DC   ........     BRA     #osal_memcpy
   2675                break;
   2676          
   2677              case ZCL_DATATYPE_CHAR_STR:
   2678              case ZCL_DATATYPE_OCTET_STR:
   2679                pStr = (uint8*)attrData;
   2680                len = *pStr;
   2681                buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_7:
   \   0000E0   6E4D         MOV.B   @R13, R14
   \   0000E2   1E53         ADD.W   #0x1, R14
   \   0000E4   ........     BRA     #osal_memcpy
   2682                break;
   2683          
   2684              case ZCL_DATATYPE_LONG_CHAR_STR:
   2685              case ZCL_DATATYPE_LONG_OCTET_STR:
   2686                pStr = (uint8*)attrData;
   2687                len = BUILD_UINT16( pStr[0], pStr[1] );
   2688                buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_8:
   \   0000E8   6E4D         MOV.B   @R13, R14
   \   0000EA   5F4D0100     MOV.B   0x1(R13), R15
   \   0000EE                RPT     #0x8
   \   0000EE   47180F5F     RLAX.W  R15
   \   0000F2   0E5F         ADD.W   R15, R14
   \   0000F4   2E53         ADD.W   #0x2, R14
   \   0000F6   ........     BRA     #osal_memcpy
   2689                break;
   2690          
   2691              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2692                pStr = (uint8*)attrData;
   2693                buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
   \                     ??zclSerializeData_10:
   \   0000FA   3E401000     MOV.W   #0x10, R14
   \   0000FE   ........     CALLA   #osal_memcpy
   2694                break;
   2695          
   2696              case ZCL_DATATYPE_NO_DATA:
   2697              case ZCL_DATATYPE_UNKNOWN:
   2698                // Fall through
   2699          
   2700              default:
   2701                break;
   2702            }
   2703          
   2704            return ( buf );
   \                     ??zclSerializeData_0:
   \   000102   1001         RETA
   2705          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine21:
   \   000000   EE4D0000     MOV.B   @R13, 0(R14)
   \   000004   1C53         ADD.W   #0x1, R12
   \   000006   DC4D01000000 MOV.B   0x1(R13), 0(R12)
   \   00000C   1C53         ADD.W   #0x1, R12
   \   00000E   1001         RETA
   2706          
   2707          #ifdef ZCL_REPORT
   2708          /*********************************************************************
   2709           * @fn      zclAnalogDataType
   2710           *
   2711           * @brief   Checks to see if Data Type is Analog
   2712           *
   2713           * @param   dataType - data type
   2714           *
   2715           * @return  TRUE if data type is analog
   2716           */
   2717          uint8 zclAnalogDataType( uint8 dataType )
   2718          {
   2719            uint8 analog;
   2720          
   2721            switch ( dataType )
   2722            {
   2723              case ZCL_DATATYPE_UINT8:
   2724              case ZCL_DATATYPE_UINT16:
   2725              case ZCL_DATATYPE_UINT24:
   2726              case ZCL_DATATYPE_UINT32:
   2727              case ZCL_DATATYPE_UINT40:
   2728              case ZCL_DATATYPE_UINT48:
   2729              case ZCL_DATATYPE_UINT56:
   2730              case ZCL_DATATYPE_UINT64:
   2731              case ZCL_DATATYPE_INT8:
   2732              case ZCL_DATATYPE_INT16:
   2733              case ZCL_DATATYPE_INT24:
   2734              case ZCL_DATATYPE_INT32:
   2735              case ZCL_DATATYPE_INT40:
   2736              case ZCL_DATATYPE_INT48:
   2737              case ZCL_DATATYPE_INT56:
   2738              case ZCL_DATATYPE_INT64:
   2739              case ZCL_DATATYPE_SEMI_PREC:
   2740              case ZCL_DATATYPE_SINGLE_PREC:
   2741              case ZCL_DATATYPE_DOUBLE_PREC:
   2742              case ZCL_DATATYPE_TOD:
   2743              case ZCL_DATATYPE_DATE:
   2744              case ZCL_DATATYPE_UTC:
   2745                analog = TRUE;
   2746                break;
   2747          
   2748              default:
   2749                analog = FALSE;
   2750                break;
   2751            }
   2752          
   2753            return ( analog );
   2754          }
   2755          
   2756          /*********************************************************************
   2757           * @fn      zclIsLittleEndianMachine
   2758           *
   2759           * @brief   Verifies endianness in system.
   2760           *
   2761           * @param   none
   2762           *
   2763           * @return  MSB-00 or LSB-01 depending on endianness in the system
   2764           */
   2765          static int zclIsLittleEndianMachine(void)
   2766          {
   2767            uint16 test = 0x0001;
   2768          
   2769            return (*((uint8 *)(&test)));
   2770          }
   2771          
   2772          /*********************************************************************
   2773           * @fn      zcl_BuildAnalogData
   2774           *
   2775           * @brief   Build an analog arribute out of sequential bytes.
   2776           *
   2777           * @param   dataType - type of data
   2778           * @param   pData - pointer to data
   2779           * @param   pBuf - where to put the data
   2780           *
   2781           * @return  none
   2782           */
   2783          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   2784          {
   2785            int current_byte_index;
   2786            int remaining_bytes;
   2787            int step;
   2788          
   2789            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   2790          
   2791            // decide if move forward or backwards to copy data
   2792            if ( zclIsLittleEndianMachine() )
   2793            {
   2794              step = 1;
   2795              current_byte_index = 0;
   2796            }
   2797            else
   2798            {
   2799              step = -1;
   2800              current_byte_index = remaining_bytes - 1;
   2801            }
   2802          
   2803            while ( remaining_bytes-- )
   2804            {
   2805              pData[current_byte_index] = *(pBuf++);
   2806              current_byte_index += step;
   2807            }
   2808          }
   2809          #endif // ZCL_REPORT
   2810          
   2811          /*********************************************************************
   2812           * @fn      zclGetDataTypeLength
   2813           *
   2814           * @brief   Return the length of the datatype in octet.
   2815           *
   2816           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   2817           *                ZCL_DATATYPE_CHAR_STR data types.
   2818           *
   2819           * @param   dataType - data type
   2820           *
   2821           * @return  length of data
   2822           */

   \                                 In  segment CODE, align 2
   2823          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   2824          {
   2825            uint8 len;
   2826          
   2827            switch ( dataType )
   \   000000   7C82         SUB.B   #0x8, R12
   \   000002   5124         JEQ     ??zclGetDataTypeLength_0
   \   000004   5C83         SUB.B   #0x1, R12
   \   000006   5124         JEQ     ??zclGetDataTypeLength_1
   \   000008   5C83         SUB.B   #0x1, R12
   \   00000A   5124         JEQ     ??zclGetDataTypeLength_2
   \   00000C   5C83         SUB.B   #0x1, R12
   \   00000E   5224         JEQ     ??zclGetDataTypeLength_3
   \   000010   7C800500     SUB.B   #0x5, R12
   \   000014   4824         JEQ     ??zclGetDataTypeLength_0
   \   000016   7C82         SUB.B   #0x8, R12
   \   000018   4624         JEQ     ??zclGetDataTypeLength_0
   \   00001A   5C83         SUB.B   #0x1, R12
   \   00001C   4624         JEQ     ??zclGetDataTypeLength_1
   \   00001E   5C83         SUB.B   #0x1, R12
   \   000020   4624         JEQ     ??zclGetDataTypeLength_2
   \   000022   5C83         SUB.B   #0x1, R12
   \   000024   4724         JEQ     ??zclGetDataTypeLength_3
   \   000026   7C800500     SUB.B   #0x5, R12
   \   00002A   3D24         JEQ     ??zclGetDataTypeLength_0
   \   00002C   5C83         SUB.B   #0x1, R12
   \   00002E   3D24         JEQ     ??zclGetDataTypeLength_1
   \   000030   5C83         SUB.B   #0x1, R12
   \   000032   3D24         JEQ     ??zclGetDataTypeLength_2
   \   000034   5C83         SUB.B   #0x1, R12
   \   000036   3E24         JEQ     ??zclGetDataTypeLength_3
   \   000038   5C83         SUB.B   #0x1, R12
   \   00003A   3E24         JEQ     ??zclGetDataTypeLength_4
   \   00003C   5C83         SUB.B   #0x1, R12
   \   00003E   3F24         JEQ     ??zclGetDataTypeLength_5
   \   000040   5C83         SUB.B   #0x1, R12
   \   000042   4024         JEQ     ??zclGetDataTypeLength_6
   \   000044   5C83         SUB.B   #0x1, R12
   \   000046   4124         JEQ     ??zclGetDataTypeLength_7
   \   000048   5C83         SUB.B   #0x1, R12
   \   00004A   2D24         JEQ     ??zclGetDataTypeLength_0
   \   00004C   5C83         SUB.B   #0x1, R12
   \   00004E   2D24         JEQ     ??zclGetDataTypeLength_1
   \   000050   5C83         SUB.B   #0x1, R12
   \   000052   2D24         JEQ     ??zclGetDataTypeLength_2
   \   000054   5C83         SUB.B   #0x1, R12
   \   000056   2E24         JEQ     ??zclGetDataTypeLength_3
   \   000058   5C83         SUB.B   #0x1, R12
   \   00005A   2E24         JEQ     ??zclGetDataTypeLength_4
   \   00005C   5C83         SUB.B   #0x1, R12
   \   00005E   2F24         JEQ     ??zclGetDataTypeLength_5
   \   000060   5C83         SUB.B   #0x1, R12
   \   000062   3024         JEQ     ??zclGetDataTypeLength_6
   \   000064   5C83         SUB.B   #0x1, R12
   \   000066   3124         JEQ     ??zclGetDataTypeLength_7
   \   000068   5C83         SUB.B   #0x1, R12
   \   00006A   1D24         JEQ     ??zclGetDataTypeLength_0
   \   00006C   5C83         SUB.B   #0x1, R12
   \   00006E   1D24         JEQ     ??zclGetDataTypeLength_1
   \   000070   7C800700     SUB.B   #0x7, R12
   \   000074   1A24         JEQ     ??zclGetDataTypeLength_1
   \   000076   5C83         SUB.B   #0x1, R12
   \   000078   1D24         JEQ     ??zclGetDataTypeLength_3
   \   00007A   5C83         SUB.B   #0x1, R12
   \   00007C   2624         JEQ     ??zclGetDataTypeLength_7
   \   00007E   7C80A600     SUB.B   #0xa6, R12
   \   000082   1824         JEQ     ??zclGetDataTypeLength_3
   \   000084   5C83         SUB.B   #0x1, R12
   \   000086   1624         JEQ     ??zclGetDataTypeLength_3
   \   000088   5C83         SUB.B   #0x1, R12
   \   00008A   1424         JEQ     ??zclGetDataTypeLength_3
   \   00008C   7C800600     SUB.B   #0x6, R12
   \   000090   0C24         JEQ     ??zclGetDataTypeLength_1
   \   000092   5C83         SUB.B   #0x1, R12
   \   000094   0A24         JEQ     ??zclGetDataTypeLength_1
   \   000096   5C83         SUB.B   #0x1, R12
   \   000098   0D24         JEQ     ??zclGetDataTypeLength_3
   \   00009A   7C800600     SUB.B   #0x6, R12
   \   00009E   1524         JEQ     ??zclGetDataTypeLength_7
   \   0000A0   5C83         SUB.B   #0x1, R12
   \   0000A2   1524         JEQ     ??zclGetDataTypeLength_8
   \   0000A4   173C         JMP     ??zclGetDataTypeLength_9
   2828            {
   2829              case ZCL_DATATYPE_DATA8:
   2830              case ZCL_DATATYPE_BOOLEAN:
   2831              case ZCL_DATATYPE_BITMAP8:
   2832              case ZCL_DATATYPE_INT8:
   2833              case ZCL_DATATYPE_UINT8:
   2834              case ZCL_DATATYPE_ENUM8:
   2835                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   0000A6   5C43         MOV.B   #0x1, R12
   2836                break;
   \   0000A8   1001         RETA
   2837          
   2838              case ZCL_DATATYPE_DATA16:
   2839              case ZCL_DATATYPE_BITMAP16:
   2840              case ZCL_DATATYPE_UINT16:
   2841              case ZCL_DATATYPE_INT16:
   2842              case ZCL_DATATYPE_ENUM16:
   2843              case ZCL_DATATYPE_SEMI_PREC:
   2844              case ZCL_DATATYPE_CLUSTER_ID:
   2845              case ZCL_DATATYPE_ATTR_ID:
   2846                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   0000AA   6C43         MOV.B   #0x2, R12
   2847                break;
   \   0000AC   1001         RETA
   2848          
   2849              case ZCL_DATATYPE_DATA24:
   2850              case ZCL_DATATYPE_BITMAP24:
   2851              case ZCL_DATATYPE_UINT24:
   2852              case ZCL_DATATYPE_INT24:
   2853                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   0000AE   7C400300     MOV.B   #0x3, R12
   2854                break;
   \   0000B2   1001         RETA
   2855          
   2856              case ZCL_DATATYPE_DATA32:
   2857              case ZCL_DATATYPE_BITMAP32:
   2858              case ZCL_DATATYPE_UINT32:
   2859              case ZCL_DATATYPE_INT32:
   2860              case ZCL_DATATYPE_SINGLE_PREC:
   2861              case ZCL_DATATYPE_TOD:
   2862              case ZCL_DATATYPE_DATE:
   2863              case ZCL_DATATYPE_UTC:
   2864              case ZCL_DATATYPE_BAC_OID:
   2865                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   0000B4   6C42         MOV.B   #0x4, R12
   2866                break;
   \   0000B6   1001         RETA
   2867          
   2868             case ZCL_DATATYPE_UINT40:
   2869             case ZCL_DATATYPE_INT40:
   2870                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   0000B8   7C400500     MOV.B   #0x5, R12
   2871                 break;
   \   0000BC   1001         RETA
   2872          
   2873             case ZCL_DATATYPE_UINT48:
   2874             case ZCL_DATATYPE_INT48:
   2875                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   0000BE   7C400600     MOV.B   #0x6, R12
   2876                 break;
   \   0000C2   1001         RETA
   2877          
   2878             case ZCL_DATATYPE_UINT56:
   2879             case ZCL_DATATYPE_INT56:
   2880                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   0000C4   7C400700     MOV.B   #0x7, R12
   2881                 break;
   \   0000C8   1001         RETA
   2882          
   2883             case ZCL_DATATYPE_DOUBLE_PREC:
   2884             case ZCL_DATATYPE_IEEE_ADDR:
   2885             case ZCL_DATATYPE_UINT64:
   2886             case ZCL_DATATYPE_INT64:
   2887               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   0000CA   7C42         MOV.B   #0x8, R12
   2888               break;
   \   0000CC   1001         RETA
   2889          
   2890              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2891               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   0000CE   7C401000     MOV.B   #0x10, R12
   2892               break;
   \   0000D2   1001         RETA
   2893          
   2894              case ZCL_DATATYPE_NO_DATA:
   2895              case ZCL_DATATYPE_UNKNOWN:
   2896                // Fall through
   2897          
   2898              default:
   2899                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000D4   4C43         MOV.B   #0x0, R12
   2900                break;
   2901            }
   2902          
   2903            return ( len );
   \   0000D6   1001         RETA
   2904          }
   2905          
   2906          /*********************************************************************
   2907           * @fn      zclGetAttrDataLength
   2908           *
   2909           * @brief   Return the length of the attribute.
   2910           *
   2911           * @param   dataType - data type
   2912           * @param   pData - pointer to data
   2913           *
   2914           * @return  returns atrribute length
   2915           */

   \                                 In  segment CODE, align 2
   2916          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   2917          {
   2918            uint16 dataLen = 0;
   2919          
   2920            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000000   7C904400     CMP.B   #0x44, R12
   \   000004   0324         JEQ     ??zclGetAttrDataLength_0
   \   000006   7C904300     CMP.B   #0x43, R12
   \   00000A   0820         JNE     ??zclGetAttrDataLength_1
   2921            {
   2922              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   00000C   6C4D         MOV.B   @R13, R12
   \   00000E   5F4D0100     MOV.B   0x1(R13), R15
   \   000012                RPT     #0x8
   \   000012   47180F5F     RLAX.W  R15
   \   000016   0C5F         ADD.W   R15, R12
   \   000018   2C53         ADD.W   #0x2, R12
   \   00001A   1001         RETA
   2923            }
   2924            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001C   7C904200     CMP.B   #0x42, R12
   \   000020   0324         JEQ     ??zclGetAttrDataLength_2
   \   000022   7C904100     CMP.B   #0x41, R12
   \   000026   0320         JNE     ??zclGetAttrDataLength_3
   2925            {
   2926              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_2:
   \   000028   6C4D         MOV.B   @R13, R12
   \   00002A   1C53         ADD.W   #0x1, R12
   \   00002C   1001         RETA
   2927            }
   2928            else
   2929            {
   2930              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_3:
   \   00002E   ........     CALLA   #zclGetDataTypeLength
   \   000032   4C4C         MOV.B   R12, R12
   2931            }
   2932          
   2933            return ( dataLen );
   \   000034   1001         RETA
   2934          }
   2935          
   2936          #ifdef ZCL_READ
   2937          /*********************************************************************
   2938           * @fn      zclReadAttrData
   2939           *
   2940           * @brief   Read the attribute's current value into pAttrData.
   2941           *          NOTE - Not compatible with application's attributes callbacks.
   2942           *
   2943           * @param   pAttrData - where to put attribute data
   2944           * @param   pAttr - pointer to attribute
   2945           * @param   pDataLen - where to put attribute data length
   2946           *
   2947           * @return Success
   2948           */

   \                                 In  segment CODE, align 2
   2949          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   2950          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   \   000006   084E         MOV.W   R14, R8
   2951            uint16 dataLen;
   2952          
   2953            if ( pAttr->attr.dataPtr == NULL )
   \   000008   1D4B0600     MOV.W   0x6(R11), R13
   \   00000C   0D93         CMP.W   #0x0, R13
   \   00000E   0220         JNE     ??zclReadAttrData_0
   2954            {
   2955              return ( ZCL_STATUS_FAILURE );
   \   000010   5C43         MOV.B   #0x1, R12
   \   000012   103C         JMP     ??zclReadAttrData_1
   2956            }
   2957          
   2958            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \                     ??zclReadAttrData_0:
   \   000014   5C4B0400     MOV.B   0x4(R11), R12
   \   000018   ........     CALLA   #zclGetAttrDataLength
   \   00001C   094C         MOV.W   R12, R9
   2959            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   00001E   0E4C         MOV.W   R12, R14
   \   000020   1D4B0600     MOV.W   0x6(R11), R13
   \   000024   0C4A         MOV.W   R10, R12
   \   000026   ........     CALLA   #osal_memcpy
   2960          
   2961            if ( pDataLen != NULL )
   \   00002A   0893         CMP.W   #0x0, R8
   \   00002C   0224         JEQ     ??zclReadAttrData_2
   2962            {
   2963              *pDataLen = dataLen;
   \   00002E   88490000     MOV.W   R9, 0(R8)
   2964            }
   2965          
   2966            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_2:
   \   000032   4C43         MOV.B   #0x0, R12
   \                     ??zclReadAttrData_1:
   \   000034   3817         POPM.W  #0x4, R11
   \   000036   1001         RETA
   2967          }
   2968          
   2969          /*********************************************************************
   2970           * @fn      zcl_ReadAttrData
   2971           *
   2972           * @brief   Read the attribute's current value into pAttrData.
   2973           *          Use application's callback function if assigned to this attribute.
   2974           *
   2975           * @param   endpoint - application's endpoint
   2976           * @param   clusterId - cluster that attribute belongs to
   2977           * @param   attrId - attribute id
   2978           * @param   pAttrData - where to put attribute data
   2979           * @param   pDataLen - where to put attribute data length
   2980           *
   2981           * @return  Successful if data was read
   2982           */

   \                                 In  segment CODE, align 2
   2983          ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zcl_ReadAttrData:
   2984                                                   uint8 *pAttrData, uint16 *pDataLen )
   2985          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   4A4C         MOV.B   R12, R10
   \   000006   0B4D         MOV.W   R13, R11
   \   000008   084E         MOV.W   R14, R8
   \   00000A   094F         MOV.W   R15, R9
   2986            zclAttrRec_t attrRec;
   2987          
   2988            if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE )
   \   00000C   0F41         MOV.W   SP, R15
   \   00000E   0F53         ADD.W   #0x0, R15
   \   000010   ........     CALLA   #??Subroutine9_0
   \                     ??CrossCallReturnLabel_43:
   \   000014   0220         JNE     ??zcl_ReadAttrData_0
   2989            {
   2990              return ( ZCL_STATUS_FAILURE );
   \   000016   5C43         MOV.B   #0x1, R12
   \   000018   133C         JMP     ??zcl_ReadAttrData_1
   2991            }
   \                     ??zcl_ReadAttrData_0:
   \   00001A   1E411400     MOV.W   0x14(SP), R14
   2992          
   2993            if ( attrRec.attr.dataPtr != NULL )
   \   00001E   81930600     CMP.W   #0x0, 0x6(SP)
   \   000022   0624         JEQ     ??zcl_ReadAttrData_2
   2994            {
   2995              return zclReadAttrData( pAttrData, &attrRec, pDataLen );
   \   000024   0D41         MOV.W   SP, R13
   \   000026   0D53         ADD.W   #0x0, R13
   \   000028   0C49         MOV.W   R9, R12
   \   00002A   ........     CALLA   #zclReadAttrData
   \   00002E   083C         JMP     ??zcl_ReadAttrData_1
   2996            }
   2997            else
   2998            {
   2999              return zclReadAttrDataUsingCB( endpoint, clusterId, attrId, pAttrData, pDataLen );
   \                     ??zcl_ReadAttrData_2:
   \   000030   0E12         PUSH.W  R14
   \   000032   0F49         MOV.W   R9, R15
   \   000034   0E48         MOV.W   R8, R14
   \   000036   0D4B         MOV.W   R11, R13
   \   000038   4C4A         MOV.B   R10, R12
   \   00003A   ........     CALLA   #zclReadAttrDataUsingCB
   \   00003E   2153         ADD.W   #0x2, SP
   \                     ??zcl_ReadAttrData_1:
   \   000040   3152         ADD.W   #0x8, SP
   \   000042   3817         POPM.W  #0x4, R11
   \   000044   1001         RETA
   3000            }
   3001          }
   3002          
   3003          /*********************************************************************
   3004           * @fn      zclGetAttrDataLengthUsingCB
   3005           *
   3006           * @brief   Use application's callback to get the length of the attribute's
   3007           *          current value stored in the database.
   3008           *
   3009           * @param   endpoint - application's endpoint
   3010           * @param   clusterId - cluster that attribute belongs to
   3011           * @param   attrId - attribute id
   3012           *
   3013           * @return  returns attribute length
   3014           */

   \                                 In  segment CODE, align 2
   \                     ??Subroutine18_0:
   \   000000   0A4C         MOV.W   R12, R10
   \   000002   0B4D         MOV.W   R13, R11
   \   000004   0F4C         MOV.W   R12, R15
   \   000006   0FDD         BIS.W   R13, R15
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   1001         RETA

   \                                 In  segment CODE, align 2
   3015          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   3016          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   084D         MOV.W   R13, R8
   \   000006   094E         MOV.W   R14, R9
   3017            uint16 dataLen = 0;
   \   000008   81430000     MOV.W   #0x0, 0(SP)
   3018            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00000C   ........     CALLA   #zclGetReadWriteCB
   \   000010   ........     CALLA   #??Subroutine18_0
   3019          
   3020            if ( pfnReadWriteCB != NULL )
   \                     ??CrossCallReturnLabel_29:
   \   000014   0A24         JEQ     ??zclGetAttrDataLengthUsingCB_0
   3021            {
   3022              // Only get the attribute length
   3023              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000016   0F41         MOV.W   SP, R15
   \   000018   0F53         ADD.W   #0x0, R15
   \   00001A   0F12         PUSH.W  R15
   \   00001C   0F43         MOV.W   #0x0, R15
   \   00001E   4E43         MOV.B   #0x0, R14
   \   000020   0D49         MOV.W   R9, R13
   \   000022   0C48         MOV.W   R8, R12
   \   000024   ........     CALLA   #?IndCallR11
   \   000028   2153         ADD.W   #0x2, SP
   3024            }
   3025          
   3026            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   00002A   2C41         MOV.W   @SP, R12
   \   00002C   2153         ADD.W   #0x2, SP
   \   00002E   3817         POPM.W  #0x4, R11
   \   000030   1001         RETA
   3027          }
   3028          
   3029          /*********************************************************************
   3030           * @fn      zclReadAttrDataUsingCB
   3031           *
   3032           * @brief   Use application's callback to read the attribute's current
   3033           *          value stored in the database.
   3034           *
   3035           * @param   endpoint - application's endpoint
   3036           * @param   clusterId - cluster that attribute belongs to
   3037           * @param   attrId - attribute id
   3038           * @param   pAttrData - where to put attribute data
   3039           * @param   pDataLen - where to put attribute data length
   3040           *
   3041           * @return  Successful if data was read
   3042           */

   \                                 In  segment CODE, align 2
   3043          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   3044                                                   uint8 *pAttrData, uint16 *pDataLen )
   3045          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   084D         MOV.W   R13, R8
   \   000004   094E         MOV.W   R14, R9
   \   000006   064F         MOV.W   R15, R6
   3046            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000008   ........     CALLA   #zclGetReadWriteCB
   \   00000C   0A4C         MOV.W   R12, R10
   \   00000E   0B4D         MOV.W   R13, R11
   \   000010   1F411000     MOV.W   0x10(SP), R15
   3047          
   3048            if ( pDataLen != NULL )
   \   000014   0F93         CMP.W   #0x0, R15
   \   000016   0224         JEQ     ??zclReadAttrDataUsingCB_0
   3049            {
   3050              *pDataLen = 0; // Always initialize it to 0
   \   000018   8F430000     MOV.W   #0x0, 0(R15)
   3051            }
   3052          
   3053            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   00001C   0E4C         MOV.W   R12, R14
   \   00001E   0EDD         BIS.W   R13, R14
   \   000020   0E93         CMP.W   #0x0, R14
   \   000022   0924         JEQ     ??zclReadAttrDataUsingCB_1
   3054            {
   3055              // Read the attribute value and its length
   3056              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   000024   0F12         PUSH.W  R15
   \   000026   0F46         MOV.W   R6, R15
   \   000028   5E43         MOV.B   #0x1, R14
   \   00002A   0D49         MOV.W   R9, R13
   \   00002C   0C48         MOV.W   R8, R12
   \   00002E   ........     CALLA   #?IndCallR11
   \   000032   2153         ADD.W   #0x2, SP
   \   000034   023C         JMP     ??zclReadAttrDataUsingCB_2
   3057            }
   3058          
   3059            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   000036   7C40C100     MOV.B   #0xc1, R12
   \                     ??zclReadAttrDataUsingCB_2:
   \   00003A   5617         POPM.W  #0x6, R11
   \   00003C   1001         RETA
   3060          }
   3061          
   3062          /*********************************************************************
   3063           * @fn      zclAuthorizeRead
   3064           *
   3065           * @brief   Use application's callback to authorize a Read operation
   3066           *          on a given attribute.
   3067           *
   3068           * @param   endpoint - application's endpoint
   3069           * @param   srcAddr - source Address
   3070           * @param   pAttr - pointer to attribute
   3071           *
   3072           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3073           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3074           */
   3075          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   3076          {
   3077            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   3078            {
   3079              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   3080          
   3081              if ( pfnAuthorizeCB != NULL )
   3082              {
   3083                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   3084              }
   3085            }
   3086          
   3087            return ( ZCL_STATUS_SUCCESS );
   3088          }
   3089          #endif // ZCL_READ
   3090          
   3091          #ifdef ZCL_WRITE
   3092          /*********************************************************************
   3093           * @fn      zclWriteAttrData
   3094           *
   3095           * @brief   Write the received data.
   3096           *
   3097           * @param   endpoint - application's endpoint
   3098           * @param   pAttr - where to write data to
   3099           * @param   pWriteRec - data to be written
   3100           *
   3101           * @return  Successful if data was written
   3102           */

   \                                 In  segment CODE, align 2
   3103          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrData:
   3104                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   3105          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4E         MOV.W   R14, R10
   \   000004   0B4F         MOV.W   R15, R11
   3106            uint8 status;
   3107          
   3108            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000006   EEB30500     BIT.B   #0x2, 0x5(R14)
   \   00000A   2228         JNC     ??zclWriteAttrData_0
   3109            {
   3110              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   00000C   ........     CALLA   #zclAuthorizeWrite
   \   000010   484C         MOV.B   R12, R8
   3111              if ( status == ZCL_STATUS_SUCCESS )
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   1F20         JNE     ??zclWriteAttrData_1
   3112              {
   3113                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \   000016   1F42....     MOV.W   &zcl_ValidateAttrDataCB, R15
   \   00001A   1FD2....     BIS.W   &zcl_ValidateAttrDataCB + 2, R15
   \   00001E   0F93         CMP.W   #0x0, R15
   \   000020   0624         JEQ     ??zclWriteAttrData_2
   \   000022   0D4B         MOV.W   R11, R13
   \   000024   0C4A         MOV.W   R10, R12
   \   000026   ........     CALLA   &zcl_ValidateAttrDataCB
   \   00002A   4C93         CMP.B   #0x0, R12
   \   00002C   0E24         JEQ     ??zclWriteAttrData_3
   3114                {
   3115                  // Write the attribute value
   3116                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   00002E   1D4B0400     MOV.W   0x4(R11), R13
   \   000032   5C4A0400     MOV.B   0x4(R10), R12
   \   000036   ........     CALLA   #zclGetAttrDataLength
   \   00003A   0E4C         MOV.W   R12, R14
   3117                  zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   00003C   1D4B0400     MOV.W   0x4(R11), R13
   \   000040   1C4A0600     MOV.W   0x6(R10), R12
   \   000044   ........     CALLA   #osal_memcpy
   3118          
   3119                  status = ZCL_STATUS_SUCCESS;
   \   000048   053C         JMP     ??zclWriteAttrData_1
   3120                }
   3121                else
   3122                {
   3123                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   00004A   78408700     MOV.B   #0x87, R8
   \   00004E   023C         JMP     ??zclWriteAttrData_1
   3124                }
   3125              }
   3126            }
   3127            else
   3128            {
   3129              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   000050   78408800     MOV.B   #0x88, R8
   3130            }
   3131          
   3132            return ( status );
   \                     ??zclWriteAttrData_1:
   \   000054   4C48         MOV.B   R8, R12
   \   000056   3817         POPM.W  #0x4, R11
   \   000058   1001         RETA
   3133          }
   3134          
   3135          /*********************************************************************
   3136           * @fn      zclWriteAttrDataUsingCB
   3137           *
   3138           * @brief   Use application's callback to write the attribute's current
   3139           *          value stored in the database.
   3140           *
   3141           * @param   endpoint - application's endpoint
   3142           * @param   pAttr - where to write data to
   3143           * @param   pAttrData - data to be written
   3144           *
   3145           * @return  Successful if data was written
   3146           */

   \                                 In  segment CODE, align 2
   3147          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrDataUsingCB:
   3148                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   3149          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   084E         MOV.W   R14, R8
   \   000006   094F         MOV.W   R15, R9
   3150            uint8 status;
   3151          
   3152            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000008   EEB30500     BIT.B   #0x2, 0x5(R14)
   \   00000C   1728         JNC     ??zclWriteAttrDataUsingCB_0
   3153            {
   3154              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   00000E   ........     CALLA   #zclAuthorizeWrite
   3155              if ( status == ZCL_STATUS_SUCCESS )
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   1520         JNE     ??zclWriteAttrDataUsingCB_1
   3156              {
   3157                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000016   4C4A         MOV.B   R10, R12
   \   000018   ........     CALLA   #zclGetReadWriteCB
   \   00001C   ........     CALLA   #??Subroutine18_0
   3158                if ( pfnReadWriteCB != NULL )
   \                     ??CrossCallReturnLabel_28:
   \   000020   0A24         JEQ     ??zclWriteAttrDataUsingCB_2
   3159                {
   3160                  // Write the attribute value
   3161                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   3162                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   000022   0312         PUSH.W  #0x0
   \   000024   0F49         MOV.W   R9, R15
   \   000026   6E43         MOV.B   #0x2, R14
   \   000028   1D480200     MOV.W   0x2(R8), R13
   \   00002C   2C48         MOV.W   @R8, R12
   \   00002E   ........     CALLA   #?IndCallR11
   \   000032   2153         ADD.W   #0x2, SP
   \   000034   053C         JMP     ??zclWriteAttrDataUsingCB_1
   3163                }
   3164                else
   3165                {
   3166                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   000036   7C40C100     MOV.B   #0xc1, R12
   \   00003A   023C         JMP     ??zclWriteAttrDataUsingCB_1
   3167                }
   3168              }
   3169            }
   3170            else
   3171            {
   3172              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   00003C   7C408800     MOV.B   #0x88, R12
   3173            }
   3174          
   3175            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   000040   3817         POPM.W  #0x4, R11
   \   000042   1001         RETA
   3176          }
   3177          
   3178          /*********************************************************************
   3179           * @fn      zclAuthorizeWrite
   3180           *
   3181           * @brief   Use application's callback to authorize a Write operation
   3182           *          on a given attribute.
   3183           *
   3184           * @param   endpoint - application's endpoint
   3185           * @param   srcAddr - source Address
   3186           * @param   pAttr - pointer to attribute
   3187           *
   3188           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3189           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3190           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine18:
   \   000000   ........     CALLA   #zclGetAuthorizeCB
   \   000004                REQUIRE ??Subroutine18_0
   \   000004                // Fall through to label ??Subroutine18_0

   \                                 In  segment CODE, align 2
   3191          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   3192          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   084D         MOV.W   R13, R8
   \   000004   094E         MOV.W   R14, R9
   3193            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   000006   FEB020000500 BIT.B   #0x20, 0x5(R14)
   \   00000C   0928         JNC     ??zclAuthorizeWrite_0
   3194            {
   3195              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00000E   ........     CALLA   #?Subroutine18
   3196          
   3197              if ( pfnAuthorizeCB != NULL )
   \                     ??CrossCallReturnLabel_27:
   \   000012   0624         JEQ     ??zclAuthorizeWrite_0
   3198              {
   3199                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000014   6E43         MOV.B   #0x2, R14
   \   000016   0D49         MOV.W   R9, R13
   \   000018   0C48         MOV.W   R8, R12
   \   00001A   ........     CALLA   #?IndCallR11
   \   00001E   013C         JMP     ??zclAuthorizeWrite_1
   3200              }
   3201            }
   3202          
   3203            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   000020   4C43         MOV.B   #0x0, R12
   \                     ??zclAuthorizeWrite_1:
   \   000022   3817         POPM.W  #0x4, R11
   \   000024   1001         RETA
   3204          }
   3205          #endif // ZCL_WRITE
   3206          
   3207          #ifdef ZCL_READ
   3208          /*********************************************************************
   3209           * @fn      zclParseInReadCmd
   3210           *
   3211           * @brief   Parse the "Profile" Read Commands
   3212           *
   3213           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3214           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3215           *
   3216           * @param   pCmd - pointer to incoming data to parse
   3217           *
   3218           * @return  pointer to the parsed command structure
   3219           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   1C4B0200     MOV.W   0x2(R11), R12
   \   000004   2C53         ADD.W   #0x2, R12
   \   000006                REQUIRE ??Subroutine5_0
   \   000006                // Fall through to label ??Subroutine5_0

   \                                 In  segment CODE, align 2
   3220          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   3221          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0B4C         MOV.W   R12, R11
   3222            zclReadCmd_t *readCmd;
   3223            uint8 *pBuf = pCmd->pData;
   \   000004   1A4C0400     MOV.W   0x4(R12), R10
   3224          
   3225            readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \   000008   ........     CALLA   #?Subroutine5
   3226            if ( readCmd != NULL )
   \                     ??CrossCallReturnLabel_46:
   \   00000C   1724         JEQ     ??zclParseInReadCmd_1
   3227            {
   3228              uint8 i;
   3229              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   00000E   1E4B0200     MOV.W   0x2(R11), R14
   \   000012   5E03         RRUM.W  #0x1, R14
   \   000014   CC4E0000     MOV.B   R14, 0(R12)
   3230              for ( i = 0; i < readCmd->numAttr; i++ )
   \   000018   4E43         MOV.B   #0x0, R14
   \   00001A   0E3C         JMP     ??zclParseInReadCmd_2
   3231              {
   3232                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_0:
   \   00001C   6D4A         MOV.B   @R10, R13
   \   00001E   5F4A0100     MOV.B   0x1(R10), R15
   \   000022                RPT     #0x8
   \   000022   47180F5F     RLAX.W  R15
   \   000026   0D5F         ADD.W   R15, R13
   \   000028   4F4E         MOV.B   R14, R15
   \   00002A   0F5F         RLA.W   R15
   \   00002C   0B4C         MOV.W   R12, R11
   \   00002E   0B5F         ADD.W   R15, R11
   \   000030   8B4D0200     MOV.W   R13, 0x2(R11)
   3233                pBuf += 2;
   \   000034   2A53         ADD.W   #0x2, R10
   3234              }
   \   000036   5E53         ADD.B   #0x1, R14
   \                     ??zclParseInReadCmd_2:
   \   000038   6E9C         CMP.B   @R12, R14
   \   00003A   F02B         JNC     ??zclParseInReadCmd_0
   3235            }
   3236          
   3237            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_1:
   \   00003C   1A17         POPM.W  #0x2, R11
   \   00003E   1001         RETA
   3238          }
   3239          
   3240          /*********************************************************************
   3241           * @fn      zclParseInReadRspCmd
   3242           *
   3243           * @brief   Parse the "Profile" Read Response Commands
   3244           *
   3245           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3246           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3247           *
   3248           * @param   pCmd - pointer to incoming data to parse
   3249           *
   3250           * @return  pointer to the parsed command structure
   3251           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   6A43         MOV.B   #0x2, R10
   \   000002                RPT     #0x6
   \   000002   45184A5B     ADDX.B  R11, R10
   \   000006   4C4A         MOV.B   R10, R12
   \   000008   0C58         ADD.W   R8, R12
   \   00000A                REQUIRE ??Subroutine4_0
   \   00000A                // Fall through to label ??Subroutine4_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   0C48         MOV.W   R8, R12
   \   000002   7417         POPM.W  #0x8, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
   3252          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   3253          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   074C         MOV.W   R12, R7
   3254            zclReadRspCmd_t *readRspCmd;
   3255            uint8 *pBuf = pCmd->pData;
   \   000004   194C0400     MOV.W   0x4(R12), R9
   3256            uint8 *dataPtr;
   3257            uint8 numAttr = 0;
   \   000008   4B43         MOV.B   #0x0, R11
   3258            uint8 hdrLen;
   3259            uint16 dataLen = 0;
   \   00000A   0843         MOV.W   #0x0, R8
   \   00000C   073C         JMP     ??zclParseInReadRspCmd_4
   3260            uint16 attrDataLen;
   3261          
   3262            // find out the number of attributes and the length of attribute data
   3263            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3264            {
   3265              uint8 status;
   3266          
   3267              numAttr++;
   \                     ??zclParseInReadRspCmd_0:
   \   00000E   5B53         ADD.B   #0x1, R11
   3268              pBuf += 2; // move pass attribute id
   \   000010   2953         ADD.W   #0x2, R9
   3269          
   3270              status = *pBuf++;
   \   000012   7E49         MOV.B   @R9+, R14
   3271              if ( status == ZCL_STATUS_SUCCESS )
   \   000014   4E93         CMP.B   #0x0, R14
   \   000016   0220         JNE     ??zclParseInReadRspCmd_4
   3272              {
   3273                uint8 dataType = *pBuf++;
   \   000018   ........     CALLA   #?Subroutine11
   3274          
   3275                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   3276                pBuf += attrDataLen; // move pass attribute data
   3277          
   3278                // add padding if needed
   3279                if ( PADDING_NEEDED( attrDataLen ) )
   3280                {
   3281                  attrDataLen++;
   3282                }
   3283          
   3284                dataLen += attrDataLen;
   3285              }
   3286            }
   \                     ??zclParseInReadRspCmd_4:
   \   00001C   1F470400     MOV.W   0x4(R7), R15
   \   000020   1F570200     ADD.W   0x2(R7), R15
   \   000024   099F         CMP.W   R15, R9
   \   000026   F32B         JNC     ??zclParseInReadRspCmd_0
   3287          
   3288            // calculate the length of the response header
   3289            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   000028   ........     CALLA   #?Subroutine4
   3290          
   3291            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3292            if ( readRspCmd != NULL )
   \                     ??CrossCallReturnLabel_34:
   \   00002C   1224         JEQ     ??zclParseInReadRspCmd_5
   3293            {
   3294              uint8 i;
   3295              pBuf = pCmd->pData;
   \   00002E   ........     CALLA   #?Subroutine19
   3296              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   3297          
   3298              readRspCmd->numAttr = numAttr;
   3299              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_12:
   \   000032   0D3C         JMP     ??zclParseInReadRspCmd_6
   3300              {
   3301                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_1:
   \   000034   ........     CALLA   #?Subroutine13
   3302          
   3303                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3304                pBuf += 2;
   3305          
   3306                statusRec->status = *pBuf++;
   3307                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_7:
   \   000038   C7930200     CMP.B   #0x0, 0x2(R7)
   \   00003C   0720         JNE     ??zclParseInReadRspCmd_7
   3308                {
   3309                  statusRec->dataType = *pBuf++;
   \   00003E   F7490300     MOV.B   @R9+, 0x3(R7)
   3310          
   3311                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   000042   0D49         MOV.W   R9, R13
   \   000044   5C470300     MOV.B   0x3(R7), R12
   \   000048   ........     CALLA   #?Subroutine10
   3312                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   3313                  statusRec->data = dataPtr;
   3314          
   3315                  pBuf += attrDataLen; // move pass attribute data
   3316          
   3317                  // advance attribute data pointer
   3318                  if ( PADDING_NEEDED( attrDataLen ) )
   3319                  {
   3320                    attrDataLen++;
   3321                  }
   3322          
   3323                  dataPtr += attrDataLen;
   3324                }
   3325              }
   \                     ??zclParseInReadRspCmd_7:
   \   00004C   5653         ADD.B   #0x1, R6
   \                     ??zclParseInReadRspCmd_6:
   \   00004E   469B         CMP.B   R11, R6
   \   000050   F12B         JNC     ??zclParseInReadRspCmd_1
   3326            }
   3327          
   3328            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_5:
   \   000052   ....         JMP     ?Subroutine1
   \   000054   0343         NOP
   3329          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine19:
   \   000000   19470400     MOV.W   0x4(R7), R9
   \   000004   4F4A         MOV.B   R10, R15
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   0A5F         ADD.W   R15, R10
   \   00000A   CC4B0000     MOV.B   R11, 0(R12)
   \   00000E   4643         MOV.B   #0x0, R6
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine13:
   \   000000   0F46         MOV.W   R6, R15
   \   000002                RPT     #0x5
   \   000002   44180F56     ADDX.W  R6, R15
   \   000006   0748         MOV.W   R8, R7
   \   000008   075F         ADD.W   R15, R7
   \   00000A   2753         ADD.W   #0x2, R7
   \   00000C   6E49         MOV.B   @R9, R14
   \   00000E   5F490100     MOV.B   0x1(R9), R15
   \   000012                RPT     #0x8
   \   000012   47180F5F     RLAX.W  R15
   \   000016   0E5F         ADD.W   R15, R14
   \   000018   874E0000     MOV.W   R14, 0(R7)
   \   00001C   2953         ADD.W   #0x2, R9
   \   00001E   F7490200     MOV.B   @R9+, 0x2(R7)
   \   000022   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine11:
   \   000000   7C49         MOV.B   @R9+, R12
   \   000002   0D49         MOV.W   R9, R13
   \   000004   ........     CALLA   #zclGetAttrDataLength
   \   000008   044C         MOV.W   R12, R4
   \   00000A   095C         ADD.W   R12, R9
   \   00000C   1CB3         BIT.W   #0x1, R12
   \   00000E   0128         JNC     ??zclParseInWriteCmd_3
   \   000010   1453         ADD.W   #0x1, R4
   \                     ??zclParseInWriteCmd_3:
   \   000012   0854         ADD.W   R4, R8
   \   000014   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine10:
   \   000000   ........     CALLA   #zclGetAttrDataLength
   \   000004   044C         MOV.W   R12, R4
   \   000006   0E4C         MOV.W   R12, R14
   \   000008   0D49         MOV.W   R9, R13
   \   00000A   0C4A         MOV.W   R10, R12
   \   00000C   ........     CALLA   #osal_memcpy
   \   000010   874A0400     MOV.W   R10, 0x4(R7)
   \   000014   0954         ADD.W   R4, R9
   \   000016   14B3         BIT.W   #0x1, R4
   \   000018   0128         JNC     ??zclParseInWriteCmd_2
   \   00001A   1453         ADD.W   #0x1, R4
   \                     ??zclParseInWriteCmd_2:
   \   00001C   0A54         ADD.W   R4, R10
   \   00001E   1001         RETA
   3330          #endif // ZCL_READ
   3331          
   3332          #ifdef ZCL_WRITE
   3333          /*********************************************************************
   3334           * @fn      zclParseInWriteCmd
   3335           *
   3336           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   3337           *          Response Commands
   3338           *
   3339           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3340           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3341           *
   3342           * @param   pCmd - pointer to incoming data to parse
   3343           *
   3344           * @return  pointer to the parsed command structure
   3345           */

   \                                 In  segment CODE, align 2, keep-with-next
   3346          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   3347          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   074C         MOV.W   R12, R7
   3348            zclWriteCmd_t *writeCmd;
   3349            uint8 *pBuf = pCmd->pData;
   \   000004   194C0400     MOV.W   0x4(R12), R9
   3350            uint16 attrDataLen;
   3351            uint8 *dataPtr;
   3352            uint8 numAttr = 0;
   \   000008   4B43         MOV.B   #0x0, R11
   3353            uint8 hdrLen;
   3354            uint16 dataLen = 0;
   \   00000A   0843         MOV.W   #0x0, R8
   \   00000C   043C         JMP     ??zclParseInWriteCmd_4
   3355          
   3356            // find out the number of attributes and the length of attribute data
   3357            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3358            {
   3359              uint8 dataType;
   3360          
   3361              numAttr++;
   \                     ??zclParseInWriteCmd_0:
   \   00000E   5B53         ADD.B   #0x1, R11
   3362              pBuf += 2; // move pass attribute id
   \   000010   2953         ADD.W   #0x2, R9
   3363          
   3364              dataType = *pBuf++;
   \   000012   ........     CALLA   #?Subroutine11
   3365          
   3366              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   3367              pBuf += attrDataLen; // move pass attribute data
   3368          
   3369              // add padding if needed
   3370              if ( PADDING_NEEDED( attrDataLen ) )
   3371              {
   3372                attrDataLen++;
   3373              }
   3374          
   3375              dataLen += attrDataLen;
   3376            }
   \                     ??zclParseInWriteCmd_4:
   \   000016   1F470400     MOV.W   0x4(R7), R15
   \   00001A   1F570200     ADD.W   0x2(R7), R15
   \   00001E   099F         CMP.W   R15, R9
   \   000020   F62B         JNC     ??zclParseInWriteCmd_0
   3377          
   3378            // calculate the length of the response header
   3379            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   000022   ........     CALLA   #?Subroutine4
   3380          
   3381            writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3382            if ( writeCmd != NULL )
   \                     ??CrossCallReturnLabel_33:
   \   000026   0D24         JEQ     ??zclParseInWriteCmd_5
   3383            {
   3384              uint8 i;
   3385              pBuf = pCmd->pData;
   \   000028   ........     CALLA   #?Subroutine19
   3386              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   3387          
   3388              writeCmd->numAttr = numAttr;
   3389              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_11:
   \   00002C   083C         JMP     ??zclParseInWriteCmd_6
   3390              {
   3391                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_1:
   \   00002E   ........     CALLA   #?Subroutine13
   3392          
   3393                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3394                pBuf += 2;
   3395                statusRec->dataType = *pBuf++;
   3396          
   3397                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_6:
   \   000032   0D49         MOV.W   R9, R13
   \   000034   5C470200     MOV.B   0x2(R7), R12
   \   000038   ........     CALLA   #?Subroutine10
   3398                zcl_memcpy( dataPtr, pBuf, attrDataLen);
   3399                statusRec->attrData = dataPtr;
   3400          
   3401                pBuf += attrDataLen; // move pass attribute data
   3402          
   3403                // advance attribute data pointer
   3404                if ( PADDING_NEEDED( attrDataLen ) )
   3405                {
   3406                  attrDataLen++;
   3407                }
   3408          
   3409                dataPtr += attrDataLen;
   3410              }
   \                     ??CrossCallReturnLabel_3:
   \   00003C   5653         ADD.B   #0x1, R6
   \                     ??zclParseInWriteCmd_6:
   \   00003E   469B         CMP.B   R11, R6
   \   000040   F62B         JNC     ??zclParseInWriteCmd_1
   3411            }
   3412          
   3413            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_5:
   \   000042                REQUIRE ?Subroutine1
   \   000042                // Fall through to label ?Subroutine1
   3414          }
   3415          
   3416          /*********************************************************************
   3417           * @fn      zclParseInWriteRspCmd
   3418           *
   3419           * @brief   Parse the "Profile" Write Response Commands
   3420           *
   3421           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3422           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3423           *
   3424           * @param   pCmd - pointer to incoming data to parse
   3425           *
   3426           * @return  pointer to the parsed command structure
   3427           */

   \                                 In  segment CODE, align 2
   3428          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   3429          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0B4C         MOV.W   R12, R11
   3430            zclWriteRspCmd_t *writeRspCmd;
   3431            uint8 *pBuf = pCmd->pData;
   \   000004   184C0400     MOV.W   0x4(R12), R8
   3432            uint8 i = 0;
   \   000008   4A43         MOV.B   #0x0, R10
   3433          
   3434            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \   00000A   ........     CALLA   #?Subroutine5
   3435            if ( writeRspCmd != NULL )
   \                     ??CrossCallReturnLabel_45:
   \   00000E   1F24         JEQ     ??zclParseInWriteRspCmd_1
   3436            {
   3437              if ( pCmd->dataLen == 1 )
   \   000010   9B930200     CMP.W   #0x1, 0x2(R11)
   \   000014   1420         JNE     ??zclParseInWriteRspCmd_2
   3438              {
   3439                // special case when all writes were successfull
   3440                writeRspCmd->attrList[i++].status = *pBuf;
   \   000016   EC480200     MOV.B   @R8, 0x2(R12)
   \   00001A   5A43         MOV.B   #0x1, R10
   \   00001C   163C         JMP     ??zclParseInWriteRspCmd_3
   3441              }
   3442              else
   3443              {
   3444                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3445                {
   3446                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_0:
   \   00001E   4F4A         MOV.B   R10, R15
   \   000020   5F06         RLAM.W  #0x2, R15
   \   000022   0D4C         MOV.W   R12, R13
   \   000024   0D5F         ADD.W   R15, R13
   \   000026   FD480200     MOV.B   @R8+, 0x2(R13)
   3447                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   00002A   6E48         MOV.B   @R8, R14
   \   00002C   5F480100     MOV.B   0x1(R8), R15
   \   000030                RPT     #0x8
   \   000030   47180F5F     RLAX.W  R15
   \   000034   0E5F         ADD.W   R15, R14
   \   000036   8D4E0400     MOV.W   R14, 0x4(R13)
   \   00003A   5A53         ADD.B   #0x1, R10
   3448                  pBuf += 2;
   \   00003C   2853         ADD.W   #0x2, R8
   3449                }
   \                     ??zclParseInWriteRspCmd_2:
   \   00003E   1F4B0400     MOV.W   0x4(R11), R15
   \   000042   1F5B0200     ADD.W   0x2(R11), R15
   \   000046   089F         CMP.W   R15, R8
   \   000048   EA2B         JNC     ??zclParseInWriteRspCmd_0
   3450              }
   3451          
   3452              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   00004A   CC4A0000     MOV.B   R10, 0(R12)
   3453            }
   3454          
   3455            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_1:
   \   00004E   3817         POPM.W  #0x4, R11
   \   000050   1001         RETA
   3456          }
   3457          #endif // ZCL_WRITE
   3458          
   3459          #ifdef ZCL_REPORT
   3460          /*********************************************************************
   3461           * @fn      zclParseInConfigReportCmd
   3462           *
   3463           * @brief   Parse the "Profile" Configure Reporting Command
   3464           *
   3465           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3466           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3467           *
   3468           * @param   pCmd - pointer to incoming data to parse
   3469           *
   3470           * @return  pointer to the parsed command structure
   3471           */
   3472          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   3473          {
   3474            zclCfgReportCmd_t *cfgReportCmd;
   3475            uint8 *pBuf = pCmd->pData;
   3476            uint8 *dataPtr;
   3477            uint8 numAttr = 0;
   3478            uint8 dataType;
   3479            uint8 hdrLen;
   3480            uint16 dataLen = 0;
   3481            uint8 reportChangeLen; // length of Reportable Change field
   3482          
   3483            // Calculate the length of the Request command
   3484            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3485            {
   3486              uint8 direction;
   3487          
   3488              numAttr++;
   3489              direction = *pBuf++;
   3490              pBuf += 2; // move pass the attribute ID
   3491          
   3492              // Is there a Reportable Change field?
   3493              if ( direction == ZCL_SEND_ATTR_REPORTS )
   3494              {
   3495                dataType = *pBuf++;
   3496                pBuf += 4; // move pass the Min and Max Reporting Intervals
   3497          
   3498                // For attributes of 'discrete' data types this field is omitted
   3499                if ( zclAnalogDataType( dataType ) )
   3500                {
   3501                  reportChangeLen = zclGetDataTypeLength( dataType );
   3502                  pBuf += reportChangeLen;
   3503          
   3504                  // add padding if needed
   3505                  if ( PADDING_NEEDED( reportChangeLen ) )
   3506                  {
   3507                    reportChangeLen++;
   3508                  }
   3509          
   3510                  dataLen += reportChangeLen;
   3511                }
   3512                else
   3513                {
   3514                  pBuf++; // move past reportable change field
   3515                }
   3516              }
   3517              else
   3518              {
   3519                pBuf += 2; // move pass the Timeout Period
   3520              }
   3521            } // while loop
   3522          
   3523            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   3524          
   3525            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3526            if ( cfgReportCmd != NULL )
   3527            {
   3528              uint8 i;
   3529              pBuf = pCmd->pData;
   3530              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   3531          
   3532              cfgReportCmd->numAttr = numAttr;
   3533              for ( i = 0; i < numAttr; i++ )
   3534              {
   3535                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   3536          
   3537                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   3538          
   3539                reportRec->direction = *pBuf++;
   3540                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3541                pBuf += 2;
   3542                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   3543                {
   3544                  // Attribute to be reported
   3545                  reportRec->dataType = *pBuf++;
   3546                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3547                  pBuf += 2;
   3548                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3549                  pBuf += 2;
   3550          
   3551                  // For attributes of 'discrete' data types this field is omitted
   3552                  if ( zclAnalogDataType( reportRec->dataType ) )
   3553                  {
   3554                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   3555                    reportRec->reportableChange = dataPtr;
   3556          
   3557                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   3558                    pBuf += reportChangeLen;
   3559          
   3560                    // advance attribute data pointer
   3561                    if ( PADDING_NEEDED( reportChangeLen ) )
   3562                    {
   3563                      reportChangeLen++;
   3564                    }
   3565          
   3566                    dataPtr += reportChangeLen;
   3567                  }
   3568                }
   3569                else
   3570                {
   3571                  // Attribute reports to be received
   3572                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   3573                  pBuf += 2;
   3574                }
   3575              } // while loop
   3576            }
   3577          
   3578            return ( (void *)cfgReportCmd );
   3579          }
   3580          
   3581          /*********************************************************************
   3582           * @fn      zclParseInConfigReportRspCmd
   3583           *
   3584           * @brief   Parse the "Profile" Configure Reporting Response Command
   3585           *
   3586           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3587           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3588           *
   3589           * @param   pCmd - pointer to incoming data to parse
   3590           *
   3591           * @return  pointer to the parsed command structure
   3592           */
   3593          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   3594          {
   3595            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3596            uint8 *pBuf = pCmd->pData;
   3597            uint8 numAttr;
   3598          
   3599            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   3600          
   3601            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3602                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   3603            if ( cfgReportRspCmd != NULL )
   3604            {
   3605              uint8 i;
   3606              cfgReportRspCmd->numAttr = numAttr;
   3607              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   3608              {
   3609                cfgReportRspCmd->attrList[i].status = *pBuf++;
   3610                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   3611                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3612                pBuf += 2;
   3613              }
   3614            }
   3615          
   3616            return ( (void *)cfgReportRspCmd );
   3617          }
   3618          
   3619          /*********************************************************************
   3620           * @fn      zclParseInReadReportCfgCmd
   3621           *
   3622           * @brief   Parse the "Profile" Read Reporting Configuration Command
   3623           *
   3624           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3625           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3626           *
   3627           * @param   pCmd - pointer to incoming data to parse
   3628           *
   3629           * @return  pointer to the parsed command structure
   3630           */
   3631          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   3632          {
   3633            zclReadReportCfgCmd_t *readReportCfgCmd;
   3634            uint8 *pBuf = pCmd->pData;
   3635            uint8 numAttr;
   3636          
   3637            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   3638          
   3639            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   3640                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   3641            if ( readReportCfgCmd != NULL )
   3642            {
   3643              uint8 i;
   3644              readReportCfgCmd->numAttr = numAttr;
   3645              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   3646              {
   3647                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   3648                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3649                pBuf += 2;
   3650              }
   3651            }
   3652          
   3653            return ( (void *)readReportCfgCmd );
   3654          }
   3655          
   3656          /*********************************************************************
   3657           * @fn      zclParseInReadReportCfgRspCmd
   3658           *
   3659           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   3660           *
   3661           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3662           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3663           *
   3664           * @param   pCmd - pointer to incoming data to parse
   3665           *
   3666           * @return  pointer to the parsed command structure
   3667           */
   3668          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   3669          {
   3670            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   3671            uint8 reportChangeLen;
   3672            uint8 *pBuf = pCmd->pData;
   3673            uint8 *dataPtr;
   3674            uint8 numAttr = 0;
   3675            uint8 hdrLen;
   3676            uint16 dataLen = 0;
   3677          
   3678            // Calculate the length of the response command
   3679            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3680            {
   3681              uint8 status;
   3682              uint8 direction;
   3683          
   3684              numAttr++;
   3685              status = *pBuf++;
   3686              direction = *pBuf++;
   3687              pBuf += 2; // move pass the attribute ID
   3688          
   3689              if ( status == ZCL_STATUS_SUCCESS )
   3690              {
   3691                if ( direction == ZCL_SEND_ATTR_REPORTS )
   3692                {
   3693                  uint8 dataType = *pBuf++;
   3694                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   3695          
   3696                  // For attributes of 'discrete' data types this field is omitted
   3697                  if ( zclAnalogDataType( dataType ) )
   3698                  {
   3699                    reportChangeLen = zclGetDataTypeLength( dataType );
   3700                    pBuf += reportChangeLen;
   3701          
   3702                    // add padding if needed
   3703                    if ( PADDING_NEEDED( reportChangeLen ) )
   3704                    {
   3705                      reportChangeLen++;
   3706                    }
   3707          
   3708                    dataLen += reportChangeLen;
   3709                  }
   3710                }
   3711                else
   3712                {
   3713                  pBuf += 2; // move pass the Timeout field
   3714                }
   3715              }
   3716            } // while loop
   3717          
   3718            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   3719          
   3720            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3721            if ( readReportCfgRspCmd != NULL )
   3722            {
   3723              uint8 i;
   3724              pBuf = pCmd->pData;
   3725              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   3726          
   3727              readReportCfgRspCmd->numAttr = numAttr;
   3728              for ( i = 0; i < numAttr; i++ )
   3729              {
   3730                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   3731          
   3732                reportRspRec->status = *pBuf++;
   3733                reportRspRec->direction = *pBuf++;
   3734                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3735                pBuf += 2;
   3736          
   3737                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   3738                {
   3739                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   3740                  {
   3741                    reportRspRec->dataType = *pBuf++;
   3742                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3743                    pBuf += 2;
   3744                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3745                    pBuf += 2;
   3746          
   3747                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   3748                    {
   3749                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   3750                      reportRspRec->reportableChange = dataPtr;
   3751          
   3752                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   3753                      pBuf += reportChangeLen;
   3754          
   3755                      // advance attribute data pointer
   3756                      if ( PADDING_NEEDED( reportChangeLen ) )
   3757                      {
   3758                        reportChangeLen++;
   3759                      }
   3760          
   3761                      dataPtr += reportChangeLen;
   3762                    }
   3763                  }
   3764                  else
   3765                  {
   3766                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   3767                    pBuf += 2;
   3768                  }
   3769                }
   3770              }
   3771            }
   3772          
   3773            return ( (void *)readReportCfgRspCmd );
   3774          }
   3775          
   3776          /*********************************************************************
   3777           * @fn      zclParseInReportCmd
   3778           *
   3779           * @brief   Parse the "Profile" Report Command
   3780           *
   3781           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3782           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3783           *
   3784           * @param   pCmd - pointer to incoming data to parse
   3785           *
   3786           * @return  pointer to the parsed command structure
   3787           */
   3788          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   3789          {
   3790            zclReportCmd_t *reportCmd;
   3791            uint8 *pBuf = pCmd->pData;
   3792            uint16 attrDataLen;
   3793            uint8 *dataPtr;
   3794            uint8 numAttr = 0;
   3795            uint8 hdrLen;
   3796            uint16 dataLen = 0;
   3797          
   3798            // find out the number of attributes and the length of attribute data
   3799            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3800            {
   3801              uint8 dataType;
   3802          
   3803              numAttr++;
   3804              pBuf += 2; // move pass attribute id
   3805          
   3806              dataType = *pBuf++;
   3807          
   3808              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   3809              pBuf += attrDataLen; // move pass attribute data
   3810          
   3811              // add padding if needed
   3812              if ( PADDING_NEEDED( attrDataLen ) )
   3813              {
   3814                attrDataLen++;
   3815              }
   3816          
   3817              dataLen += attrDataLen;
   3818            }
   3819          
   3820            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   3821          
   3822            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3823            if (reportCmd != NULL )
   3824            {
   3825              uint8 i;
   3826              pBuf = pCmd->pData;
   3827              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   3828          
   3829              reportCmd->numAttr = numAttr;
   3830              for ( i = 0; i < numAttr; i++ )
   3831              {
   3832                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   3833          
   3834                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3835                pBuf += 2;
   3836                reportRec->dataType = *pBuf++;
   3837          
   3838                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   3839                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   3840                reportRec->attrData = dataPtr;
   3841          
   3842                pBuf += attrDataLen; // move pass attribute data
   3843          
   3844                // advance attribute data pointer
   3845                if ( PADDING_NEEDED( attrDataLen ) )
   3846                {
   3847                  attrDataLen++;
   3848                }
   3849          
   3850                dataPtr += attrDataLen;
   3851              }
   3852            }
   3853          
   3854            return ( (void *)reportCmd );
   3855          }
   3856          #endif // ZCL_REPORT
   3857          
   3858          /*********************************************************************
   3859           * @fn      zclParseInDefaultRspCmd
   3860           *
   3861           * @brief   Parse the "Profile" Default Response Command
   3862           *
   3863           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3864           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3865           *
   3866           * @param   pCmd - pointer to incoming data to parse
   3867           *
   3868           * @return  pointer to the parsed command structure
   3869           */

   \                                 In  segment CODE, align 2
   3870          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   3871          {
   \   000000   0A12         PUSH.W  R10
   3872            zclDefaultRspCmd_t *defaultRspCmd;
   3873            uint8 *pBuf = pCmd->pData;
   \   000002   1A4C0400     MOV.W   0x4(R12), R10
   3874          
   3875            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \   000006   2C43         MOV.W   #0x2, R12
   \   000008   ........     CALLA   #??Subroutine5_0
   3876            if ( defaultRspCmd != NULL )
   \                     ??CrossCallReturnLabel_47:
   \   00000C   0424         JEQ     ??zclParseInDefaultRspCmd_0
   3877            {
   3878              defaultRspCmd->commandID = *pBuf++;
   \   00000E   FC4A0000     MOV.B   @R10+, 0(R12)
   3879              defaultRspCmd->statusCode = *pBuf;
   \   000012   EC4A0100     MOV.B   @R10, 0x1(R12)
   3880            }
   3881          
   3882            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   000016   3A41         POP.W   R10
   \   000018   1001         RETA
   3883          }
   3884          
   3885          #ifdef ZCL_DISCOVER
   3886          /*********************************************************************
   3887           * @fn      zclParseInDiscAttrsCmd
   3888           *
   3889           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   3890           *
   3891           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3892           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3893           *
   3894           * @param   pCmd - pointer to incoming data to parse
   3895           *
   3896           * @return  pointer to the parsed command structure
   3897           */
   3898          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   3899          {
   3900            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   3901            uint8 *pBuf = pCmd->pData;
   3902          
   3903            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   3904            if ( pDiscoverCmd != NULL )
   3905            {
   3906              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   3907              pBuf += 2;
   3908              pDiscoverCmd->maxAttrIDs = *pBuf;
   3909            }
   3910          
   3911            return ( (void *)pDiscoverCmd );
   3912          }
   3913          
   3914          /*********************************************************************
   3915           * @fn      zclParseInDiscAttrsRspCmd
   3916           *
   3917           * @brief   Parse the "Profile" Discovery Response Commands
   3918           *
   3919           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3920           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3921           *
   3922           * @param   pCmd - pointer to incoming data to parse
   3923           *
   3924           * @return  pointer to the parsed command structure
   3925           */
   3926          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3927          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   3928          {
   3929            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   3930            uint8 *pBuf = pCmd->pData;
   3931            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   3932          
   3933            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   3934                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   3935          
   3936            if ( pDiscoverRspCmd != NULL )
   3937            {
   3938              pDiscoverRspCmd->discComplete = *pBuf++;
   3939              pDiscoverRspCmd->numAttr = numAttr;
   3940          
   3941              for ( uint8 i = 0; i < numAttr; i++ )
   3942              {
   3943                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3944                pBuf += 2;
   3945                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   3946              }
   3947            }
   3948          
   3949            return ( (void *)pDiscoverRspCmd );
   3950          }
   3951          
   3952          /*********************************************************************
   3953           * @fn      zclParseInDiscCmdsCmd
   3954           *
   3955           * @brief   Parse the "Profile" Discovery Commands
   3956           *
   3957           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3958           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3959           *
   3960           * @param   pCmd - pointer to incoming data to parse
   3961           *
   3962           * @return  pointer to the parsed command structure
   3963           */
   3964          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   3965          {
   3966            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   3967            uint8 *pBuf = pCmd->pData;
   3968          
   3969            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   3970            if ( pDiscoverCmd != NULL )
   3971            {
   3972              pDiscoverCmd->startCmdID = *pBuf++;
   3973              pDiscoverCmd->maxCmdID = *pBuf++;
   3974            }
   3975          
   3976            return ( (void *)pDiscoverCmd );
   3977          }
   3978          
   3979          /*********************************************************************
   3980           * @fn      zclParseInDiscCmdsRspCmd
   3981           *
   3982           * @brief   Parse the Discover Commands Response Command
   3983           *
   3984           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3985           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3986           *
   3987           * @param   pCmd - pointer to incoming data to parse
   3988           *
   3989           * @return  pointer to the parsed command structure
   3990           */
   3991          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3992          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   3993          {
   3994            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   3995            uint8 *pBuf = pCmd->pData;
   3996            uint8 i;
   3997            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // determine length of command ID variable array
   3998          
   3999            // allocate memory for size of structure plus variable array
   4000            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( 1 + numCmds );
   4001            if ( pDiscoverRspCmd != NULL )
   4002            {
   4003              pDiscoverRspCmd->discComplete = *pBuf++;
   4004              pDiscoverRspCmd->numCmd = numCmds;
   4005          
   4006              for ( i = 0; i < numCmds; i++ )
   4007              {
   4008                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   4009              }
   4010            }
   4011          
   4012            return ( (void *)pDiscoverRspCmd );
   4013          }
   4014          
   4015          /*********************************************************************
   4016           * @fn      zclParseInDiscAttrsExtRspCmd
   4017           *
   4018           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   4019           *
   4020           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4021           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4022           *
   4023           * @param   pCmd - pointer to incoming data to parse
   4024           *
   4025           * @return  pointer to the parsed command structure
   4026           */
   4027          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4028          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   4029          {
   4030            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   4031            uint8 i;
   4032            uint8 *pBuf = pCmd->pData;
   4033            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   4034          
   4035            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   4036                              ( numAttrs * sizeof(zclDiscoverAttrsExtRsp_t) ) );
   4037          
   4038            if ( pDiscoverRspCmd != NULL )
   4039            {
   4040              pDiscoverRspCmd->discComplete = *pBuf++;
   4041              pDiscoverRspCmd->numAttr = numAttrs;
   4042          
   4043              for ( i = 0; i < numAttrs; i++ )
   4044              {
   4045                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4046                pBuf += 2;
   4047                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   4048                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   4049              }
   4050            }
   4051          
   4052            return ( (void *)pDiscoverRspCmd );
   4053          }
   4054          #endif // ZCL_DISCOVER
   4055          
   4056          #ifdef ZCL_READ
   4057          /*********************************************************************
   4058           * @fn      zclProcessInReadCmd
   4059           *
   4060           * @brief   Process the "Profile" Read Command
   4061           *
   4062           * @param   pInMsg - incoming message to process
   4063           *
   4064           * @return  TRUE if command processed. FALSE, otherwise.
   4065           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine15:
   \   000000   B8B20200     BIT.W   #0x8, 0x2(R8)
   \   000004                REQUIRE ??Subroutine15_0
   \   000004                // Fall through to label ??Subroutine15_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   3152         ADD.W   #0x8, SP
   \   000002   7417         POPM.W  #0x8, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
   4066          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   4067          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   084C         MOV.W   R12, R8
   4068            zclReadCmd_t *readCmd;
   4069            zclReadRspCmd_t *readRspCmd;
   4070            zclAttrRec_t attrRec;
   4071            uint16 len;
   4072            uint8 i;
   4073          
   4074            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   000006   174C0C00     MOV.W   0xc(R12), R7
   4075          
   4076            // calculate the length of the response status record
   4077            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   4078          
   4079            readRspCmd = zcl_mem_alloc( len );
   \   00000A   6F47         MOV.B   @R7, R15
   \   00000C   2C43         MOV.W   #0x2, R12
   \   00000E                RPT     #0x6
   \   00000E   45180C5F     ADDX.W  R15, R12
   \   000012   ........     CALLA   #?Subroutine6
   4080            if ( readRspCmd == NULL )
   \                     ??CrossCallReturnLabel_1:
   \   000016   0220         JNE     ??zclProcessInReadCmd_2
   4081            {
   4082              return FALSE; // EMBEDDED RETURN
   \   000018   4C43         MOV.B   #0x0, R12
   \   00001A   603C         JMP     ??zclProcessInReadCmd_3
   4083            }
   4084          
   4085            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_2:
   \   00001C   EC470000     MOV.B   @R7, 0(R12)
   4086            for ( i = 0; i < readCmd->numAttr; i++ )
   \   000020   4443         MOV.B   #0x0, R4
   \   000022   043C         JMP     ??zclProcessInReadCmd_4
   4087            {
   4088              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   4089          
   4090              statusRec->attrID = readCmd->attrID[i];
   4091          
   4092              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4093                                   readCmd->attrID[i], &attrRec ) )
   4094              {
   4095                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   4096                {
   4097                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   4098                                                        &(pInMsg->msg->srcAddr), &attrRec );
   4099                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   4100                  {
   4101                    statusRec->data = attrRec.attr.dataPtr;
   4102                    statusRec->dataType = attrRec.attr.dataType;
   4103                  }
   4104                }
   4105                else
   4106                {
   4107                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   4108                }
   4109              }
   4110              else
   4111              {
   4112                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_0:
   \   000024   F94086000200 MOV.B   #0x86, 0x2(R9)
   4113              }
   \                     ??zclProcessInReadCmd_1:
   \   00002A   5453         ADD.B   #0x1, R4
   \                     ??zclProcessInReadCmd_4:
   \   00002C   6497         CMP.B   @R7, R4
   \   00002E   3F2C         JC      ??zclProcessInReadCmd_5
   \   000030   4F44         MOV.B   R4, R15
   \   000032   0B4F         MOV.W   R15, R11
   \   000034                RPT     #0x5
   \   000034   44180B5F     ADDX.W  R15, R11
   \   000038   0946         MOV.W   R6, R9
   \   00003A   095B         ADD.W   R11, R9
   \   00003C   2953         ADD.W   #0x2, R9
   \   00003E   0F5F         RLA.W   R15
   \   000040   0B47         MOV.W   R7, R11
   \   000042   0B5F         ADD.W   R15, R11
   \   000044   2B53         ADD.W   #0x2, R11
   \   000046   A94B0000     MOV.W   @R11, 0(R9)
   \   00004A   2A48         MOV.W   @R8, R10
   \   00004C   0F41         MOV.W   SP, R15
   \   00004E   0F53         ADD.W   #0x0, R15
   \   000050   2E4B         MOV.W   @R11, R14
   \   000052   1D4A0400     MOV.W   0x4(R10), R13
   \   000056   5C4A1400     MOV.B   0x14(R10), R12
   \   00005A   ........     CALLA   #??Subroutine9_0
   \                     ??CrossCallReturnLabel_42:
   \   00005E   E227         JEQ     ??zclProcessInReadCmd_0
   \   000060   D1B30500     BIT.B   #0x1, 0x5(SP)
   \   000064   2028         JNC     ??zclProcessInReadCmd_6
   \   000066   2F48         MOV.W   @R8, R15
   \   000068   054F         MOV.W   R15, R5
   \   00006A   35500600     ADD.W   #0x6, R5
   \   00006E   F1B010000500 BIT.B   #0x10, 0x5(SP)
   \   000074   0C28         JNC     ??zclProcessInReadCmd_7
   \   000076   5C4F1400     MOV.B   0x14(R15), R12
   \   00007A   ........     CALLA   #?Subroutine18
   \                     ??CrossCallReturnLabel_26:
   \   00007E   0724         JEQ     ??zclProcessInReadCmd_7
   \   000080   5E43         MOV.B   #0x1, R14
   \   000082   0D41         MOV.W   SP, R13
   \   000084   0D53         ADD.W   #0x0, R13
   \   000086   0C45         MOV.W   R5, R12
   \   000088   ........     CALLA   #?IndCallR11
   \   00008C   013C         JMP     ??zclProcessInReadCmd_8
   \                     ??zclProcessInReadCmd_7:
   \   00008E   4C43         MOV.B   #0x0, R12
   \                     ??zclProcessInReadCmd_8:
   \   000090   C94C0200     MOV.B   R12, 0x2(R9)
   \   000094   4C93         CMP.B   #0x0, R12
   \   000096   C923         JNE     ??zclProcessInReadCmd_1
   \   000098   994106000400 MOV.W   0x6(SP), 0x4(R9)
   \   00009E   D94104000300 MOV.B   0x4(SP), 0x3(R9)
   \   0000A4   C23F         JMP     ??zclProcessInReadCmd_1
   \                     ??zclProcessInReadCmd_6:
   \   0000A6   F9408F000200 MOV.B   #0x8f, 0x2(R9)
   \   0000AC   BE3F         JMP     ??zclProcessInReadCmd_1
   4114            }
   4115          
   4116            // Build and send Read Response command
   4117            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   4118                             readRspCmd, !pInMsg->hdr.fc.direction,
   4119                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_5:
   \   0000AE   2A48         MOV.W   @R8, R10
   \   0000B0   58120600     PUSH.B  0x6(R8)
   \   0000B4   5312         PUSH.B  #0x1
   \   0000B6   ........     CALLA   #?Subroutine15
   \                     ??CrossCallReturnLabel_22:
   \   0000BA   4E12         PUSH.B  R14
   \   0000BC   0F46         MOV.W   R6, R15
   \   0000BE   1E4A0400     MOV.W   0x4(R10), R14
   \   0000C2   0D4A         MOV.W   R10, R13
   \   0000C4   3D500600     ADD.W   #0x6, R13
   \   0000C8   5C4A1400     MOV.B   0x14(R10), R12
   \   0000CC   ........     CALLA   #zcl_SendReadRsp
   4120            zcl_mem_free( readRspCmd );
   \   0000D0   0C46         MOV.W   R6, R12
   \   0000D2   ........     CALLA   #osal_mem_free
   4121          
   4122            return TRUE;
   \   0000D6   5C43         MOV.B   #0x1, R12
   \   0000D8   31500600     ADD.W   #0x6, SP
   \                     ??zclProcessInReadCmd_3:
   \   0000DC   ....         JMP     ?Subroutine0
   \   0000DE   0343         NOP
   4123          }
   4124          #endif // ZCL_READ
   4125          
   4126          #ifdef ZCL_WRITE
   4127          /*********************************************************************
   4128           * @fn      processInWriteCmd
   4129           *
   4130           * @brief   Process the "Profile" Write and Write No Response Commands
   4131           *
   4132           * @param   pInMsg - incoming message to process
   4133           *
   4134           * @return  TRUE if command processed. FALSE, otherwise.
   4135           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   000000   2E44         MOV.W   @R4, R14
   \   000002                REQUIRE ??Subroutine28_0
   \   000002                // Fall through to label ??Subroutine28_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   1D4C0400     MOV.W   0x4(R12), R13
   \   000004   5C4C1400     MOV.B   0x14(R12), R12
   \   000008                REQUIRE ??Subroutine9_0
   \   000008                // Fall through to label ??Subroutine9_0

   \                                 In  segment CODE, align 2, keep-with-next
   4136          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   4137          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   0B4C         MOV.W   R12, R11
   4138            zclWriteCmd_t *writeCmd;
   4139            zclWriteRspCmd_t *writeRspCmd;
   4140            uint8 sendRsp = FALSE;
   \   000006   4943         MOV.B   #0x0, R9
   4141            uint8 j = 0;
   \   000008   4A43         MOV.B   #0x0, R10
   4142            uint8 i;
   4143          
   4144            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   00000A   154C0C00     MOV.W   0xc(R12), R5
   4145            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \   00000E   EC930700     CMP.B   #0x2, 0x7(R12)
   \   000012   0920         JNE     ??zclProcessInWriteCmd_3
   4146            {
   4147              // We need to send a response back - allocate space for it
   4148              writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4149                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   000014   6C45         MOV.B   @R5, R12
   \   000016   5C06         RLAM.W  #0x2, R12
   \   000018   2C53         ADD.W   #0x2, R12
   \   00001A   ........     CALLA   #??Subroutine4_0
   4150              if ( writeRspCmd == NULL )
   \                     ??CrossCallReturnLabel_35:
   \   00001E   0220         JNE     ??zclProcessInWriteCmd_4
   4151              {
   4152                return FALSE; // EMBEDDED RETURN
   \   000020   4C43         MOV.B   #0x0, R12
   \   000022   613C         JMP     ??zclProcessInWriteCmd_5
   4153              }
   4154          
   4155              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_4:
   \   000024   5943         MOV.B   #0x1, R9
   4156            }
   4157          
   4158            for ( i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_3:
   \   000026   4643         MOV.B   #0x0, R6
   \   000028   093C         JMP     ??zclProcessInWriteCmd_6
   4159            {
   4160              zclAttrRec_t attrRec;
   4161              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4162          
   4163              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4164                                   statusRec->attrID, &attrRec ) )
   4165              {
   4166                if ( statusRec->dataType == attrRec.attr.dataType )
   4167                {
   4168                  uint8 status;
   4169          
   4170                  // Write the new attribute value
   4171                  if ( attrRec.attr.dataPtr != NULL )
   4172                  {
   4173                    status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4174                                               &attrRec, statusRec );
   4175                  }
   4176                  else // Use CB
   4177                  {
   4178                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4179                                                      &attrRec, statusRec->attrData );
   4180                  }
   4181          
   4182                  // If successful, a write attribute status record shall NOT be generated
   4183                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   4184                  {
   4185                    // Attribute is read only - move on to the next write attribute record
   4186                    writeRspCmd->attrList[j].status = status;
   4187                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4188                  }
   4189                }
   4190                else
   4191                {
   4192                  // Attribute data type is incorrect - move on to the next write attribute record
   4193                  if ( sendRsp )
   4194                  {
   4195                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4196                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4197                  }
   4198                }
   4199              }
   4200              else
   4201              {
   4202                // Attribute is not supported - move on to the next write attribute record
   4203                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_0:
   \   00002A   59B3         BIT.B   #0x1, R9
   \   00002C   0628         JNC     ??zclProcessInWriteCmd_1
   4204                {
   4205                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   00002E   F74086000200 MOV.B   #0x86, 0x2(R7)
   4206                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \                     ??zclProcessInWriteCmd_2:
   \   000034   A7440400     MOV.W   @R4, 0x4(R7)
   \   000038   5A53         ADD.B   #0x1, R10
   4207                }
   4208              }
   \                     ??zclProcessInWriteCmd_1:
   \   00003A   5653         ADD.B   #0x1, R6
   \                     ??zclProcessInWriteCmd_6:
   \   00003C   6695         CMP.B   @R5, R6
   \   00003E   312C         JC      ??zclProcessInWriteCmd_7
   \   000040   0F46         MOV.W   R6, R15
   \   000042                RPT     #0x5
   \   000042   44180F56     ADDX.W  R6, R15
   \   000046   0445         MOV.W   R5, R4
   \   000048   045F         ADD.W   R15, R4
   \   00004A   2453         ADD.W   #0x2, R4
   \   00004C   4F4A         MOV.B   R10, R15
   \   00004E   5F06         RLAM.W  #0x2, R15
   \   000050   0748         MOV.W   R8, R7
   \   000052   075F         ADD.W   R15, R7
   \   000054   2C4B         MOV.W   @R11, R12
   \   000056   0F41         MOV.W   SP, R15
   \   000058   0F53         ADD.W   #0x0, R15
   \   00005A   ........     CALLA   #?Subroutine9
   \                     ??CrossCallReturnLabel_39:
   \   00005E   E527         JEQ     ??zclProcessInWriteCmd_0
   \   000060   D49104000200 CMP.B   0x4(SP), 0x2(R4)
   \   000066   1720         JNE     ??zclProcessInWriteCmd_8
   \   000068   2C4B         MOV.W   @R11, R12
   \   00006A   81930600     CMP.W   #0x0, 0x6(SP)
   \   00006E   0624         JEQ     ??zclProcessInWriteCmd_9
   \   000070   0F44         MOV.W   R4, R15
   \   000072   ........     CALLA   #?Subroutine12
   \                     ??CrossCallReturnLabel_4:
   \   000076   ........     CALLA   #zclWriteAttrData
   \   00007A   063C         JMP     ??zclProcessInWriteCmd_10
   \                     ??zclProcessInWriteCmd_9:
   \   00007C   1F440400     MOV.W   0x4(R4), R15
   \   000080   ........     CALLA   #?Subroutine12
   \                     ??CrossCallReturnLabel_5:
   \   000084   ........     CALLA   #zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteCmd_10:
   \   000088   59B3         BIT.B   #0x1, R9
   \   00008A   D72B         JNC     ??zclProcessInWriteCmd_1
   \   00008C   4C93         CMP.B   #0x0, R12
   \   00008E   D527         JEQ     ??zclProcessInWriteCmd_1
   \   000090   C74C0200     MOV.B   R12, 0x2(R7)
   \   000094   CF3F         JMP     ??zclProcessInWriteCmd_2
   \                     ??zclProcessInWriteCmd_8:
   \   000096   59B3         BIT.B   #0x1, R9
   \   000098   D02B         JNC     ??zclProcessInWriteCmd_1
   \   00009A   F7408D000200 MOV.B   #0x8d, 0x2(R7)
   \   0000A0   C93F         JMP     ??zclProcessInWriteCmd_2
   4209            } // for loop
   4210          
   4211            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_7:
   \   0000A2   59B3         BIT.B   #0x1, R9
   \   0000A4   1F28         JNC     ??zclProcessInWriteCmd_11
   4212            {
   4213              writeRspCmd->numAttr = j;
   \   0000A6   C84A0000     MOV.B   R10, 0(R8)
   4214              if ( writeRspCmd->numAttr == 0 )
   \   0000AA   4A93         CMP.B   #0x0, R10
   \   0000AC   0420         JNE     ??zclProcessInWriteCmd_12
   4215              {
   4216                // Since all records were written successful, include a single status record
   4217                // in the resonse command with the status field set to SUCCESS and the
   4218                // attribute ID field omitted.
   4219                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0000AE   C8430200     MOV.B   #0x0, 0x2(R8)
   4220                writeRspCmd->numAttr = 1;
   \   0000B2   D8430000     MOV.B   #0x1, 0(R8)
   4221              }
   4222          
   4223              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4224                                pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4225                                true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteCmd_12:
   \   0000B6   274B         MOV.W   @R11, R7
   \   0000B8   5B120600     PUSH.B  0x6(R11)
   \   0000BC   5312         PUSH.B  #0x1
   \   0000BE   BBB20200     BIT.W   #0x8, 0x2(R11)
   \   0000C2   ........     CALLA   #??Subroutine15_0
   \                     ??CrossCallReturnLabel_18:
   \   0000C6   4E12         PUSH.B  R14
   \   0000C8   0F48         MOV.W   R8, R15
   \   0000CA   1E470400     MOV.W   0x4(R7), R14
   \   0000CE   0D47         MOV.W   R7, R13
   \   0000D0   3D500600     ADD.W   #0x6, R13
   \   0000D4   5C471400     MOV.B   0x14(R7), R12
   \   0000D8   ........     CALLA   #zcl_SendWriteRsp
   4226              zcl_mem_free( writeRspCmd );
   \   0000DC   ........     CALLA   #??Subroutine26_0
   4227            }
   \                     ??CrossCallReturnLabel_30:
   \   0000E0   31500600     ADD.W   #0x6, SP
   4228          
   4229            return TRUE;
   \                     ??zclProcessInWriteCmd_11:
   \   0000E4   5C43         MOV.B   #0x1, R12
   \                     ??zclProcessInWriteCmd_5:
   \   0000E6                REQUIRE ?Subroutine0
   \   0000E6                // Fall through to label ?Subroutine0
   4230          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine12:
   \   000000   ........     CALLA   #?Subroutine22
   \                     ??CrossCallReturnLabel_25:
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine22:
   \   000000   0E41         MOV.W   SP, R14
   \   000002   3E52         ADD.W   #0x8, R14
   \   000004                REQUIRE ??Subroutine24_0
   \   000004                // Fall through to label ??Subroutine24_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine24_0:
   \   000000   0D4C         MOV.W   R12, R13
   \   000002   3D500600     ADD.W   #0x6, R13
   \   000006   5C4C1400     MOV.B   0x14(R12), R12
   \   00000A   1001         RETA
   4231          
   4232          /*********************************************************************
   4233           * @fn      zclRevertWriteUndividedCmd
   4234           *
   4235           * @brief   Revert the "Profile" Write Undevided Command
   4236           *
   4237           * @param   pInMsg - incoming message to process
   4238           * @param   curWriteRec - old data
   4239           * @param   numAttr - number of attributes to be reverted
   4240           *
   4241           * @return  none
   4242           */

   \                                 In  segment CODE, align 2
   4243          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   4244                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   4245          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   0B4C         MOV.W   R12, R11
   \   000006   084D         MOV.W   R13, R8
   \   000008   094E         MOV.W   R14, R9
   4246            uint8 i;
   4247          
   4248            for ( i = 0; i < numAttr; i++ )
   \   00000A   4A43         MOV.B   #0x0, R10
   \   00000C   0C3C         JMP     ??zclRevertWriteUndividedCmd_2
   4249            {
   4250              zclAttrRec_t attrRec;
   4251              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   4252          
   4253              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4254                                    statusRec->attrID, &attrRec ) )
   4255              {
   4256                break; // should never happen
   4257              }
   4258          
   4259              if ( attrRec.attr.dataPtr != NULL )
   4260              {
   4261                // Just copy the old data back - no need to validate the data
   4262                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   4263                zcl_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   4264              }
   4265              else // Use CB
   4266              {
   4267                // Write the old data back
   4268                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4269                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_0:
   \   00000E   264B         MOV.W   @R11, R6
   \   000010   0F4D         MOV.W   R13, R15
   \   000012   0E41         MOV.W   SP, R14
   \   000014   0E53         ADD.W   #0x0, R14
   \   000016   0D46         MOV.W   R6, R13
   \   000018   3D500600     ADD.W   #0x6, R13
   \   00001C   5C461400     MOV.B   0x14(R6), R12
   \   000020   ........     CALLA   #zclWriteAttrDataUsingCB
   4270              }
   \                     ??zclRevertWriteUndividedCmd_1:
   \   000024   5A53         ADD.B   #0x1, R10
   \                     ??zclRevertWriteUndividedCmd_2:
   \   000026   0A99         CMP.W   R9, R10
   \   000028   1D2C         JC      ??zclRevertWriteUndividedCmd_3
   \   00002A   0F4A         MOV.W   R10, R15
   \   00002C                RPT     #0x5
   \   00002C   44180F5A     ADDX.W  R10, R15
   \   000030   0648         MOV.W   R8, R6
   \   000032   065F         ADD.W   R15, R6
   \   000034   2C4B         MOV.W   @R11, R12
   \   000036   0F41         MOV.W   SP, R15
   \   000038   0F53         ADD.W   #0x0, R15
   \   00003A   2E46         MOV.W   @R6, R14
   \   00003C   ........     CALLA   #??Subroutine28_0
   \                     ??CrossCallReturnLabel_40:
   \   000040   1124         JEQ     ??zclRevertWriteUndividedCmd_3
   \   000042   1D460400     MOV.W   0x4(R6), R13
   \   000046   17410600     MOV.W   0x6(SP), R7
   \   00004A   0793         CMP.W   #0x0, R7
   \   00004C   E027         JEQ     ??zclRevertWriteUndividedCmd_0
   \   00004E   5C410400     MOV.B   0x4(SP), R12
   \   000052   ........     CALLA   #zclGetAttrDataLength
   \   000056   0E4C         MOV.W   R12, R14
   \   000058   1D460400     MOV.W   0x4(R6), R13
   \   00005C   0C47         MOV.W   R7, R12
   \   00005E   ........     CALLA   #osal_memcpy
   \   000062   E03F         JMP     ??zclRevertWriteUndividedCmd_1
   4271            } // for loop
   4272          }
   \                     ??zclRevertWriteUndividedCmd_3:
   \   000064   3152         ADD.W   #0x8, SP
   \   000066   5617         POPM.W  #0x6, R11
   \   000068   1001         RETA
   4273          
   4274          /*********************************************************************
   4275           * @fn      zclProcessInWriteUndividedCmd
   4276           *
   4277           * @brief   Process the "Profile" Write Undivided Command
   4278           *
   4279           * @param   pInMsg - incoming message to process
   4280           *
   4281           * @return  TRUE if command processed. FALSE, otherwise.
   4282           */

   \                                 In  segment CODE, align 2
   4283          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   4284          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   31800C00     SUB.W   #0xc, SP
   \   000006   084C         MOV.W   R12, R8
   4285            zclWriteCmd_t *writeCmd;
   4286            zclWriteRspCmd_t *writeRspCmd;
   4287            zclAttrRec_t attrRec;
   4288            uint16 dataLen;
   4289            uint16 curLen = 0;
   \   000008   0743         MOV.W   #0x0, R7
   4290            uint8 j = 0;
   \   00000A   4A43         MOV.B   #0x0, R10
   4291            uint8 i;
   4292          
   4293            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   00000C   154C0C00     MOV.W   0xc(R12), R5
   4294          
   4295            // Allocate space for Write Response Command
   4296            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4297                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \   000010   6C45         MOV.B   @R5, R12
   \   000012   5C06         RLAM.W  #0x2, R12
   \   000014   2C53         ADD.W   #0x2, R12
   \   000016   ........     CALLA   #osal_mem_alloc
   \   00001A   094C         MOV.W   R12, R9
   4298            if ( writeRspCmd == NULL )
   \   00001C   0C93         CMP.W   #0x0, R12
   \   00001E   3624         JEQ     ??zclProcessInWriteUndividedCmd_6
   4299            {
   4300              return FALSE; // EMBEDDED RETURN
   4301            }
   4302          
   4303            // If any attribute cannot be written, no attribute values are changed. Hence,
   4304            // make sure all the attributes are supported and writable
   4305            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000020   4B43         MOV.B   #0x0, R11
   \   000022   0C3C         JMP     ??zclProcessInWriteUndividedCmd_9
   4306            {
   4307              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4308          
   4309              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4310                                    statusRec->attrID, &attrRec ) )
   4311              {
   4312                // Attribute is not supported - stop here
   4313                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4314                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4315                break;
   4316              }
   4317          
   4318              if ( statusRec->dataType != attrRec.attr.dataType )
   4319              {
   4320                // Attribute data type is incorrect - stope here
   4321                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4322                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4323                break;
   4324              }
   4325          
   4326              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   4327              {
   4328                // Attribute is not writable - stop here
   4329                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   4330                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4331                break;
   4332              }
   4333          
   4334              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   4335              {
   4336                // Not authorized to write - stop here
   4337                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   4338                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4339                break;
   4340              }
   4341          
   4342              // Attribute Data length
   4343              if ( attrRec.attr.dataPtr != NULL )
   4344              {
   4345                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   4346              }
   4347              else // Use CB
   4348              {
   4349                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4350                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   000024   2F48         MOV.W   @R8, R15
   \   000026   2E46         MOV.W   @R6, R14
   \   000028   1D4F0400     MOV.W   0x4(R15), R13
   \   00002C   5C4F1400     MOV.B   0x14(R15), R12
   \   000030   ........     CALLA   #zclGetAttrDataLengthUsingCB
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000034   814C0000     MOV.W   R12, 0(SP)
   4351              }
   4352          
   4353              // add padding if needed
   4354              if ( PADDING_NEEDED( dataLen ) )
   \   000038   ........     CALLA   #?Subroutine7
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   00003C   6B95         CMP.B   @R5, R11
   \   00003E   172C         JC      ??zclProcessInWriteUndividedCmd_0
   \   000040   0F4B         MOV.W   R11, R15
   \   000042                RPT     #0x5
   \   000042   44180F5B     ADDX.W  R11, R15
   \   000046   0645         MOV.W   R5, R6
   \   000048   065F         ADD.W   R15, R6
   \   00004A   2653         ADD.W   #0x2, R6
   \   00004C   2448         MOV.W   @R8, R4
   \   00004E   0F41         MOV.W   SP, R15
   \   000050   2F52         ADD.W   #0x4, R15
   \   000052   2E46         MOV.W   @R6, R14
   \   000054   1D440400     MOV.W   0x4(R4), R13
   \   000058   5C441400     MOV.B   0x14(R4), R12
   \   00005C   ........     CALLA   #??Subroutine9_0
   \                     ??CrossCallReturnLabel_41:
   \   000060   1720         JNE     ??zclProcessInWriteUndividedCmd_10
   \   000062   F94086000200 MOV.B   #0x86, 0x2(R9)
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   000068   A9460400     MOV.W   @R6, 0x4(R9)
   \   00006C   5A43         MOV.B   #0x1, R10
   4355              {
   4356                dataLen++;
   4357              }
   4358          
   4359              curLen += dataLen;
   4360            } // for loop
   4361          
   4362            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   00006E   C94A0000     MOV.B   R10, 0(R9)
   4363            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   000072   4A93         CMP.B   #0x0, R10
   \   000074   9020         JNE     ??zclProcessInWriteUndividedCmd_11
   4364            {
   4365              uint8 *curDataPtr;
   4366              zclWriteRec_t *curWriteRec;
   4367          
   4368              // calculate the length of the current data header
   4369              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   000076   4B4A         MOV.B   R10, R11
   \   000078                RPT     #0x5
   \   000078   44184B5A     ADDX.B  R10, R11
   4370          
   4371              // Allocate space to keep a copy of the current data
   4372              curWriteRec = (zclWriteRec_t *) zcl_mem_alloc( hdrLen + curLen );
   \   00007C   4C4B         MOV.B   R11, R12
   \   00007E   0C57         ADD.W   R7, R12
   \   000080   ........     CALLA   #?Subroutine6
   4373              if ( curWriteRec == NULL )
   \                     ??CrossCallReturnLabel_0:
   \   000084   2420         JNE     ??zclProcessInWriteUndividedCmd_12
   4374              {
   4375                zcl_mem_free(writeRspCmd );
   \   000086   0C49         MOV.W   R9, R12
   \   000088   ........     CALLA   #osal_mem_free
   4376                return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   00008C   4C43         MOV.B   #0x0, R12
   \   00008E   953C         JMP     ??zclProcessInWriteUndividedCmd_13
   4377              }
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   000090   5C410800     MOV.B   0x8(SP), R12
   \   000094   C69C0200     CMP.B   R12, 0x2(R6)
   \   000098   0424         JEQ     ??zclProcessInWriteUndividedCmd_14
   \   00009A   F9408D000200 MOV.B   #0x8d, 0x2(R9)
   \   0000A0   E33F         JMP     ??zclProcessInWriteUndividedCmd_4
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   0000A2   E1B30900     BIT.B   #0x2, 0x9(SP)
   \   0000A6   042C         JC      ??zclProcessInWriteUndividedCmd_15
   \   0000A8   F94088000200 MOV.B   #0x88, 0x2(R9)
   \   0000AE   DC3F         JMP     ??zclProcessInWriteUndividedCmd_4
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0000B0   F1B020000900 BIT.B   #0x20, 0x9(SP)
   \   0000B6   0428         JNC     ??zclProcessInWriteUndividedCmd_16
   \   0000B8   F9407E000200 MOV.B   #0x7e, 0x2(R9)
   \   0000BE   D43F         JMP     ??zclProcessInWriteUndividedCmd_4
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   0000C0   1D410A00     MOV.W   0xa(SP), R13
   \   0000C4   0D93         CMP.W   #0x0, R13
   \   0000C6   AE27         JEQ     ??zclProcessInWriteUndividedCmd_1
   \   0000C8   ........     CALLA   #zclGetAttrDataLength
   \   0000CC   B33F         JMP     ??zclProcessInWriteUndividedCmd_17
   4378          
   4379              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   0000CE   4B4B         MOV.B   R11, R11
   \   0000D0   074C         MOV.W   R12, R7
   \   0000D2   075B         ADD.W   R11, R7
   4380          
   4381              // Write the new data over
   4382              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   0000D4   4B43         MOV.B   #0x0, R11
   \   0000D6   023C         JMP     ??zclProcessInWriteUndividedCmd_18
   4383              {
   4384                uint8 status;
   4385                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4386                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   4387          
   4388                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4389                                      statusRec->attrID, &attrRec ) )
   4390                {
   4391                  break; // should never happen
   4392                }
   4393          
   4394                // Keep a copy of the current data before before writing the new data over
   4395                curStatusRec->attrID = statusRec->attrID;
   4396                curStatusRec->attrData = curDataPtr;
   4397          
   4398                if ( attrRec.attr.dataPtr != NULL )
   4399                {
   4400                  // Read the current value
   4401                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   4402          
   4403                  // Write the new attribute value
   4404                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4405                                             &attrRec, statusRec );
   4406                }
   4407                else // Use CBs
   4408                {
   4409                  // Read the current value
   4410                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4411                                          statusRec->attrID, curDataPtr, &dataLen );
   4412                  // Write the new attribute value
   4413                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4414                                                    &attrRec, statusRec->attrData );
   4415                }
   4416          
   4417                // If successful, a write attribute status record shall NOT be generated
   4418                if ( status != ZCL_STATUS_SUCCESS )
   4419                {
   4420                  writeRspCmd->attrList[j].status = status;
   4421                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4422          
   4423                  // Since this write failed, we need to revert all the pervious writes
   4424                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   4425                  break;
   4426                }
   4427          
   4428                // add padding if needed
   4429                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   0000D8   ........     CALLA   #?Subroutine7
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   0000DC   6B95         CMP.B   @R5, R11
   \   0000DE   502C         JC      ??zclProcessInWriteUndividedCmd_19
   \   0000E0   0F4B         MOV.W   R11, R15
   \   0000E2                RPT     #0x5
   \   0000E2   44180F5B     ADDX.W  R11, R15
   \   0000E6   0445         MOV.W   R5, R4
   \   0000E8   045F         ADD.W   R15, R4
   \   0000EA   2453         ADD.W   #0x2, R4
   \   0000EC   0E46         MOV.W   R6, R14
   \   0000EE   0E5F         ADD.W   R15, R14
   \   0000F0   814E0200     MOV.W   R14, 0x2(SP)
   \   0000F4   2C48         MOV.W   @R8, R12
   \   0000F6   0F41         MOV.W   SP, R15
   \   0000F8   2F52         ADD.W   #0x4, R15
   \   0000FA   ........     CALLA   #?Subroutine9
   \                     ??CrossCallReturnLabel_38:
   \   0000FE   4024         JEQ     ??zclProcessInWriteUndividedCmd_19
   \   000100   1F410200     MOV.W   0x2(SP), R15
   \   000104   AF440000     MOV.W   @R4, 0(R15)
   \   000108   1F410200     MOV.W   0x2(SP), R15
   \   00010C   8F470400     MOV.W   R7, 0x4(R15)
   \   000110   81930A00     CMP.W   #0x0, 0xa(SP)
   \   000114   0E24         JEQ     ??zclProcessInWriteUndividedCmd_20
   \   000116   0E41         MOV.W   SP, R14
   \   000118   0E53         ADD.W   #0x0, R14
   \   00011A   0D41         MOV.W   SP, R13
   \   00011C   2D52         ADD.W   #0x4, R13
   \   00011E   0C47         MOV.W   R7, R12
   \   000120   ........     CALLA   #zclReadAttrData
   \   000124   2C48         MOV.W   @R8, R12
   \   000126   0F44         MOV.W   R4, R15
   \   000128   ........     CALLA   #?Subroutine22
   \                     ??CrossCallReturnLabel_24:
   \   00012C   ........     CALLA   #zclWriteAttrData
   \   000130   173C         JMP     ??zclProcessInWriteUndividedCmd_21
   \                     ??zclProcessInWriteUndividedCmd_20:
   \   000132   2C48         MOV.W   @R8, R12
   \   000134   0F41         MOV.W   SP, R15
   \   000136   0F53         ADD.W   #0x0, R15
   \   000138   0F12         PUSH.W  R15
   \   00013A   0F47         MOV.W   R7, R15
   \   00013C   2E44         MOV.W   @R4, R14
   \   00013E   1D4C0400     MOV.W   0x4(R12), R13
   \   000142   5C4C1400     MOV.B   0x14(R12), R12
   \   000146   ........     CALLA   #zclReadAttrDataUsingCB
   \   00014A   2C48         MOV.W   @R8, R12
   \   00014C   1F440400     MOV.W   0x4(R4), R15
   \   000150   0E41         MOV.W   SP, R14
   \   000152   3E500600     ADD.W   #0x6, R14
   \   000156   ........     CALLA   #??Subroutine24_0
   \                     ??CrossCallReturnLabel_23:
   \   00015A   ........     CALLA   #zclWriteAttrDataUsingCB
   \   00015E   2153         ADD.W   #0x2, SP
   \                     ??zclProcessInWriteUndividedCmd_21:
   \   000160   4C93         CMP.B   #0x0, R12
   \   000162   BA27         JEQ     ??zclProcessInWriteUndividedCmd_3
   \   000164   474A         MOV.B   R10, R7
   \   000166   5706         RLAM.W  #0x2, R7
   \   000168   0F49         MOV.W   R9, R15
   \   00016A   0F57         ADD.W   R7, R15
   \   00016C   CF4C0200     MOV.B   R12, 0x2(R15)
   \   000170   AF440400     MOV.W   @R4, 0x4(R15)
   \   000174   5A53         ADD.B   #0x1, R10
   \   000176   4E4B         MOV.B   R11, R14
   \   000178   0D46         MOV.W   R6, R13
   \   00017A   0C48         MOV.W   R8, R12
   \   00017C   ........     CALLA   #zclRevertWriteUndividedCmd
   4430                {
   4431                  dataLen++;
   4432                }
   4433          
   4434                curDataPtr += dataLen;
   4435              } // for loop
   4436          
   4437              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_19:
   \   000180   C94A0000     MOV.B   R10, 0(R9)
   4438              if ( writeRspCmd->numAttr  == 0 )
   \   000184   4A93         CMP.B   #0x0, R10
   \   000186   0420         JNE     ??zclProcessInWriteUndividedCmd_22
   4439              {
   4440                // Since all records were written successful, include a single status record
   4441                // in the resonse command with the status field set to SUCCESS and the
   4442                // attribute ID field omitted.
   4443                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000188   C9430200     MOV.B   #0x0, 0x2(R9)
   4444                writeRspCmd->numAttr = 1;
   \   00018C   D9430000     MOV.B   #0x1, 0(R9)
   4445              }
   4446          
   4447              zcl_mem_free( curWriteRec );
   \                     ??zclProcessInWriteUndividedCmd_22:
   \   000190   0C46         MOV.W   R6, R12
   \   000192   ........     CALLA   #osal_mem_free
   4448            }
   4449          
   4450            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4451                              pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4452                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000196   2B48         MOV.W   @R8, R11
   \   000198   58120600     PUSH.B  0x6(R8)
   \   00019C   5312         PUSH.B  #0x1
   \   00019E   ........     CALLA   #?Subroutine15
   \                     ??CrossCallReturnLabel_21:
   \   0001A2   4E12         PUSH.B  R14
   \   0001A4   0F49         MOV.W   R9, R15
   \   0001A6   ........     CALLA   #?Subroutine16
   \                     ??CrossCallReturnLabel_8:
   \   0001AA   ........     CALLA   #zcl_SendWriteRsp
   4453            zcl_mem_free( writeRspCmd );
   \   0001AE   0C49         MOV.W   R9, R12
   \   0001B0   ........     CALLA   #osal_mem_free
   4454          
   4455            return TRUE;
   \   0001B4   5C43         MOV.B   #0x1, R12
   \   0001B6   31500600     ADD.W   #0x6, SP
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   0001BA   31500C00     ADD.W   #0xc, SP
   \   0001BE   7417         POPM.W  #0x8, R11
   \   0001C0   1001         RETA
   4456          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine7:
   \   000000   91B30400     BIT.W   #0x1, 0x4(SP)
   \   000004   0528         JNC     ??zclProcessInWriteUndividedCmd_7
   \   000006   1F410400     MOV.W   0x4(SP), R15
   \   00000A   1F53         ADD.W   #0x1, R15
   \   00000C   814F0400     MOV.W   R15, 0x4(SP)
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   000010   17510400     ADD.W   0x4(SP), R7
   \   000014   5B53         ADD.B   #0x1, R11
   \   000016   1001         RETA

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DC8 255
   4457          #endif // ZCL_WRITE
   4458          
   4459          #ifdef ZCL_DISCOVER
   4460          /*********************************************************************
   4461           * @fn      zclProcessInDiscAttrs
   4462           *
   4463           * @brief   Process the "Profile" Discover Attributes Commands
   4464           *
   4465           * @param   pInMsg - incoming message to process
   4466           *
   4467           * @return  TRUE if command processed. FALSE, otherwise.
   4468           */
   4469          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   4470          {
   4471            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4472            zclAttrRec_t attrRec;
   4473            uint16 attrID;
   4474            uint8 numAttrs;
   4475            uint8 i;
   4476          
   4477            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   4478          
   4479            // Find out the number of attributes supported within the specified range
   4480            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   4481            {
   4482              // finds the next attribute on this endpoint/cluster after the range.
   4483              // attributes must be in numerical order in the list.
   4484              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4485              {
   4486                break;
   4487              }
   4488            }
   4489          
   4490            numAttrs = i;  // store range of attributes in buffer
   4491          
   4492              // Process message for either attributes or extended attributes
   4493            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   4494            {
   4495              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   4496            }
   4497            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   4498            {
   4499              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   4500            }
   4501          
   4502            return TRUE;
   4503          }
   4504          
   4505          /*********************************************************************
   4506           * @fn      zclProcessInDiscAttrsCmd
   4507           *
   4508           * @brief   Process the Discover Attributes Command
   4509           *
   4510           * @param   pInMsg - incoming message to process
   4511           *
   4512           * @param   pDiscoverCmd - structure from requesting command
   4513           *
   4514           * @param   attrLenBuf - describes the amount of attributes to be processed
   4515           *
   4516           * @return  none
   4517           */
   4518          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4519          {
   4520            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   4521            uint8 discComplete = TRUE;
   4522            zclAttrRec_t attrRec;
   4523            uint16 attrID;
   4524            uint8 i;
   4525          
   4526            // Allocate space for the response command
   4527            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   4528                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   4529            if ( pDiscoverRsp == NULL )
   4530            {
   4531              return; // EMEDDED RETURN
   4532            }
   4533          
   4534            if ( numAttrs != 0 )
   4535            {
   4536              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4537              {
   4538                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4539                {
   4540                  break; // should not happen, as numAttrs already calculated
   4541                }
   4542          
   4543                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   4544                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   4545              }
   4546          
   4547              // Are there more attributes to be discovered?
   4548              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4549              {
   4550                discComplete = FALSE;
   4551              }
   4552            }
   4553          
   4554            pDiscoverRsp->discComplete = discComplete;
   4555            pDiscoverRsp->numAttr = numAttrs;
   4556          
   4557            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4558                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   4559                                         true, pInMsg->hdr.transSeqNum );
   4560            zcl_mem_free( pDiscoverRsp );
   4561          
   4562            return;
   4563          }
   4564          
   4565          /*********************************************************************
   4566           * @fn      zclProcessInDiscAttrsExtCmd
   4567           *
   4568           * @brief   Process the Discover Attributes Extended Command
   4569           *
   4570           * @param   pInMsg - incoming message to process
   4571           *
   4572           * @param   pDiscoverCmd - structure from requesting command
   4573           *
   4574           * @param   attrLenBuf - describes the amount of attributes to be processed
   4575           *
   4576           * @return  none
   4577           */
   4578          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4579          {
   4580            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   4581            uint8 discComplete = TRUE;
   4582            zclAttrRec_t attrRec;
   4583            uint16 attrID;
   4584            uint8 i;
   4585          
   4586              // Allocate space for the response command
   4587            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   4588                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   4589            if ( pDiscoverExtRsp == NULL )
   4590            {
   4591              return; // EMEDDED RETURN
   4592            }
   4593          
   4594          
   4595            if ( numAttrs != 0 )
   4596            {
   4597              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4598              {
   4599                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4600                {
   4601                  break; // Should not happen, as numAttrs already calculated
   4602                }
   4603          
   4604                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   4605                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   4606                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   4607              }
   4608          
   4609              // Are there more attributes to be discovered?
   4610              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4611              {
   4612                discComplete = FALSE;
   4613              }
   4614            }
   4615          
   4616            pDiscoverExtRsp->discComplete = discComplete;
   4617            pDiscoverExtRsp->numAttr = numAttrs;
   4618          
   4619            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4620                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   4621                                         true, pInMsg->hdr.transSeqNum );
   4622          
   4623            zcl_mem_free( pDiscoverExtRsp );
   4624          
   4625            return;
   4626          }
   4627          
   4628          /*********************************************************************
   4629           * @fn      zclProcessInDiscCmd
   4630           *
   4631           * @brief   Process the "Profile" Discover Command
   4632           *
   4633           * @param   pInMsg - incoming message to process
   4634           *
   4635           * @return  TRUE if command processed. FALSE, otherwise.
   4636           */
   4637          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   4638          {
   4639            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4640            zclDiscoverCmdsCmdRsp_t cmdRsp;
   4641            ZStatus_t status;
   4642            zclCommandRec_t cmdRec;
   4643            uint8 cmdID;
   4644            uint8 i;
   4645            uint8 j;
   4646          
   4647            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   4648          
   4649            // Find out the number of commands supported within the specified range
   4650            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   4651            {
   4652              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4653              {
   4654                break;  // Command not supported
   4655              }
   4656            }
   4657          
   4658            // Allocate space for the response command
   4659            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   4660          
   4661            if ( cmdRsp.pCmdID == NULL )
   4662            {
   4663              return FALSE; // EMEDDED RETURN
   4664            }
   4665          
   4666            if ( i != 0 )
   4667            {
   4668              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   4669              {
   4670                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4671                {
   4672                  break; // Attribute not supported
   4673                }
   4674          
   4675                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   4676              }
   4677            }
   4678          
   4679            // Are there more commands to be discovered?
   4680            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4681            {
   4682              cmdRsp.discComplete = FALSE;
   4683            }
   4684            else
   4685            {
   4686              cmdRsp.discComplete = TRUE;
   4687            }
   4688          
   4689            // pass the command requested
   4690            cmdRsp.cmdType = pInMsg->hdr.commandID;
   4691          
   4692            // store number of commands returned
   4693            cmdRsp.numCmd = j;
   4694          
   4695            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4696                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   4697                                                true, pInMsg->hdr.transSeqNum );
   4698          
   4699            zcl_mem_free( cmdRsp.pCmdID );
   4700          
   4701            if ( status == ZSuccess )
   4702            {
   4703              return TRUE;
   4704            }
   4705            else
   4706            {
   4707              return FALSE;
   4708            }
   4709          }
   4710          
   4711          #endif // ZCL_DISCOVER
   4712          
   4713          /*********************************************************************
   4714          *********************************************************************/

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     12   zclAuthorizeWrite
       12   -- Indirect call
       12   -> zclGetAuthorizeCB
      4   zclBuildHdr
     12   zclFindAttrRec
       12   -> zclFindAttrRecsList
      4   zclFindAttrRecsList
      8   zclFindClusterOption
      4   zclGetAttrDataLength
        4   -> zclGetDataTypeLength
     16   zclGetAttrDataLengthUsingCB
       16   -- Indirect call
       14   -> zclGetReadWriteCB
      4   zclGetAuthorizeCB
        4   -> zclFindAttrRecsList
      4   zclGetClusterOption
        4   -> zclFindClusterOption
      4   zclGetDataTypeLength
      4   zclGetReadWriteCB
        4   -> zclFindAttrRecsList
      8   zclParseHdr
        8   -> osal_memset
      6   zclParseInDefaultRspCmd
        6   -> osal_mem_alloc
      8   zclParseInReadCmd
        8   -> osal_mem_alloc
     20   zclParseInReadRspCmd
       20   -> osal_mem_alloc
       20   -> osal_memcpy
       20   -> zclGetAttrDataLength
     20   zclParseInWriteCmd
       20   -> osal_mem_alloc
       20   -> osal_memcpy
       20   -> zclGetAttrDataLength
     12   zclParseInWriteRspCmd
       12   -> osal_mem_alloc
     34   zclProcessInReadCmd
       28   -- Indirect call
       28   -> osal_mem_alloc
       34   -> osal_mem_free
       28   -> zclFindAttrRec
       28   -> zclGetAuthorizeCB
       34   -> zcl_SendReadRsp
     34   zclProcessInWriteCmd
       28   -> osal_mem_alloc
       34   -> osal_mem_free
       28   -> zclFindAttrRec
       28   -> zclWriteAttrData
       28   -> zclWriteAttrDataUsingCB
       34   -> zcl_SendWriteRsp
     38   zclProcessInWriteUndividedCmd
       32   -> osal_mem_alloc
       32   -> osal_mem_free
       38   -> osal_mem_free
       32   -> zclFindAttrRec
       32   -> zclGetAttrDataLength
       32   -> zclGetAttrDataLengthUsingCB
       32   -> zclReadAttrData
       34   -> zclReadAttrDataUsingCB
       32   -> zclRevertWriteUndividedCmd
       32   -> zclWriteAttrData
       34   -> zclWriteAttrDataUsingCB
       38   -> zcl_SendWriteRsp
     12   zclReadAttrData
       12   -> osal_memcpy
       12   -> zclGetAttrDataLength
     18   zclReadAttrDataUsingCB
       18   -- Indirect call
       16   -> zclGetReadWriteCB
     24   zclRevertWriteUndividedCmd
       24   -> osal_memcpy
       24   -> zclFindAttrRec
       24   -> zclGetAttrDataLength
       24   -> zclWriteAttrDataUsingCB
      4   zclSerializeData
        4   -> osal_buffer_uint32
        4   -> osal_memcpy
      6   zclSetSecurityOption
        6   -> zclFindClusterOption
     12   zclWriteAttrData
       12   -- Indirect call
       12   -> osal_memcpy
       12   -> zclAuthorizeWrite
       12   -> zclGetAttrDataLength
     14   zclWriteAttrDataUsingCB
       14   -- Indirect call
       12   -> zclAuthorizeWrite
       12   -> zclGetReadWriteCB
     14   zcl_DeviceOperational
       14   -> zclFindAttrRec
       14   -> zclReadAttrData
      8   zcl_HandleExternal
        8   -> osal_msg_allocate
        8   -> osal_msg_send
      4   zcl_Init
     42   zcl_ProcessMessageMSG
       34   -- Indirect call
       34   -> afFindEndPointDesc
       34   -> osal_mem_free
       34   -> zclGetClusterOption
       34   -> zclParseHdr
       34   -> zclSetSecurityOption
       42   -> zclSetSecurityOption
       36   -> zcl_DeviceOperational
       42   -> zcl_SendDefaultRspCmd
     22   zcl_ReadAttrData
       20   -> zclFindAttrRec
       20   -> zclReadAttrData
       22   -> zclReadAttrDataUsingCB
     34   zcl_SendCommand
       34   -> AF_DataRequest
       26   -> afFindEndPointDesc
       26   -> osal_mem_alloc
       34   -> osal_mem_free
       26   -> osal_memcpy
       26   -> osal_memset
       26   -> zclBuildHdr
       26   -> zclGetClusterOption
       28   -> zcl_DeviceOperational
     20   zcl_SendDefaultRspCmd
       20   -> zcl_SendCommand
     30   zcl_SendRead
       16   -> osal_mem_alloc
       30   -> osal_mem_free
       30   -> zcl_SendCommand
     36   zcl_SendReadRsp
       22   -> osal_mem_alloc
       36   -> osal_mem_free
       22   -> zclGetAttrDataLength
       22   -> zclGetAttrDataLengthUsingCB
       24   -> zclReadAttrDataUsingCB
       22   -> zclSerializeData
       36   -> zcl_SendCommand
     34   zcl_SendWriteRequest
       20   -> osal_mem_alloc
       34   -> osal_mem_free
       20   -> zclGetAttrDataLength
       20   -> zclSerializeData
       34   -> zcl_SendCommand
     30   zcl_SendWriteRsp
       16   -> osal_mem_alloc
       30   -> osal_mem_free
       30   -> zcl_SendCommand
      8   zcl_event_loop
        8   -> osal_msg_deallocate
        8   -> osal_msg_receive
        8   -> osal_msg_send
        8   -> zcl_ProcessMessageMSG
      4   zcl_getRawAFMsg
     12   zcl_registerAttrList
       12   -> osal_mem_alloc
     12   zcl_registerClusterOptionList
       12   -> osal_mem_alloc
      4   zcl_registerForMsg
     12   zcl_registerPlugin
       12   -> osal_mem_alloc
      8   zcl_registerReadWriteCB
        8   -> zclFindAttrRecsList
      4   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_RegisteredMsgTaskID>
      10  ??Subroutine15_0
      12  ??Subroutine18_0
      12  ??Subroutine24_0
       6  ??Subroutine26_0
       8  ??Subroutine28_0
      10  ??Subroutine4_0
       8  ??Subroutine5_0
       8  ??Subroutine9_0
       6  ?Subroutine0
       6  ?Subroutine1
      32  ?Subroutine10
      22  ?Subroutine11
       6  ?Subroutine12
      36  ?Subroutine13
       2  ?Subroutine14
       4  ?Subroutine15
      16  ?Subroutine16
      10  ?Subroutine17
       4  ?Subroutine18
      18  ?Subroutine19
       6  ?Subroutine2
       6  ?Subroutine20
      16  ?Subroutine21
       4  ?Subroutine22
       6  ?Subroutine3
      10  ?Subroutine4
       6  ?Subroutine5
      10  ?Subroutine6
      24  ?Subroutine7
      18  ?Subroutine8
       2  ?Subroutine9
       2  attrList
       2  clusterOptionList
       2  plugins
       2  rawAFMsg
      38  zclAuthorizeWrite
      80  zclBuildHdr
     184  zclCmdTable
      76  zclFindAttrRec
      26  zclFindAttrRecsList
      58  zclFindClusterOption
      54  zclGetAttrDataLength
      50  zclGetAttrDataLengthUsingCB
      20  zclGetAuthorizeCB
      22  zclGetClusterOption
     216  zclGetDataTypeLength
      24  zclGetReadWriteCB
     142  zclParseHdr
      26  zclParseInDefaultRspCmd
      64  zclParseInReadCmd
      86  zclParseInReadRspCmd
      66  zclParseInWriteCmd
      82  zclParseInWriteRspCmd
     224  zclProcessInReadCmd
     230  zclProcessInWriteCmd
     450  zclProcessInWriteUndividedCmd
      56  zclReadAttrData
      62  zclReadAttrDataUsingCB
     106  zclRevertWriteUndividedCmd
     260  zclSerializeData
      34  zclSetSecurityOption
      90  zclWriteAttrData
      68  zclWriteAttrDataUsingCB
      72  zcl_DeviceOperational
      98  zcl_HandleExternal
       6  zcl_Init
     624  zcl_ProcessMessageMSG
      70  zcl_ReadAttrData
       1  zcl_RegisteredMsgTaskID
     294  zcl_SendCommand
      52  zcl_SendDefaultRspCmd
      94  zcl_SendRead
     244  zcl_SendReadRsp
     180  zcl_SendWriteRequest
     124  zcl_SendWriteRsp
       1  zcl_SeqNum
       1  zcl_TaskID
       1  zcl_TransID
       4  zcl_ValidateAttrDataCB
      70  zcl_event_loop
       6  zcl_getRawAFMsg
      80  zcl_registerAttrList
      72  zcl_registerClusterOptionList
      18  zcl_registerForMsg
      78  zcl_registerPlugin
      42  zcl_registerReadWriteCB
      12  zcl_registerValidateAttrData

 
 5 290 bytes in segment CODE
   184 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
    15 bytes in segment DATA16_Z
 
 5 290 bytes of CODE  memory
   185 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none
