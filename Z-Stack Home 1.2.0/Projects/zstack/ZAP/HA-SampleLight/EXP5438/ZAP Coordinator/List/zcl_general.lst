###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.60.5.50814/W32 for MSP430       08/Apr/2014  21:14:23 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\Z-Stack Home                       #
#                     1.2.0\Components\stack\zcl\zcl_general.c                #
#    Command line  =  -f "C:\Texas Instruments\Z-Stack Home                   #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     Source\zap.cfg" (-DZAP_PHY_SPI=1                        #
#                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE    #
#                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                  #
#                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE               #
#                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE            #
#                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4) -f   #
#                     "C:\Texas Instruments\Z-Stack Home                      #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\Tools\MSP5438\f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE    #
#                     -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF                 #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU                 #
#                     -DZCL_DEVICE_MGMT) "C:\Texas Instruments\Z-Stack Home   #
#                     1.2.0\Components\stack\zcl\zcl_general.c" -D            #
#                     FEATURE_GREEN_POWER -D FEATURE_ENHANCED_BEACON -D       #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -lC "C:\Texas  #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\ZAP Coordinator\List\" -lA           #
#                     "C:\Texas Instruments\Z-Stack Home                      #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP    #
#                     Coordinator\List\" --remarks --diag_suppress            #
#                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                    #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\ZAP Coordinator\Obj\" --debug        #
#                     -D__MSP430F5438__ -e --double=32 --clib -I "C:\Texas    #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\" -I "C:\Texas Instruments\Z-Stack   #
#                     Home 1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\. #
#                     .\Source\" -I "C:\Texas Instruments\Z-Stack Home        #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     Source\" -I "C:\Texas Instruments\Z-Stack Home          #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\hal\target\MSP5438ZAP\" -I          #
#                     "C:\Texas Instruments\Z-Stack Home                      #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\hal\include\" -I "C:\Texas          #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\mac\includ #
#                     e\" -I "C:\Texas Instruments\Z-Stack Home               #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\mt\" -I "C:\Texas                   #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\osal\inclu #
#                     de\" -I "C:\Texas Instruments\Z-Stack Home              #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\osal\mcu\msp430\" -I "C:\Texas      #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\services\s #
#                     addr\" -I "C:\Texas Instruments\Z-Stack Home            #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\services\sdata\" -I "C:\Texas       #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\stack\af\" #
#                      -I "C:\Texas Instruments\Z-Stack Home                  #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\stack\nwk\" -I "C:\Texas            #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\stack\sapi #
#                     \" -I "C:\Texas Instruments\Z-Stack Home                #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\stack\sec\" -I "C:\Texas            #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\stack\sys\ #
#                     " -I "C:\Texas Instruments\Z-Stack Home                 #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\stack\zcl\" -I "C:\Texas            #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\stack\zdo\ #
#                     " -I "C:\Texas Instruments\Z-Stack Home                 #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\..\ #
#                     ..\..\..\Components\zmac\" -I "C:\Texas                 #
#                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA-S #
#                     ampleLight\EXP5438\..\..\..\..\..\Components\zmac\f8w\" #
#                      --core=430X --data_model=small -Ohz --multiplier=32    #
#                     --multiplier_location=4C0 --require_prototypes          #
#                     --hw_workaround=CPU40 --hw_workaround=CPU39             #
#    List file     =  C:\Texas Instruments\Z-Stack Home                       #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP    #
#                     Coordinator\List\zcl_general.lst                        #
#    Object file   =  C:\Texas Instruments\Z-Stack Home                       #
#                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP    #
#                     Coordinator\Obj\zcl_general.r43                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\Z-Stack Home 1.2.0\Components\stack\zcl\zcl_general.c
      1          /**************************************************************************************************
      2            Filename:       zcl_general.c
      3            Revised:        $Date: 2013-10-16 16:08:27 -0700 (Wed, 16 Oct 2013) $
      4            Revision:       $Revision: 35699 $
      5          
      6            Description:    Zigbee Cluster Library - General.  This application receives all
      7                            ZCL messages and initially parses them before passing to application.
      8          
      9          
     10            Copyright 2006-2013 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          #include "ZComDef.h"
     45          #include "zcl.h"
     46          #include "zcl_general.h"
     47          //#include "ZDApp.h"
     48          #include "zcl_ezmode.h"
     49          
     50          #if defined ( INTER_PAN )
     51            #include "stub_aps.h"
     52          #endif
     53          
     54          /*********************************************************************
     55           * MACROS
     56           */
     57          #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
     58          #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
     59          #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
     60          
     61          #ifdef ZCL_SCENES
     62          #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
     63          #endif // ZCL_SCENES
     64          
     65          /*********************************************************************
     66           * CONSTANTS
     67           */
     68          
     69          /*********************************************************************
     70           * TYPEDEFS
     71           */
     72          typedef struct zclGenCBRec
     73          {
     74            struct zclGenCBRec        *next;
     75            uint8                     endpoint; // Used to link it into the endpoint descriptor
     76            zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
     77          } zclGenCBRec_t;
     78          
     79          typedef struct zclGenSceneItem
     80          {
     81            struct zclGenSceneItem    *next;
     82            uint8                     endpoint; // Used to link it into the endpoint descriptor
     83            zclGeneral_Scene_t        scene;    // Scene info
     84          } zclGenSceneItem_t;
     85          
     86          typedef struct zclGenAlarmItem
     87          {
     88            struct zclGenAlarmItem    *next;
     89            uint8                     endpoint; // Used to link it into the endpoint descriptor
     90            zclGeneral_Alarm_t        alarm;    // Alarm info
     91          } zclGenAlarmItem_t;
     92          
     93          // Scene NV types
     94          typedef struct
     95          {
     96            uint16                    numRecs;
     97          } nvGenScenesHdr_t;
     98          
     99          typedef struct zclGenSceneNVItem
    100          {
    101            uint8                     endpoint;
    102            zclGeneral_Scene_t        scene;
    103          } zclGenSceneNVItem_t;
    104          
    105          /*********************************************************************
    106           * GLOBAL VARIABLES
    107           */
    108          
    109          /*********************************************************************
    110           * GLOBAL FUNCTIONS
    111           */
    112          
    113          /*********************************************************************
    114           * LOCAL VARIABLES
    115           */

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    116          static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
   \                     zclGenCBs:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    117          static uint8 zclGenPluginRegisted = FALSE;
   \                     zclGenPluginRegisted:
   \   000000                DS8 1
    118          
    119          #if defined( ZCL_SCENES )
    120            #if !defined ( ZCL_STANDALONE )
    121              static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
    122            #endif
    123          #endif // ZCL_SCENES
    124          
    125          #ifdef ZCL_ALARMS
    126          static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
    127          #endif // ZCL_ALARMS
    128          
    129          /*********************************************************************
    130           * LOCAL FUNCTIONS
    131           */
    132          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
    133          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    134          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
    135          
    136          // Device Configuration and Installation clusters
    137          #ifdef ZCL_BASIC
    138          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    139          #endif // ZCL_BASIC
    140          
    141          #ifdef ZCL_IDENTIFY
    142          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    143          #endif // ZCL_IDENTIFY
    144          
    145          // Groups and Scenes clusters
    146          #ifdef ZCL_GROUPS
    147          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
    148          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    149          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
    150          #endif // ZCL_GROUPS
    151          
    152          #ifdef ZCL_SCENES
    153          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    154          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    155          #endif // ZCL_SCENES
    156          
    157          // On/Off and Level Control Configuration clusters
    158          #ifdef ZCL_ON_OFF
    159          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    160          #endif // ZCL_ONOFF
    161          
    162          #ifdef ZCL_LEVEL_CTRL
    163          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    164          #endif // ZCL_LEVEL_CTRL
    165          
    166          // Alarms cluster
    167          #ifdef ZCL_ALARMS
    168          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    169          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    170          #endif // ZCL_ALARMS
    171          
    172          // Location cluster
    173          #ifdef ZCL_LOCATION
    174          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    175          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    176          #endif // ZCL_LOCATION
    177          
    178          #ifdef ZCL_SCENES
    179            #if !defined ( ZCL_STANDALONE )
    180              static uint8 zclGeneral_ScenesInitNV( void );
    181              static void zclGeneral_ScenesSetDefaultNV( void );
    182              static void zclGeneral_ScenesWriteNV( void );
    183              static uint16 zclGeneral_ScenesRestoreFromNV( void );
    184            #endif
    185          #endif // ZCL_SCENES
    186          
    187          /*********************************************************************
    188           * @fn      zclGeneral_RegisterCmdCallbacks
    189           *
    190           * @brief   Register an applications command callbacks
    191           *
    192           * @param   endpoint - application's endpoint
    193           * @param   callbacks - pointer to the callback record.
    194           *
    195           * @return  ZMemError if not able to allocate
    196           */

   \                                 In  segment CODE, align 2
    197          ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
   \                     zclGeneral_RegisterCmdCallbacks:
    198          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
    199            zclGenCBRec_t *pNewItem;
    200            zclGenCBRec_t *pLoop;
    201          
    202            // Register as a ZCL Plugin
    203            if ( zclGenPluginRegisted == FALSE )
   \   000006   C293....     CMP.B   #0x0, &zclGenPluginRegisted
   \   00000A   0B20         JNE     ??zclGeneral_RegisterCmdCallbacks_3
    204            {
    205              zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
    206                                  ZCL_CLUSTER_ID_GEN_MULTISTATE_VALUE_BASIC,
    207                                  zclGeneral_HdlIncoming );
   \   00000C   3E40....     MOV.W   #LWRD(zclGeneral_HdlIncoming), R14
   \   000010   3F40....     MOV.W   #HWRD(zclGeneral_HdlIncoming), R15
   \   000014   3D401400     MOV.W   #0x14, R13
   \   000018   0C43         MOV.W   #0x0, R12
   \   00001A   ........     CALLA   #zcl_registerPlugin
    208          
    209          #ifdef ZCL_SCENES
    210              // Initialize the Scenes Table
    211              zclGeneral_ScenesInit();
    212          #endif // ZCL_SCENES
    213          
    214              zclGenPluginRegisted = TRUE;
   \   00001E   D243....     MOV.B   #0x1, &zclGenPluginRegisted
    215            }
    216          
    217            // Fill in the new profile list
    218            pNewItem = zcl_mem_alloc( sizeof( zclGenCBRec_t ) );
   \                     ??zclGeneral_RegisterCmdCallbacks_3:
   \   000022   3C400600     MOV.W   #0x6, R12
   \   000026   ........     CALLA   #osal_mem_alloc
    219            if ( pNewItem == NULL )
   \   00002A   0C93         CMP.W   #0x0, R12
   \   00002C   0320         JNE     ??zclGeneral_RegisterCmdCallbacks_4
    220              return (ZMemError);
   \   00002E   7C401000     MOV.B   #0x10, R12
   \   000032   143C         JMP     ??zclGeneral_RegisterCmdCallbacks_5
    221          
    222            pNewItem->next = (zclGenCBRec_t *)NULL;
   \                     ??zclGeneral_RegisterCmdCallbacks_4:
   \   000034   8C430000     MOV.W   #0x0, 0(R12)
    223            pNewItem->endpoint = endpoint;
   \   000038   CC4A0200     MOV.B   R10, 0x2(R12)
    224            pNewItem->CBs = callbacks;
   \   00003C   8C4B0400     MOV.W   R11, 0x4(R12)
    225          
    226            // Find spot in list
    227            if (  zclGenCBs == NULL )
   \   000040   1F42....     MOV.W   &zclGenCBs, R15
   \   000044   0F93         CMP.W   #0x0, R15
   \   000046   0420         JNE     ??zclGeneral_RegisterCmdCallbacks_2
    228            {
    229              zclGenCBs = pNewItem;
   \   000048   824C....     MOV.W   R12, &zclGenCBs
   \   00004C   063C         JMP     ??zclGeneral_RegisterCmdCallbacks_6
    230            }
    231            else
    232            {
    233              // Look for end of list
    234              pLoop = zclGenCBs;
    235              while ( pLoop->next != NULL )
    236                pLoop = pLoop->next;
   \                     ??zclGeneral_RegisterCmdCallbacks_0:
   \   00004E   0F4B         MOV.W   R11, R15
   \                     ??zclGeneral_RegisterCmdCallbacks_2:
   \   000050   2B4F         MOV.W   @R15, R11
   \   000052   0B93         CMP.W   #0x0, R11
   \   000054   FC23         JNE     ??zclGeneral_RegisterCmdCallbacks_0
    237          
    238              // Put new item at end of list
    239              pLoop->next = pNewItem;
   \   000056   8F4C0000     MOV.W   R12, 0(R15)
    240            }
    241          
    242            return ( ZSuccess );
   \                     ??zclGeneral_RegisterCmdCallbacks_6:
   \   00005A   4C43         MOV.B   #0x0, R12
   \                     ??zclGeneral_RegisterCmdCallbacks_5:
   \   00005C   1A17         POPM.W  #0x2, R11
   \   00005E   1001         RETA
    243          }
    244          
    245          #ifdef ZCL_IDENTIFY
    246          /*********************************************************************
    247           * @fn      zclGeneral_SendIdentify
    248           *
    249           * @brief   Call to send out an Identify Command
    250           *
    251           * @param   srcEP - Sending application's endpoint
    252           * @param   dstAddr - where you want the message to go
    253           * @param   identifyTime - how long the device will continue to identify itself (in seconds)
    254           * @param   seqNum - identification number for the transaction
    255           *
    256           * @return  ZStatus_t
    257           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   5312         PUSH.B  #0x1
   \   000002   4F43         MOV.B   #0x0, R15
   \   000004                REQUIRE ??Subroutine2_0
   \   000004                // Fall through to label ??Subroutine2_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine2_0:
   \   000000   3E400300     MOV.W   #0x3, R14
   \   000004                REQUIRE ??Subroutine3_0
   \   000004                // Fall through to label ??Subroutine3_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine3_0:
   \   000000   ........     CALLA   #zcl_SendCommand
   \   000004   31501000     ADD.W   #0x10, SP
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
    258          ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentify:
    259                                             uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
    260          {
   \   000000   2183         SUB.W   #0x2, SP
    261            uint8 buf[2];
    262          
    263            buf[0] = LO_UINT16( identifyTime );
   \   000002   ........     CALLA   #?Subroutine1
    264            buf[1] = HI_UINT16( identifyTime );
    265          
    266            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    267                                    COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    268                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_1:
   \   000006   0E12         PUSH.W  R14
   \   000008   2312         PUSH.W  #0x2
   \   00000A   51120C00     PUSH.B  0xc(SP)
   \   00000E   0312         PUSH.W  #0x0
   \   000010   4F12         PUSH.B  R15
   \   000012   4312         PUSH.B  #0x0
   \   000014   ....         JMP     ?Subroutine0
   \   000016   0343         NOP
    269          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   C14E0400     MOV.B   R14, 0x4(SP)
   \   000004                RPT     #0x8
   \   000004   47190E10     RRUX.W  R14
   \   000008   C14E0500     MOV.B   R14, 0x5(SP)
   \   00000C   0E41         MOV.W   SP, R14
   \   00000E   2E52         ADD.W   #0x4, R14
   \   000010   1001         RETA
    270          
    271          /*********************************************************************
    272           * @fn      zclGeneral_SendIdentifyEZModeInvoke
    273           *
    274           * @brief   Call to send out an Identify EZ-Mode Invoke Command
    275           *
    276           * @param   srcEP - Sending application's endpoint
    277           * @param   dstAddr - where you want the message to go
    278           * @param   action - describes the EZ-Mode action to be performed
    279           * @param   seqNum - identification number for the transaction
    280           *
    281           * @return  ZStatus_t
    282           */

   \                                 In  segment CODE, align 2, keep-with-next
    283          ZStatus_t zclGeneral_SendIdentifyEZModeInvoke( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyEZModeInvoke:
    284                                                         uint8 action, uint8 disableDefaultRsp, uint8 seqNum )
    285          {
   \   000000   2183         SUB.W   #0x2, SP
    286            uint8 buf[1];
    287          
    288            buf[0] = action;
   \   000002   C14E0000     MOV.B   R14, 0(SP)
    289          
    290            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    291                                    COMMAND_IDENTIFY_EZMODE_INVOKE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    292                                    disableDefaultRsp, 0, seqNum, 1, buf );
   \   000006   0E41         MOV.W   SP, R14
   \   000008   0E53         ADD.W   #0x0, R14
   \   00000A   0E12         PUSH.W  R14
   \   00000C   1312         PUSH.W  #0x1
   \   00000E   51120C00     PUSH.B  0xc(SP)
   \   000012   0312         PUSH.W  #0x0
   \   000014   4F12         PUSH.B  R15
   \   000016   4312         PUSH.B  #0x0
   \   000018   5312         PUSH.B  #0x1
   \   00001A   6F43         MOV.B   #0x2, R15
   \   00001C   ....         JMP     ??Subroutine2_0
   \   00001E   0343         NOP
    293          }
    294          
    295          /*********************************************************************
    296           * @fn      zclGeneral_SendIdentifyUpdateCommState
    297           *
    298           * @brief   Call to send out an Identify Update Commission State Command
    299           *
    300           * @param   srcEP - Sending application's endpoint
    301           * @param   dstAddr - where you want the message to go
    302           * @param   action - describes the EZ-Mode action to be performed
    303           * @param   commissionStateMask - updates the device's commission state
    304           * @param   seqNum - identification number for the transaction
    305           *
    306           * @return  ZStatus_t
    307           */

   \                                 In  segment CODE, align 2, keep-with-next
    308          ZStatus_t zclGeneral_SendIdentifyUpdateCommState( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyUpdateCommState:
    309                                                            uint8 action, uint8 commissionStateMask,
    310                                                            uint8 disableDefaultRsp, uint8 seqNum )
    311          {
   \   000000   2183         SUB.W   #0x2, SP
    312            uint8 buf[2];
    313          
    314            buf[0] = action;
   \   000002   C14E0000     MOV.B   R14, 0(SP)
    315            buf[1] = commissionStateMask;
   \   000006   C14F0100     MOV.B   R15, 0x1(SP)
    316          
    317            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    318                                    COMMAND_IDENTIFY_UPDATE_COMMISSION_STATE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    319                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \   00000A   0F41         MOV.W   SP, R15
   \   00000C   0F53         ADD.W   #0x0, R15
   \   00000E   0F12         PUSH.W  R15
   \   000010   2312         PUSH.W  #0x2
   \   000012   51120E00     PUSH.B  0xe(SP)
   \   000016   0312         PUSH.W  #0x0
   \   000018   51121000     PUSH.B  0x10(SP)
   \   00001C   4312         PUSH.B  #0x0
   \   00001E   5312         PUSH.B  #0x1
   \   000020   7F400300     MOV.B   #0x3, R15
   \   000024   0E4F         MOV.W   R15, R14
   \   000026   ....         JMP     ??Subroutine3_0
   \   000028   0343         NOP
    320          }
    321          
    322          #ifdef ZCL_LIGHT_LINK_ENHANCE
    323          /*********************************************************************
    324           * @fn      zclGeneral_SendIdentifyTriggerEffect
    325           *
    326           * @brief   Call to send out a Trigger Effect Command
    327           *
    328           * @param   srcEP - Sending application's endpoint
    329           * @param   dstAddr - where you want the message to go
    330           * @param   effectId - identify effect to use
    331           * @param   effectVariant - which variant of effect to be triggered
    332           * @param   disableDefaultRsp - whether to disable the Default Response command
    333           * @param   seqNum - identification number for the transaction
    334           *
    335           * @return  ZStatus_t
    336           */
    337          ZStatus_t zclGeneral_SendIdentifyTriggerEffect( uint8 srcEP, afAddrType_t *dstAddr,
    338                                                          uint8 effectId, uint8 effectVariant,
    339                                                          uint8 disableDefaultRsp, uint8 seqNum )
    340          {
    341            uint8 buf[2];
    342          
    343            buf[0] = effectId;
    344            buf[1] = effectVariant;
    345          
    346            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    347                                    COMMAND_IDENTIFY_TRIGGER_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    348                                    disableDefaultRsp, 0, seqNum, 2, buf );
    349          }
    350          #endif // ZCL_LIGHT_LINK_ENHANCE
    351          
    352          /*********************************************************************
    353           * @fn      zclGeneral_SendIdentifyQueryResponse
    354           *
    355           * @brief   Call to send out an Identify Query Response Command
    356           *
    357           * @param   srcEP - Sending application's endpoint
    358           * @param   dstAddr - where you want the message to go
    359           * @param   timeout - how long the device will continue to identify itself (in seconds)
    360           * @param   seqNum - identification number for the transaction
    361           *
    362           * @return  ZStatus_t
    363           */

   \                                 In  segment CODE, align 2, keep-with-next
    364          ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyQueryResponse:
    365                                                          uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
    366          {
   \   000000   2183         SUB.W   #0x2, SP
    367            uint8 buf[2];
    368          
    369            buf[0] = LO_UINT16( timeout );
   \   000002   ........     CALLA   #?Subroutine1
    370            buf[1] = HI_UINT16( timeout );
    371          
    372            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    373                                    COMMAND_IDENTIFY_QUERY_RSP, TRUE,
    374                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_0:
   \   000006   0E12         PUSH.W  R14
   \   000008   2312         PUSH.W  #0x2
   \   00000A   51120C00     PUSH.B  0xc(SP)
   \   00000E   0312         PUSH.W  #0x0
   \   000010   4F12         PUSH.B  R15
   \   000012   5312         PUSH.B  #0x1
   \   000014   ....         JMP     ?Subroutine0
   \   000016   0343         NOP
    375          }
    376          #endif // ZCL_IDENTIFY
    377          
    378          #ifdef ZCL_GROUPS
    379          /*********************************************************************
    380           * @fn      zclGeneral_SendGroupRequest
    381           *
    382           * @brief   Send a Group Request to a device.  You can also use the
    383           *          appropriate macro.
    384           *
    385           * @param   srcEP - Sending Apps endpoint
    386           * @param   dstAddr - where to send the request
    387           * @param   cmd - one of the following:
    388           *              COMMAND_GROUP_VIEW
    389           *              COMMAND_GROUP_REMOVE
    390           * @param   groupID -
    391           *
    392           * @return  ZStatus_t
    393           */
    394          ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    395                                                 uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    396          {
    397            uint8 buf[2];
    398          
    399            buf[0] = LO_UINT16( groupID );
    400            buf[1] = HI_UINT16( groupID );
    401          
    402            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    403                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    404                                      disableDefaultRsp, 0, seqNum, 2, buf ) );
    405          }
    406          
    407          /*********************************************************************
    408           * @fn      zclGeneral_SendAddGroupRequest
    409           *
    410           * @brief   Send the Add Group Request to a device
    411           *
    412           * @param   srcEP - Sending Apps endpoint
    413           * @param   dstAddr - where to send the request
    414           * @param   cmd - one of the following:
    415           *                COMMAND_GROUP_ADD
    416           *                COMMAND_GROUP_ADD_IF_IDENTIFYING
    417           * @param   groupID - pointer to the group structure
    418           * @param   groupName - pointer to Group Name.  This is a Zigbee
    419           *          string data type, so the first byte is the length of the
    420           *          name (in bytes), then the name.
    421           *
    422           * @return  ZStatus_t
    423           */
    424          ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    425                                                    uint8 cmd, uint16 groupID, uint8 *groupName,
    426                                                    uint8 disableDefaultRsp, uint8 seqNum )
    427          {
    428            uint8 *buf;
    429            uint8 *pBuf;
    430            uint8 len;
    431            ZStatus_t status;
    432          
    433            len = 2;    // Group ID
    434            len += groupName[0] + 1;  // String + 1 for length
    435          
    436            buf = zcl_mem_alloc( len );
    437            if ( buf )
    438            {
    439              pBuf = buf;
    440              *pBuf++ = LO_UINT16( groupID );
    441              *pBuf++ = HI_UINT16( groupID );
    442              *pBuf++ = groupName[0]; // string length
    443              zcl_memcpy( pBuf, &(groupName[1]), groupName[0] );
    444          
    445              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    446                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    447                                        disableDefaultRsp, 0, seqNum, len, buf );
    448              zcl_mem_free( buf );
    449            }
    450            else
    451              status = ZMemError;
    452          
    453            return ( status );
    454          }
    455          
    456          /*********************************************************************
    457           * @fn      zclGeneral_SendGroupGetMembershipRequest
    458           *
    459           * @brief   Send a Get Group Membership (Resposne) Command to a device
    460           *
    461           * @param   srcEP - Sending Apps endpoint
    462           * @param   dstAddr - where to send the request
    463           * @param   cmd - one of the following:
    464           *                COMMAND_GROUP_GET_MEMBERSHIP
    465           *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
    466           * @param   groupID - pointer to the group structure
    467           * @param   groupName - pointer to Group Name.  This is a Zigbee
    468           *          string data type, so the first byte is the length of the
    469           *          name (in bytes), then the name.
    470           *
    471           * @return  ZStatus_t
    472           */
    473          ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
    474                                                              uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
    475                                                              uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
    476          {
    477            uint8 *buf;
    478            uint8 *pBuf;
    479            uint8 len = 0;
    480            uint8 i;
    481            ZStatus_t status;
    482          
    483            if ( rspCmd )
    484              len++;  // Capacity
    485          
    486            len++;  // Group Count
    487            len += sizeof ( uint16 ) * grpCnt;  // Group List
    488          
    489            buf = zcl_mem_alloc( len );
    490            if ( buf )
    491            {
    492              pBuf = buf;
    493              if ( rspCmd )
    494                *pBuf++ = capacity;
    495          
    496              *pBuf++ = grpCnt;
    497              for ( i = 0; i < grpCnt; i++ )
    498              {
    499                *pBuf++ = LO_UINT16( grpList[i] );
    500                *pBuf++ = HI_UINT16( grpList[i] );
    501              }
    502          
    503              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    504                                        cmd, TRUE, direction,
    505                                        disableDefaultRsp, 0, seqNum, len, buf );
    506              zcl_mem_free( buf );
    507            }
    508            else
    509              status = ZMemError;
    510          
    511            return ( status );
    512          }
    513          
    514          /*********************************************************************
    515           * @fn      zclGeneral_SendGroupResponse
    516           *
    517           * @brief   Send Group Response (not Group View Response)
    518           *
    519           * @param   srcEP - Sending application's endpoint
    520           * @param   dstAddr - where you want the message to go
    521           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    522           * @param   status - group command status
    523           * @param   groupID - what group
    524           *
    525           * @return  ZStatus_t
    526           */
    527          ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
    528                                                  uint8 cmd, uint8 status, uint16 groupID,
    529                                                  uint8 disableDefaultRsp, uint8 seqNum )
    530          {
    531            uint8 buf[3];
    532          
    533            buf[0] = status;
    534            buf[1] = LO_UINT16( groupID );
    535            buf[2] = HI_UINT16( groupID );
    536          
    537            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    538                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    539                                    disableDefaultRsp, 0, seqNum, 3, buf );
    540          }
    541          
    542          /*********************************************************************
    543           * @fn      zclGeneral_SendGroupViewResponse
    544           *
    545           * @brief   Call to send Group Response Command
    546           *
    547           * @param   srcEP - Sending application's endpoint
    548           * @param   dstAddr - where you want the message to go
    549           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    550           * @param   status - group command status
    551           * @param   grp - group info
    552           *
    553           * @return  ZStatus_t
    554           */
    555          ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
    556                                                      uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
    557          {
    558            uint8 *buf;
    559            uint8 len;
    560            ZStatus_t stat;
    561          
    562            len = 1 + 2 + 1; // Status + Group ID + name length
    563          
    564            if ( status == ZCL_STATUS_SUCCESS )
    565            {
    566              len += grp->name[0];  // String length
    567            }
    568          
    569            buf = zcl_mem_alloc( len );
    570            if ( buf )
    571            {
    572              buf[0] = status;
    573              buf[1] = LO_UINT16( grp->ID );
    574              buf[2] = HI_UINT16( grp->ID );
    575          
    576              if ( status == ZCL_STATUS_SUCCESS )
    577              {
    578                buf[3] = grp->name[0]; // string length
    579                zcl_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
    580              }
    581              else //ZCL_STATUS_NOT_FOUND
    582              {
    583                buf[3] = 0;
    584              }
    585          
    586              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    587                                      COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    588                                      disableDefaultRsp, 0, seqNum, len, buf );
    589              zcl_mem_free( buf );
    590            }
    591            else
    592            {
    593              stat = ZMemError;
    594            }
    595          
    596            return ( stat );
    597          }
    598          #endif // ZCL_GROUPS
    599          
    600          #ifdef ZCL_SCENES
    601          /*********************************************************************
    602           * @fn      zclGeneral_SendAddSceneRequest
    603           *
    604           * @brief   Send the (Enhanced) Add Scene Request to a device. You can
    605           *           also use the appropriate macro.
    606           *
    607           * @param   srcEP - Sending Apps endpoint
    608           * @param   dstAddr - where to send the request
    609           * @param   scene - pointer to the scene structure
    610           * @param  cmd - COMMAND_SCENE_ADD or COMMAND_SCENE_ENHANCED_ADD
    611           * @param   disableDefaultRsp - whether to disable the Default Response command
    612           * @param   seqNum - sequence number
    613           *
    614           * @return  ZStatus_t
    615           */
    616          ZStatus_t zclGeneral_SendAddSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    617                                                    uint8 cmd, zclGeneral_Scene_t *scene,
    618                                                    uint8 disableDefaultRsp, uint8 seqNum )
    619          {
    620            uint8 *buf;
    621            uint8 *pBuf;
    622            uint8 len;
    623            ZStatus_t status;
    624          
    625            len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
    626            len += scene->name[0] + 1; // String + 1 for length
    627          
    628            // Add something for the extension field length
    629            len += scene->extLen;
    630          
    631            buf = zcl_mem_alloc( len );
    632            if ( buf )
    633            {
    634              pBuf = buf;
    635              *pBuf++ = LO_UINT16( scene->groupID );
    636              *pBuf++ = HI_UINT16( scene->groupID );
    637              *pBuf++ = scene->ID;
    638              *pBuf++ = LO_UINT16( scene->transTime );
    639              *pBuf++ = HI_UINT16( scene->transTime );
    640              *pBuf++ = scene->name[0]; // string length
    641              zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    642              pBuf += scene->name[0]; // move pass name
    643          
    644              // Add the extension fields
    645              if ( scene->extLen > 0 )
    646                zcl_memcpy( pBuf, scene->extField, scene->extLen );
    647          
    648              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    649                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    650                                        disableDefaultRsp, 0, seqNum, len, buf );
    651              zcl_mem_free( buf );
    652            }
    653            else
    654              status = ZMemError;
    655          
    656            return ( status );
    657          }
    658          
    659          /*********************************************************************
    660           * @fn      zclGeneral_SendSceneRequest
    661           *
    662           * @brief   Send a Scene Request to a device.  You can also use the
    663           *          appropriate macro.
    664           *
    665           * @param   srcEP - Sending Apps endpoint
    666           * @param   dstAddr - where to send the request
    667           * @param   cmd - one of the following:
    668           *              COMMAND_SCENE_VIEW
    669           *              COMMAND_SCENE_REMOVE
    670           *              COMMAND_SCENE_REMOVE_ALL
    671           *              COMMAND_SCENE_STORE
    672           *              COMMAND_SCENE_RECALL
    673           *              COMMAND_SCENE_GET_MEMBERSHIP
    674           *              COMMAND_SCENE_ENHANCED_VIEW
    675           * @param   groupID - group ID
    676           * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
    677           *                    COMMAND_SCENE_GET_MEMBERSHIP)
    678           * @param   disableDefaultRsp - whether to disable the Default Response command
    679           * @param   seqNum - sequence number
    680           * @return  ZStatus_t
    681           */
    682          ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    683                                                 uint8 cmd, uint16 groupID, uint8 sceneID,
    684                                                 uint8 disableDefaultRsp, uint8 seqNum )
    685          {
    686            uint8 buf[3];
    687            uint8 len = 2;
    688          
    689            buf[0] = LO_UINT16( groupID );
    690            buf[1] = HI_UINT16( groupID );
    691          
    692            if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
    693            {
    694              buf[2] = sceneID;
    695              len++;
    696            }
    697          
    698            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    699                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    700                                      disableDefaultRsp, 0, seqNum, len, buf ) );
    701          }
    702          
    703          /*********************************************************************
    704           * @fn      zclGeneral_SendSceneResponse
    705           *
    706           * @brief   Send Group Response (not Group View Response)
    707           *
    708           * @param   srcEP - Sending application's endpoint
    709           * @param   dstAddr - where you want the message to go
    710           * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
    711           *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
    712           * @param   status - scene command status
    713           * @param   groupID - what group
    714           * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
    715           *
    716           * @return  ZStatus_t
    717           */
    718          ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
    719                                                  uint8 cmd, uint8 status, uint16 groupID,
    720                                                  uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
    721          {
    722            uint8 buf[4];
    723            uint8 len = 1 + 2; // Status + Group ID
    724          
    725            buf[0] = status;
    726            buf[1] = LO_UINT16( groupID );
    727            buf[2] = HI_UINT16( groupID );
    728          
    729            if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
    730            {
    731              buf[3] = sceneID;
    732              len++;
    733            }
    734          
    735            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    736                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    737                                    disableDefaultRsp, 0, seqNum, len, buf );
    738          }
    739          
    740          /*********************************************************************
    741           * @fn      zclGeneral_SendSceneViewResponse
    742           *
    743           * @brief   Call to send Scene (Enahced) View Response Command. You can
    744           *           also use the appropriate macro.
    745           *
    746           * @param   srcEP - Sending application's endpoint
    747           * @param   dstAddr - where you want the message to go
    748           * @param   cmd - either COMMAND_SCENE_VIEW_RSP or COMMAND_SCENE_ENHANCED_VIEW_RSP
    749           * @param   status - scene command status
    750           * @param   scene - scene info
    751           *
    752           * @return  ZStatus_t
    753           */
    754          ZStatus_t zclGeneral_SendSceneViewRsp( uint8 srcEP, afAddrType_t *dstAddr,
    755                                                 uint8 cmd, uint8 status, zclGeneral_Scene_t *scene,
    756                                                 uint8 disableDefaultRsp, uint8 seqNum )
    757          {
    758            uint8 *buf;
    759            uint8 *pBuf;
    760            uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
    761            ZStatus_t stat;
    762          
    763            if ( status == ZCL_STATUS_SUCCESS )
    764            {
    765              len += 2; // Transition Time
    766              len += scene->name[0] + 1; // string + 1 for length
    767          
    768              // Add something for the extension field length
    769              len += scene->extLen;
    770            }
    771          
    772            buf = zcl_mem_alloc( len );
    773            if ( buf )
    774            {
    775              pBuf = buf;
    776              *pBuf++ = status;
    777              *pBuf++ = LO_UINT16( scene->groupID );
    778              *pBuf++ = HI_UINT16( scene->groupID );
    779              *pBuf++ = scene->ID;
    780              if ( status == ZCL_STATUS_SUCCESS )
    781              {
    782                uint16 transTime = scene->transTime;
    783                if ( cmd == COMMAND_SCENE_ENHANCED_VIEW_RSP )
    784                {
    785                  // Transition time is in 1/10s
    786                  transTime *= 10;
    787                  transTime += scene->transTime100ms;
    788                }
    789          
    790                *pBuf++ = LO_UINT16( transTime );
    791                *pBuf++ = HI_UINT16( transTime );
    792                *pBuf++ = scene->name[0]; // string length
    793                if ( scene->name[0] != 0 )
    794                {
    795                  zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    796                  pBuf += scene->name[0]; // move pass name
    797                }
    798          
    799                // Add the extension fields
    800                if ( scene->extLen > 0 )
    801                  zcl_memcpy( pBuf, scene->extField, scene->extLen );
    802              }
    803          
    804              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    805                                      cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    806                                      disableDefaultRsp, 0, seqNum, len, buf );
    807              zcl_mem_free( buf );
    808            }
    809            else
    810              stat = ZMemError;
    811          
    812            return ( stat );
    813          }
    814          
    815          /*********************************************************************
    816           * @fn      zclGeneral_SendSceneGetMembershipResponse
    817           *
    818           * @brief   Call to send Scene Get Membership Response Command
    819           *
    820           * @param   srcEP - Sending application's endpoint
    821           * @param   dstAddr - where you want the message to go
    822           * @param   status - scene command status
    823           * @param   capacity - remaining capacity of the scene table
    824           * @param   sceneCnt - number of scenes in the scene list
    825           * @param   sceneList - list of scene IDs
    826           * @param   groupID - group ID that scene belongs to
    827           * @param   seqNum - sequence number
    828           *
    829           * @return  ZStatus_t
    830           */
    831          ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
    832                                                               uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
    833                                                               uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    834          {
    835            uint8 *buf;
    836            uint8 *pBuf;
    837            uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
    838            uint8 i;
    839            ZStatus_t stat;
    840          
    841            if ( status == ZCL_STATUS_SUCCESS )
    842            {
    843              len++; // Scene Count
    844              len += sceneCnt; // Scene List (Scene ID is a single octet)
    845            }
    846          
    847            buf = zcl_mem_alloc( len );
    848            if ( buf )
    849            {
    850              pBuf = buf;
    851              *pBuf++ = status;
    852              *pBuf++ = capacity;
    853              *pBuf++ = LO_UINT16( groupID );
    854              *pBuf++ = HI_UINT16( groupID );
    855              if ( status == ZCL_STATUS_SUCCESS )
    856              {
    857                *pBuf++ = sceneCnt;
    858                for ( i = 0; i < sceneCnt; i++ )
    859                  *pBuf++ = sceneList[i];
    860              }
    861          
    862              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    863                                      COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
    864                                      ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
    865              zcl_mem_free( buf );
    866            }
    867            else
    868              stat = ZMemError;
    869          
    870            return ( stat );
    871          }
    872          
    873          #ifdef ZCL_LIGHT_LINK_ENHANCE
    874          /*********************************************************************
    875           * @fn      zclGeneral_SendSceneCopy
    876           *
    877           * @brief   Send Scene Copy Request to a device
    878           *
    879           * @param   srcEP - sending application's endpoint
    880           * @param   dstAddr - where to send the request
    881           * @param   mode - how scene copy is to proceed
    882           * @param   groupIDFrom - group from which scene to be copied
    883           * @param   sceneIDFrom - scene from which scene to be copied
    884           * @param   groupIDTo - group to which scene to be copied
    885           * @param   sceneIDTo - scene to which scene to be copied
    886           * @param   disableDefaultRsp - disable Default Response command
    887           * @param   seqNum - the identification number for the transaction
    888           *
    889           * @return  ZStatus_t
    890           */
    891          ZStatus_t zclGeneral_SendSceneCopy( uint8 srcEP, afAddrType_t *dstAddr,
    892                                              uint8 mode, uint16 groupIDFrom, uint8 sceneIDFrom,
    893                                              uint16 groupIDTo, uint8 sceneIDTo,
    894                                              uint8 disableDefaultRsp, uint8 seqNum )
    895          {
    896            uint8 buf[7];
    897          
    898            buf[0] = mode;
    899            buf[1] = LO_UINT16( groupIDFrom );
    900            buf[2] = HI_UINT16( groupIDFrom );
    901            buf[3] = sceneIDFrom;
    902            buf[4] = LO_UINT16( groupIDTo );
    903            buf[5] = HI_UINT16( groupIDTo );
    904            buf[6] = sceneIDTo;
    905          
    906            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    907                                      COMMAND_SCENE_COPY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    908                                      disableDefaultRsp, 0, seqNum, 7, buf ) );
    909          }
    910          
    911          /*********************************************************************
    912           * @fn      zclGeneral_SendSceneCopyResponse
    913           *
    914           * @brief   Send Scene Copy Response to a device
    915           *
    916           * @param   srcEP - sending application's endpoint
    917           * @param   dstAddr - where to send the request
    918           * @param   status - status of copy scene attemp
    919           * @param   groupIDFrom - group from which scene was copied
    920           * @param   sceneIDFrom - scene from which scene was copied
    921           * @param   disableDefaultRsp - disable Default Response command
    922           * @param   seqNum - the identification number for the transaction
    923           *
    924           * @return  ZStatus_t
    925           */
    926          ZStatus_t zclGeneral_SendSceneCopyResponse( uint8 srcEP, afAddrType_t *dstAddr,
    927                                                      uint8 status, uint16 groupIDFrom, uint8 sceneIDFrom,
    928                                                      uint8 disableDefaultRsp, uint8 seqNum )
    929          {
    930            uint8 buf[4];
    931          
    932            buf[0] = status;
    933            buf[1] = LO_UINT16( groupIDFrom );
    934            buf[2] = HI_UINT16( groupIDFrom );
    935            buf[3] = sceneIDFrom;
    936          
    937            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    938                                      COMMAND_SCENE_COPY_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    939                                      disableDefaultRsp, 0, seqNum, 4, buf ) );
    940          }
    941          #endif // ZCL_LIGHT_LINK_ENHANCE
    942          #endif // ZCL_SCENES
    943          
    944          #ifdef ZCL_ON_OFF
    945          #ifdef ZCL_LIGHT_LINK_ENHANCE
    946          /*********************************************************************
    947           * @fn      zclGeneral_SendOnOff_CmdOffWithEffect
    948           *
    949           * @brief   Call to send out an Off with Effect Command.
    950           *
    951           * @param   srcEP - Sending application's endpoint
    952           * @param   dstAddr - where you want the message to go
    953           * @param   effectId - fading effect to use when switching light off
    954           * @param   effectVariant - which variant of effect to be triggered
    955           * @param   disableDefaultRsp - whether to disable the Default Response command
    956           * @param   seqNum - sequence number
    957           *
    958           * @return  ZStatus_t
    959           */
    960          ZStatus_t zclGeneral_SendOnOff_CmdOffWithEffect( uint8 srcEP, afAddrType_t *dstAddr,
    961                                                           uint8 effectId, uint8 effectVariant,
    962                                                           uint8 disableDefaultRsp, uint8 seqNum )
    963          {
    964            uint8 buf[2];
    965          
    966            buf[0] = effectId;
    967            buf[1] = effectVariant;
    968          
    969            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
    970                                    COMMAND_OFF_WITH_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    971                                    disableDefaultRsp, 0, seqNum, 2, buf );
    972          }
    973          
    974          /*********************************************************************
    975           * @fn      zclGeneral_SendOnOff_CmdOnWithTimedOff
    976           *
    977           * @brief   Call to send out an On with Timed Off Command.
    978           *
    979           * @param   srcEP - Sending application's endpoint
    980           * @param   dstAddr - where you want the message to go
    981           * @param   onOffCtrl - how the lamp is to be operated
    982           * @param   onTime - the length of time (in 1/10ths second) that the lamp is to remain on, before automatically turning off
    983           * @param   offWaitTime - the length of time (in 1/10ths second) that the lamp shall remain off, and guarded to prevent an on command turning the light back on.
    984           * @param   disableDefaultRsp - whether to disable the Default Response command
    985           * @param   seqNum - sequence number
    986           *
    987           * @return  ZStatus_t
    988           */
    989          ZStatus_t zclGeneral_SendOnOff_CmdOnWithTimedOff ( uint8 srcEP, afAddrType_t *dstAddr,
    990                                                             zclOnOffCtrl_t onOffCtrl, uint16 onTime, uint16 offWaitTime,
    991                                                             uint8 disableDefaultRsp, uint8 seqNum )
    992          {
    993            uint8 buf[5];
    994          
    995            buf[0] = onOffCtrl.byte;
    996            buf[1] = LO_UINT16( onTime );
    997            buf[2] = HI_UINT16( onTime );
    998            buf[3] = LO_UINT16( offWaitTime );
    999            buf[4] = HI_UINT16( offWaitTime );
   1000          
   1001            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
   1002                                    COMMAND_ON_WITH_TIMED_OFF, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1003                                    disableDefaultRsp, 0, seqNum, 5, buf );
   1004          }
   1005          #endif // ZCL_LIGHT_LINK_ENHANCE
   1006          #endif // ZCL_ON_OFF
   1007          
   1008          #ifdef ZCL_LEVEL_CTRL
   1009          /*********************************************************************
   1010           * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
   1011           *
   1012           * @brief   Call to send out a Level Control Request. You can also use
   1013           *          the appropriate macro.
   1014           *
   1015           * @param   srcEP - Sending application's endpoint
   1016           * @param   dstAddr - where you want the message to go
   1017           * @param   cmd - one of the following:
   1018           *              COMMAND_LEVEL_MOVE_TO_LEVEL or
   1019           *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
   1020           * @param   level - what level to move to
   1021           * @param   transitionTime - how long to take to get to the level (in seconds)
   1022           *
   1023           * @return  ZStatus_t
   1024           */
   1025          ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1026                                                                   uint8 cmd, uint8 level, uint16 transTime,
   1027                                                                   uint8 disableDefaultRsp, uint8 seqNum )
   1028          {
   1029            uint8 buf[3];
   1030          
   1031            buf[0] = level;
   1032            buf[1] = LO_UINT16( transTime );
   1033            buf[2] = HI_UINT16( transTime );
   1034          
   1035            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1036                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1037                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1038          }
   1039          
   1040          /*********************************************************************
   1041           * @fn      zclGeneral_SendLevelControlMoveRequest
   1042           *
   1043           * @brief   Call to send out a Level Control Request. You can also use
   1044           *          the appropriate macro.
   1045           *
   1046           * @param   srcEP - Sending application's endpoint
   1047           * @param   dstAddr - where you want the message to go
   1048           * @param   cmd - one of the following:
   1049           *              COMMAND_LEVEL_MOVE or
   1050           *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
   1051           * @param   moveMode - LEVEL_MOVE_UP or
   1052           *                     LEVEL_MOVE_DOWN
   1053           * @param   rate - number of steps to take per second
   1054           *
   1055           * @return  ZStatus_t
   1056           */
   1057          ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1058                                                            uint8 cmd, uint8 moveMode, uint8 rate,
   1059                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1060          {
   1061            uint8 buf[2];
   1062          
   1063            buf[0] = moveMode;
   1064            buf[1] = rate;
   1065          
   1066            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1067                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1068                                    disableDefaultRsp, 0, seqNum, 2, buf );
   1069          }
   1070          
   1071          /*********************************************************************
   1072           * @fn      zclGeneral_SendLevelControlStepRequest
   1073           *
   1074           * @brief   Call to send out a Level Control Request. You can also use
   1075           *          the appropriate macro.
   1076           *
   1077           * @param   srcEP - Sending application's endpoint
   1078           * @param   dstAddr - where you want the message to go
   1079           * @param   cmd - one of the following:
   1080           *              COMMAND_LEVEL_STEP
   1081           *              COMMAND_LEVEL_STEP_WITH_ON_OFF
   1082           * @param   stepMode - LEVEL_STEP_UP or
   1083           *                     LEVEL_STEP_DOWN
   1084           * @param   amount - number of levels to step
   1085           * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
   1086           *
   1087           * @return  ZStatus_t
   1088           */
   1089          ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1090                                                            uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
   1091                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1092          {
   1093            uint8 buf[4];
   1094          
   1095            buf[0] = stepMode;
   1096            buf[1] = stepSize;
   1097            buf[2] = LO_UINT16( transTime );
   1098            buf[3] = HI_UINT16( transTime );
   1099          
   1100            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1101                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1102                                    disableDefaultRsp, 0, seqNum, 4, buf );
   1103          }
   1104          
   1105          /*********************************************************************
   1106           * @fn      zclGeneral_SendLevelControlStepRequest
   1107           *
   1108           * @brief   Call to send out a Level Control Request. You can also use
   1109           *          the appropriate macro.
   1110           *
   1111           * @param   srcEP - Sending application's endpoint
   1112           * @param   dstAddr - where you want the message to go
   1113           * @param   cmd - one of the following:
   1114           *              COMMAND_LEVEL_STOP
   1115           *              COMMAND_LEVEL_STOP_WITH_ON_OFF
   1116           *
   1117           * @return  ZStatus_t
   1118           */
   1119          ZStatus_t zclGeneral_SendLevelControlStopRequest( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1120                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1121          {
   1122            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1123                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1124                                    disableDefaultRsp, 0, seqNum, 0, NULL );
   1125          }
   1126          #endif // ZCL_LEVEL_CTRL
   1127          
   1128          #ifdef ZCL_ALARMS
   1129          /*********************************************************************
   1130           * @fn      zclGeneral_SendAlarm
   1131           *
   1132           * @brief   Call to send out an Alarm Request Command
   1133           *
   1134           * @param   srcEP - Sending application's endpoint
   1135           * @param   dstAddr - where you want the message to go
   1136           * @param   cmd - COMMAND_ALARMS_ALARM
   1137           * @param   alarmCode - code for the cause of the alarm
   1138           * @param   clusterID - cluster whose attribute generate the alarm
   1139           *
   1140           * @return  ZStatus_t
   1141           */
   1142          ZStatus_t zclGeneral_SendAlarm( uint8 srcEP, afAddrType_t *dstAddr,
   1143                                          uint8 alarmCode, uint16 clusterID,
   1144                                          uint8 disableDefaultRsp, uint8 seqNum )
   1145          {
   1146            uint8 buf[3];
   1147          
   1148            buf[0] = alarmCode;
   1149            buf[1] = LO_UINT16( clusterID );
   1150            buf[2] = HI_UINT16( clusterID );
   1151          
   1152            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1153                                    COMMAND_ALARMS_ALARM, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1154                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1155          }
   1156          
   1157          /*********************************************************************
   1158           * @fn      zclGeneral_SendAlarmReset
   1159           *
   1160           * @brief   Call to send out an Alarm Reset Command
   1161           *
   1162           * @param   srcEP - Sending application's endpoint
   1163           * @param   dstAddr - where you want the message to go
   1164           * @param   alarmCode - code for the cause of the alarm
   1165           * @param   clusterID - cluster whose attribute generate the alarm
   1166           *
   1167           * @return  ZStatus_t
   1168          */
   1169          ZStatus_t zclGeneral_SendAlarmReset( uint8 srcEP, afAddrType_t *dstAddr,
   1170                                               uint8 alarmCode, uint16 clusterID,
   1171                                               uint8 disableDefaultRsp, uint8 seqNum )
   1172          {
   1173            uint8 buf[3];
   1174          
   1175            buf[0] = alarmCode;
   1176            buf[1] = LO_UINT16( clusterID );
   1177            buf[2] = HI_UINT16( clusterID );
   1178          
   1179            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1180                                    COMMAND_ALARMS_RESET, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1181                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1182          }
   1183          
   1184          /*********************************************************************
   1185           * @fn      zclGeneral_SendAlarmGetRespnose
   1186           *
   1187           * @brief   Call to send out an Alarm Get Response Command
   1188           *
   1189           * @param   srcEP - Sending application's endpoint
   1190           * @param   dstAddr - where you want the message to go
   1191           * @param   status - SUCCESS or NOT_FOUND
   1192           * @param   alarmCode - code for the cause of the alarm
   1193           * @param   clusterID - cluster whose attribute generate the alarm
   1194           * @param   timeStamp - time at which the alarm occured
   1195           *
   1196           * @return  ZStatus_t
   1197           */
   1198          ZStatus_t zclGeneral_SendAlarmGetRespnose( uint8 srcEP, afAddrType_t *dstAddr,
   1199                                                     uint8 status, uint8 alarmCode, uint16 clusterID,
   1200                                                     uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
   1201          {
   1202            uint8 buf[8];
   1203            uint8 len = 1; // Status
   1204          
   1205            buf[0] = status;
   1206            if ( status == ZCL_STATUS_SUCCESS )
   1207            {
   1208              len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
   1209              buf[1] = alarmCode;
   1210              buf[2] = LO_UINT16( clusterID );
   1211              buf[3] = HI_UINT16( clusterID );
   1212              zcl_buffer_uint32( &buf[4], timeStamp );
   1213            }
   1214          
   1215            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1216                                    COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1217                                    disableDefaultRsp, 0, seqNum, len, buf );
   1218          }
   1219          
   1220          #ifdef SE_UK_EXT
   1221          /*********************************************************************
   1222           * @fn      zclGeneral_SendAlarmGetEventLog
   1223           *
   1224           * @brief   Call to send out an Alarm Get Event Log Command
   1225           *
   1226           * @param   srcEP - Sending application's endpoint
   1227           * @param   dstAddr - where you want the message to go
   1228           * @param   pEventLog - pointer to Get Event Log Command
   1229           * @param   disableDefaultRsp - disable default response
   1230           * @param   seqNum - ZCL sequence number
   1231           *
   1232           * @return  ZStatus_t
   1233           */
   1234          ZStatus_t zclGeneral_SendAlarmGetEventLog( uint8 srcEP, afAddrType_t *dstAddr,
   1235                                                     zclGetEventLog_t *pEventLog,
   1236                                                     uint8 disableDefaultRsp, uint8 seqNum )
   1237          {
   1238            uint8 buf[10];
   1239          
   1240            buf[0] = pEventLog->logID;
   1241            zcl_buffer_uint32( &buf[1], pEventLog->startTime );
   1242            zcl_buffer_uint32( &buf[5], pEventLog->endTime );
   1243            buf[9] = pEventLog->numEvents;
   1244          
   1245            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1246                                    COMMAND_ALARMS_GET_EVENT_LOG, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1247                                    disableDefaultRsp, 0, seqNum, 10, buf );
   1248          }
   1249          
   1250          /*********************************************************************
   1251           * @fn      zclGeneral_SendAlarmPublishEventLog
   1252           *
   1253           * @brief   Call to send out an Alarm Publish Event Log Command
   1254           *
   1255           * @param   srcEP - Sending application's endpoint
   1256           * @param   dstAddr - where you want the message to go
   1257           * @param   pEventLog - pointer to Publish Event Log Command
   1258           * @param   disableDefaultRsp - disable default response
   1259           * @param   seqNum - ZCL sequence number
   1260           *
   1261           * @return  ZStatus_t
   1262           */
   1263          ZStatus_t zclGeneral_SendAlarmPublishEventLog( uint8 srcEP, afAddrType_t *dstAddr,
   1264                                                         zclPublishEventLog_t *pEventLog,
   1265                                                         uint8 disableDefaultRsp, uint8 seqNum )
   1266          {
   1267            uint8 *buf;
   1268            uint8 *pBuf;
   1269            uint8 bufLen;
   1270          
   1271            // Log ID + Command Index + Total Commands + (numSubLogs * ( Event ID + Event Time))
   1272            bufLen = 1 + 1 + 1 + (pEventLog->numSubLogs * (1 + 4));
   1273          
   1274            buf = zcl_mem_alloc( bufLen );
   1275            if ( buf == NULL )
   1276            {
   1277              return (ZMemError);
   1278            }
   1279          
   1280            pBuf = buf;
   1281            *pBuf++ = pEventLog->logID;
   1282            *pBuf++ = pEventLog->cmdIndex;
   1283            *pBuf++ = pEventLog->totalCmds;
   1284          
   1285            for ( uint8 i = 0; i < pEventLog->numSubLogs; i++ )
   1286            {
   1287              zclEventLogPayload_t *pLogs = &(pEventLog->pLogs[i]);
   1288          
   1289              *pBuf++ = pLogs->eventId;
   1290              pBuf = zcl_buffer_uint32( pBuf, pLogs->eventTime );
   1291            }
   1292          
   1293            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1294                                    COMMAND_ALARMS_PUBLISH_EVENT_LOG, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1295                                    disableDefaultRsp, 0, seqNum, bufLen, buf );
   1296          }
   1297          #endif // SE_UK_EXT
   1298          #endif // ZCL_ALARMS
   1299          
   1300          #ifdef ZCL_LOCATION
   1301          /*********************************************************************
   1302           * @fn      zclGeneral_SendLocationSetAbsolute
   1303           *
   1304           * @brief   Call to send out a Set Absolute Location Command
   1305           *
   1306           * @param   srcEP - Sending application's endpoint
   1307           * @param   dstAddr - where you want the message to go
   1308           * @param   absLoc - absolute location info
   1309           *
   1310           * @return  ZStatus_t
   1311           */
   1312          ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
   1313                                                        zclLocationAbsolute_t *absLoc,
   1314                                                        uint8 disableDefaultRsp, uint8 seqNum )
   1315          {
   1316             uint8 buf[10]; // 5 fields (2 octects each)
   1317          
   1318             buf[0] = LO_UINT16( absLoc->coordinate1 );
   1319             buf[1] = HI_UINT16( absLoc->coordinate1 );
   1320             buf[2] = LO_UINT16( absLoc->coordinate2 );
   1321             buf[3] = HI_UINT16( absLoc->coordinate2 );
   1322             buf[4] = LO_UINT16( absLoc->coordinate3 );
   1323             buf[5] = HI_UINT16( absLoc->coordinate3 );
   1324             buf[6] = LO_UINT16( absLoc->power );
   1325             buf[7] = HI_UINT16( absLoc->power );
   1326             buf[8] = LO_UINT16( absLoc->pathLossExponent );
   1327             buf[9] = HI_UINT16( absLoc->pathLossExponent );
   1328          
   1329             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1330                                     COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
   1331                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
   1332          }
   1333          
   1334          /*********************************************************************
   1335           * @fn      zclGeneral_SendLocationSetDevCfg
   1336           *
   1337           * @brief   Call to send out a Set Device Configuration Command
   1338           *
   1339           * @param   srcEP - Sending application's endpoint
   1340           * @param   dstAddr - where you want the message to go
   1341           * @param   devCfg - device configuration info
   1342           *
   1343           * @return  ZStatus_t
   1344           */
   1345          ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1346                                                      zclLocationDevCfg_t *devCfg,
   1347                                                      uint8 disableDefaultRsp, uint8 seqNum )
   1348          {
   1349             uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
   1350          
   1351             buf[0] = LO_UINT16( devCfg->power );
   1352             buf[1] = HI_UINT16( devCfg->power );
   1353             buf[2] = LO_UINT16( devCfg->pathLossExponent );
   1354             buf[3] = HI_UINT16( devCfg->pathLossExponent );
   1355             buf[4] = LO_UINT16( devCfg->calcPeriod );
   1356             buf[5] = HI_UINT16( devCfg->calcPeriod );
   1357             buf[6] = devCfg->numMeasurements;
   1358             buf[7] = LO_UINT16( devCfg->reportPeriod );
   1359             buf[8] = HI_UINT16( devCfg->reportPeriod );
   1360          
   1361             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1362                                     COMMAND_LOCATION_SET_DEV_CFG, TRUE,
   1363                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
   1364          }
   1365          
   1366          /*********************************************************************
   1367           * @fn      zclGeneral_SendLocationGetDevCfg
   1368           *
   1369           * @brief   Call to send out a Get Device Configuration Command
   1370           *
   1371           * @param   srcEP - Sending application's endpoint
   1372           * @param   dstAddr - where you want the message to go
   1373           * @param   targetAddr - device for which location parameters are being requested
   1374           *
   1375           * @return  ZStatus_t
   1376           */
   1377          ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1378                                                      uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
   1379          {
   1380            uint8 buf[8];
   1381          
   1382            zcl_memcpy( buf, targetAddr, 8 );
   1383          
   1384            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1385                                    COMMAND_LOCATION_GET_DEV_CFG, TRUE,
   1386                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
   1387          }
   1388          
   1389          /*********************************************************************
   1390           * @fn      zclGeneral_SendLocationGetData
   1391           *
   1392           * @brief   Call to send out a Get Location Data Command
   1393           *
   1394           * @param   srcEP - Sending application's endpoint
   1395           * @param   dstAddr - where you want the message to go
   1396           * @param   locaData - location information and channel parameters that are requested.
   1397           *
   1398           * @return  ZStatus_t
   1399           */
   1400          ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
   1401                                                    zclLocationGetData_t *locData,
   1402                                                    uint8 disableDefaultRsp, uint8 seqNum )
   1403          {
   1404            uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
   1405            uint8 *pBuf = buf;
   1406            uint8 len = 2; // bitmap + number responses
   1407          
   1408            *pBuf  = locData->absoluteOnly;
   1409            *pBuf |= locData->recalculate << 1;
   1410            *pBuf |= locData->brdcastIndicator << 2;
   1411            *pBuf |= locData->brdcastResponse << 3;
   1412            *pBuf |= locData->compactResponse << 4;
   1413            pBuf++;  // move past the bitmap field
   1414          
   1415            *pBuf++ = locData->numResponses;
   1416          
   1417            if ( locData->brdcastIndicator == 0 )
   1418            {
   1419              zcl_memcpy( pBuf, locData->targetAddr, 8 );
   1420              len += 8; // ieee addr
   1421            }
   1422          
   1423            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1424                                    COMMAND_LOCATION_GET_DATA, TRUE,
   1425                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1426          }
   1427          
   1428          /*********************************************************************
   1429           * @fn      zclGeneral_SendLocationDevCfgResponse
   1430           *
   1431           * @brief   Call to send out a Device Configuration Response Command
   1432           *
   1433           * @param   srcEP - Sending application's endpoint
   1434           * @param   dstAddr - where you want the message to go
   1435           * @param   devCfg - device's location parameters that are requested
   1436           *
   1437           * @return  ZStatus_t
   1438           */
   1439          ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1440                                                           zclLocationDevCfgRsp_t *devCfg,
   1441                                                           uint8 disableDefaultRsp, uint8 seqNum )
   1442          {
   1443            uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
   1444            uint8 len = 1; // Status
   1445          
   1446            buf[0] = devCfg->status;
   1447            if ( devCfg->status == ZCL_STATUS_SUCCESS )
   1448            {
   1449              buf[1] = LO_UINT16( devCfg->data.power );
   1450              buf[2] = HI_UINT16( devCfg->data.power );
   1451              buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
   1452              buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
   1453              buf[5] = LO_UINT16( devCfg->data.calcPeriod );
   1454              buf[6] = HI_UINT16( devCfg->data.calcPeriod );
   1455              buf[7] = devCfg->data.numMeasurements;
   1456              buf[8] = LO_UINT16( devCfg->data.reportPeriod );
   1457              buf[9] = HI_UINT16( devCfg->data.reportPeriod );
   1458              len += 9;
   1459            }
   1460          
   1461            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1462                                    COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
   1463                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1464          }
   1465          
   1466          /*********************************************************************
   1467           * @fn      zclGeneral_SendLocationData
   1468           *
   1469           * @brief   Call to send out location data
   1470           *
   1471           * @param   srcEP - Sending application's endpoint
   1472           * @param   dstAddr - where you want the message to go
   1473           * @param   status - indicates whether response to request was successful or not
   1474           * @param   locData - location information and channel parameters being sent
   1475           *
   1476           * @return  ZStatus_t
   1477           */
   1478          ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1479                                                 uint8 status, zclLocationData_t *locData,
   1480                                                 uint8 disableDefaultRsp, uint8 seqNum )
   1481          {
   1482            uint8 buf[16];
   1483            uint8 *pBuf = buf;
   1484            uint8 len = 0;
   1485          
   1486            if ( cmd == COMMAND_LOCATION_DATA_RSP )
   1487            {
   1488              // Only response command includes a status field
   1489              *pBuf++ = status;
   1490              len++;
   1491            }
   1492          
   1493            if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
   1494            {
   1495              // Notification or Response with successful status
   1496              *pBuf++ = locData->type;
   1497              *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
   1498              *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
   1499              *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
   1500              *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
   1501              len += 5;
   1502          
   1503              if ( locationType2D(locData->type) == 0 )
   1504              {
   1505                // 2D location doesn't have coordinate 3
   1506                *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
   1507                *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
   1508                len += 2;
   1509              }
   1510          
   1511              if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1512              {
   1513                // Compact notification doesn't include these fields
   1514                *pBuf++ = LO_UINT16( locData->absLoc.power );
   1515                *pBuf++ = HI_UINT16( locData->absLoc.power );
   1516                *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
   1517                *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
   1518                len += 4;
   1519              }
   1520          
   1521              if ( locationTypeAbsolute(locData->type) == 0 )
   1522              {
   1523                // Absolute location doesn't include these fields
   1524                if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1525                {
   1526                  // Compact notification doesn't include this field
   1527                  *pBuf++ = locData->calcLoc.locationMethod;
   1528                  len++;
   1529                }
   1530          
   1531                *pBuf++ = locData->calcLoc.qualityMeasure;
   1532                *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
   1533                *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
   1534                len += 3;
   1535              }
   1536            }
   1537          
   1538            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1539                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1540                                    disableDefaultRsp, 0, seqNum, len, buf );
   1541          }
   1542          #endif // ZCL_LOCATION
   1543          
   1544          /*********************************************************************
   1545           * @fn      zclGeneral_FindCallbacks
   1546           *
   1547           * @brief   Find the callbacks for an endpoint
   1548           *
   1549           * @param   endpoint - endpoint to find the application callbacks for
   1550           *
   1551           * @return  pointer to the callbacks
   1552           */
   1553          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
   1554          {
   1555            zclGenCBRec_t *pCBs;
   1556          
   1557            pCBs = zclGenCBs;
   1558            while ( pCBs )
   1559            {
   1560              if ( pCBs->endpoint == endpoint )
   1561                return ( pCBs->CBs );
   1562              pCBs = pCBs->next;
   1563            }
   1564            return ( (zclGeneral_AppCallbacks_t *)NULL );
   1565          }
   1566          
   1567          /*********************************************************************
   1568           * @fn      zclGeneral_HdlIncoming
   1569           *
   1570           * @brief   Callback from ZCL to process incoming Commands specific
   1571           *          to this cluster library or Profile commands for attributes
   1572           *          that aren't in the attribute list
   1573           *
   1574           *
   1575           * @param   pInMsg - pointer to the incoming message
   1576           *
   1577           * @return  ZStatus_t
   1578           */

   \                                 In  segment CODE, align 2
   1579          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlIncoming:
   1580          {
   1581            ZStatus_t stat = ZSuccess;
   1582          
   1583          #if defined ( INTER_PAN )
   1584            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
   1585              return ( stat ); // Cluster not supported thru Inter-PAN
   1586          #endif
   1587            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
   \   000000   5E4C0200     MOV.B   0x2(R12), R14
   \   000004   7EF00700     AND.B   #0x7, R14
   \   000008   5E93         CMP.B   #0x1, R14
   \   00000A   0220         JNE     ??zclGeneral_HdlIncoming_0
   1588            {
   1589              // Is this a manufacturer specific command?
   1590              if ( pInMsg->hdr.fc.manuSpecific == 0 )
   1591              {
   1592                stat = zclGeneral_HdlInSpecificCommands( pInMsg );
   \   00000C   ........     BRA     #zclGeneral_HdlInSpecificCommands
   1593              }
   1594              else
   1595              {
   1596                // We don't support any manufacturer specific command.
   1597                stat = ZFailure;
   1598              }
   1599            }
   1600            else
   1601            {
   1602              // Handle all the normal (Read, Write...) commands -- should never get here
   1603              stat = ZFailure;
   \                     ??zclGeneral_HdlIncoming_0:
   \   000010   5C43         MOV.B   #0x1, R12
   1604            }
   1605            return ( stat );
   \   000012   1001         RETA
   1606          }
   1607          
   1608          /*********************************************************************
   1609           * @fn      zclGeneral_HdlInSpecificCommands
   1610           *
   1611           * @brief   Callback from ZCL to process incoming Commands specific
   1612           *          to this cluster library
   1613          
   1614           * @param   pInMsg - pointer to the incoming message
   1615           *
   1616           * @return  ZStatus_t
   1617           */

   \                                 In  segment CODE, align 2
   1618          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlInSpecificCommands:
   1619          {
   \   000000   0A12         PUSH.W  R10
   1620            ZStatus_t stat;
   1621            zclGeneral_AppCallbacks_t *pCBs;
   1622          
   1623            // make sure endpoint exists
   1624            pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
   \   000002   2F4C         MOV.W   @R12, R15
   \   000004   5E4F1400     MOV.B   0x14(R15), R14
   \   000008   1D42....     MOV.W   &zclGenCBs, R13
   \   00000C   013C         JMP     ??zclGeneral_HdlInSpecificCommands_6
   \                     ??zclGeneral_HdlInSpecificCommands_0:
   \   00000E   2D4D         MOV.W   @R13, R13
   \                     ??zclGeneral_HdlInSpecificCommands_6:
   \   000010   0D93         CMP.W   #0x0, R13
   \   000012   1924         JEQ     ??zclGeneral_HdlInSpecificCommands_4
   \   000014   CD9E0200     CMP.B   R14, 0x2(R13)
   \   000018   FA23         JNE     ??zclGeneral_HdlInSpecificCommands_0
   \   00001A   1D4D0400     MOV.W   0x4(R13), R13
   1625            if ( pCBs == NULL )
   \   00001E   0D93         CMP.W   #0x0, R13
   \   000020   1224         JEQ     ??zclGeneral_HdlInSpecificCommands_4
   1626              return ( ZFailure );
   1627          
   1628            switch ( pInMsg->msg->clusterId )
   \   000022   1F4F0400     MOV.W   0x4(R15), R15
   \   000026   0F83         SUB.W   #0x0, R15
   \   000028   0724         JEQ     ??zclGeneral_HdlInSpecificCommands_7
   \   00002A   3F800300     SUB.W   #0x3, R15
   \   00002E   1724         JEQ     ??zclGeneral_HdlInSpecificCommands_8
   \   000030   3F800300     SUB.W   #0x3, R15
   \   000034   1824         JEQ     ??zclGeneral_HdlInSpecificCommands_9
   \   000036   2F3C         JMP     ??zclGeneral_HdlInSpecificCommands_3
   1629            {
   1630          #ifdef ZCL_BASIC
   1631              case ZCL_CLUSTER_ID_GEN_BASIC:
   1632                stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_7:
   \   000038   BCB20200     BIT.W   #0x8, 0x2(R12)
   \   00003C   0E2C         JC      ??zclGeneral_HdlInSpecificCommands_10
   \   00003E   CC930700     CMP.B   #0x0, 0x7(R12)
   \   000042   0324         JEQ     ??zclGeneral_HdlInSpecificCommands_11
   \   000044   283C         JMP     ??zclGeneral_HdlInSpecificCommands_3
   \                     ??zclGeneral_HdlInSpecificCommands_4:
   \   000046   5C43         MOV.B   #0x1, R12
   \   000048   283C         JMP     ??zclGeneral_HdlInSpecificCommands_12
   \                     ??zclGeneral_HdlInSpecificCommands_11:
   \   00004A   3E4D         MOV.W   @R13+, R14
   \   00004C   3F4D         MOV.W   @R13+, R15
   \   00004E   0D4E         MOV.W   R14, R13
   \   000050   0DDF         BIS.W   R15, R13
   \   000052   0D93         CMP.W   #0x0, R13
   \   000054   0224         JEQ     ??zclGeneral_HdlInSpecificCommands_10
   \   000056   ........     CALLA   #?IndCallR15
   \                     ??zclGeneral_HdlInSpecificCommands_10:
   \   00005A   4A43         MOV.B   #0x0, R10
   \   00005C   1D3C         JMP     ??zclGeneral_HdlInSpecificCommands_1
   1633                break;
   1634          #endif // ZCL_BASIC
   1635          
   1636          #ifdef ZCL_IDENTIFY
   1637              case ZCL_CLUSTER_ID_GEN_IDENTIFY:
   1638                stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_8:
   \   00005E   ........     CALLA   #zclGeneral_ProcessInIdentity
   \   000062   4A4C         MOV.B   R12, R10
   1639                break;
   \   000064   193C         JMP     ??zclGeneral_HdlInSpecificCommands_1
   1640          #endif // ZCL_IDENTIFY
   1641          
   1642          #ifdef ZCL_GROUPS
   1643              case ZCL_CLUSTER_ID_GEN_GROUPS:
   1644                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1645                  stat = zclGeneral_ProcessInGroupsServer( pInMsg );
   1646                else
   1647                  stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
   1648                break;
   1649          #endif // ZCL_GROUPS
   1650          
   1651          #ifdef ZCL_SCENES
   1652              case ZCL_CLUSTER_ID_GEN_SCENES:
   1653                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1654                  stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
   1655                else
   1656                  stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
   1657                break;
   1658          #endif // ZCL_SCENES
   1659          
   1660          #ifdef ZCL_ON_OFF
   1661              case ZCL_CLUSTER_ID_GEN_ON_OFF:
   1662                stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_9:
   \   000066   4A43         MOV.B   #0x0, R10
   \   000068   BCB20200     BIT.W   #0x8, 0x2(R12)
   \   00006C   152C         JC      ??zclGeneral_HdlInSpecificCommands_1
   \   00006E   5C4C0700     MOV.B   0x7(R12), R12
   \   000072   4E4C         MOV.B   R12, R14
   \   000074   4E83         SUB.B   #0x0, R14
   \   000076   0424         JEQ     ??zclGeneral_HdlInSpecificCommands_2
   \   000078   5E83         SUB.B   #0x1, R14
   \   00007A   0224         JEQ     ??zclGeneral_HdlInSpecificCommands_2
   \   00007C   5E83         SUB.B   #0x1, R14
   \   00007E   0B20         JNE     ??zclGeneral_HdlInSpecificCommands_3
   \                     ??zclGeneral_HdlInSpecificCommands_2:
   \   000080   1E4D1000     MOV.W   0x10(R13), R14
   \   000084   1F4D1200     MOV.W   0x12(R13), R15
   \   000088   0D4E         MOV.W   R14, R13
   \   00008A   0DDF         BIS.W   R15, R13
   \   00008C   0D93         CMP.W   #0x0, R13
   \   00008E   0424         JEQ     ??zclGeneral_HdlInSpecificCommands_1
   \   000090   ........     CALLA   #?IndCallR15
   \   000094   013C         JMP     ??zclGeneral_HdlInSpecificCommands_1
   \                     ??zclGeneral_HdlInSpecificCommands_3:
   \   000096   5A43         MOV.B   #0x1, R10
   1663                break;
   1664          #endif // ZCL_ON_OFF
   1665          
   1666          #ifdef ZCL_LEVEL_CTRL
   1667              case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
   1668                stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
   1669                break;
   1670          #endif // ZCL_LEVEL_CTRL
   1671          
   1672          #ifdef ZCL_ALARMS
   1673              case ZCL_CLUSTER_ID_GEN_ALARMS:
   1674                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1675                  stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
   1676                else
   1677                  stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
   1678                break;
   1679          #endif // ZCL_ALARMS
   1680          
   1681          #ifdef ZCL_LOCATION
   1682              case ZCL_CLUSTER_ID_GEN_LOCATION:
   1683                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1684                  stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
   1685                else
   1686                  stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
   1687                break;
   1688          #endif // ZCL_LOCATION
   1689          
   1690              case ZCL_CLUSTER_ID_GEN_POWER_CFG:
   1691              case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
   1692              case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
   1693              case ZCL_CLUSTER_ID_GEN_TIME:
   1694              default:
   1695                stat = ZFailure;
   1696                break;
   1697            }
   1698          
   1699            return ( stat );
   \                     ??zclGeneral_HdlInSpecificCommands_1:
   \   000098   4C4A         MOV.B   R10, R12
   \                     ??zclGeneral_HdlInSpecificCommands_12:
   \   00009A   3A41         POP.W   R10
   \   00009C   1001         RETA
   1700          }
   1701          
   1702          #ifdef ZCL_BASIC
   1703          /*********************************************************************
   1704           * @fn      zclGeneral_ProcessInBasic
   1705           *
   1706           * @brief   Process in the received Basic Command.
   1707           *
   1708           * @param   pInMsg - pointer to the incoming message
   1709           *
   1710           * @return  ZStatus_t
   1711           */
   1712          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
   1713                                                      zclGeneral_AppCallbacks_t *pCBs )
   1714          {
   1715            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1716            {
   1717              if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
   1718                return ( ZFailure );   // Error ignore the command
   1719          
   1720              if ( pCBs->pfnBasicReset )
   1721                pCBs->pfnBasicReset();
   1722            }
   1723            // no Client command
   1724          
   1725            return ( ZSuccess );
   1726          }
   1727          #endif // ZCL_BASIC
   1728          
   1729          #ifdef ZCL_IDENTIFY
   1730          /*********************************************************************
   1731           * @fn      zclGeneral_ProcessInIdentity
   1732           *
   1733           * @brief   Process in the received Identity Command.
   1734           *
   1735           * @param   pInMsg - pointer to the incoming message
   1736           *
   1737           * @return  ZStatus_t
   1738           */

   \                                 In  segment CODE, align 2
   1739          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInIdentity:
   1740                                                         zclGeneral_AppCallbacks_t *pCBs )
   1741          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31800600     SUB.W   #0x6, SP
   \   000006   084C         MOV.W   R12, R8
   1742            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \   000008   BCB20200     BIT.W   #0x8, 0x2(R12)
   \   00000C   2D2C         JC      ??zclGeneral_ProcessInIdentity_0
   1743            {
   1744              if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
   \   00000E   5E4C0700     MOV.B   0x7(R12), R14
   \   000012   4E93         CMP.B   #0x0, R14
   \   000014   0520         JNE     ??zclGeneral_ProcessInIdentity_1
   1745              {
   1746                if ( pCBs->pfnIdentify )
   \   000016   1A4D0400     MOV.W   0x4(R13), R10
   \   00001A   1B4D0600     MOV.W   0x6(R13), R11
   \   00001E   2D3C         JMP     ??zclGeneral_ProcessInIdentity_2
   1747                {
   1748                  zclIdentify_t cmd;
   1749          
   1750                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1751                  cmd.identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1752          
   1753                  pCBs->pfnIdentify( &cmd );
   1754                }
   1755              }
   1756              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_QUERY )
   \                     ??zclGeneral_ProcessInIdentity_1:
   \   000020   5E93         CMP.B   #0x1, R14
   \   000022   2520         JNE     ??zclGeneral_ProcessInIdentity_3
   1757              {
   1758                uint16 identifyTime = 0;
   \   000024   81430400     MOV.W   #0x0, 0x4(SP)
   1759          
   1760                // Retrieve Identify Time
   1761                zcl_ReadAttrData( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   1762                                  ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
   \   000028   2B4C         MOV.W   @R12, R11
   \   00002A   0312         PUSH.W  #0x0
   \   00002C   0F41         MOV.W   SP, R15
   \   00002E   3F500600     ADD.W   #0x6, R15
   \   000032   0E43         MOV.W   #0x0, R14
   \   000034   1D4B0400     MOV.W   0x4(R11), R13
   \   000038   5C4B1400     MOV.B   0x14(R11), R12
   \   00003C   ........     CALLA   #zcl_ReadAttrData
   1763          
   1764                // Is device identifying itself?
   1765                if ( identifyTime > 0 )
   \   000040   2153         ADD.W   #0x2, SP
   \   000042   81930400     CMP.W   #0x0, 0x4(SP)
   \   000046   3024         JEQ     ??zclGeneral_ProcessInIdentity_4
   1766                {
   1767                  zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1768                                                        identifyTime, true, pInMsg->hdr.transSeqNum );
   \   000048   2B48         MOV.W   @R8, R11
   \   00004A   58120600     PUSH.B  0x6(R8)
   \   00004E   5F43         MOV.B   #0x1, R15
   \   000050   1E410600     MOV.W   0x6(SP), R14
   \   000054   0D4B         MOV.W   R11, R13
   \   000056   3D500600     ADD.W   #0x6, R13
   \   00005A   5C4B1400     MOV.B   0x14(R11), R12
   \   00005E   ........     CALLA   #zclGeneral_SendIdentifyQueryResponse
   1769          #ifdef ZCL_EZMODE
   1770                  zcl_EZModeAction( EZMODE_ACTION_IDENTIFY_QUERY, NULL );
   1771          #endif
   1772                  return ( ZCL_STATUS_CMD_HAS_RSP );
   \   000062   7C43         MOV.B   #0xff, R12
   \   000064   2153         ADD.W   #0x2, SP
   \   000066   213C         JMP     ??zclGeneral_ProcessInIdentity_5
   1773                }
   1774              }
   1775          #ifdef ZCL_EZMODE
   1776              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_EZMODE_INVOKE )
   1777              {
   1778                if ( pCBs->pfnIdentifyEZModeInvoke )
   1779                {
   1780                  pCBs->pfnIdentifyEZModeInvoke( pInMsg->pData[0] );
   1781                }
   1782              }
   1783              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_UPDATE_COMMISSION_STATE )
   1784              {
   1785                if ( pCBs->pfnIdentifyUpdateCommState )
   1786                {
   1787                  zclIdentifyUpdateCommState_t cmd;
   1788          
   1789                  cmd.action = pInMsg->pData[0];
   1790                  cmd.commissionStateMask = pInMsg->pData[1];
   1791          
   1792                  pCBs->pfnIdentifyUpdateCommState( &cmd );
   1793                }
   1794              }
   1795          #endif
   1796          
   1797          #ifdef ZCL_LIGHT_LINK_ENHANCE
   1798              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_TRIGGER_EFFECT )
   1799              {
   1800                if ( pCBs->pfnIdentifyTriggerEffect )
   1801                {
   1802                  zclIdentifyTriggerEffect_t cmd;
   1803          
   1804                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1805                  cmd.effectId = pInMsg->pData[0];
   1806                  cmd.effectVariant = pInMsg->pData[1];
   1807          
   1808                  pCBs->pfnIdentifyTriggerEffect( &cmd );
   1809                }
   1810              }
   1811          #endif //ZCL_LIGHT_LINK_ENHANCE
   1812              else
   1813              {
   1814                return ( ZFailure );   // Error ignore the command
   1815              }
   1816            }
   1817            else // Client Command
   1818            {
   1819              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
   \                     ??zclGeneral_ProcessInIdentity_0:
   \   000068   CC930700     CMP.B   #0x0, 0x7(R12)
   \   00006C   0224         JEQ     ??zclGeneral_ProcessInIdentity_6
   1820                return ( ZFailure );   // Error ignore the command
   \                     ??zclGeneral_ProcessInIdentity_3:
   \   00006E   5C43         MOV.B   #0x1, R12
   \   000070   1C3C         JMP     ??zclGeneral_ProcessInIdentity_5
   1821          
   1822              if ( pCBs->pfnIdentifyQueryRsp )
   \                     ??zclGeneral_ProcessInIdentity_6:
   \   000072   1A4D0C00     MOV.W   0xc(R13), R10
   \   000076   1B4D0E00     MOV.W   0xe(R13), R11
   \                     ??zclGeneral_ProcessInIdentity_2:
   \   00007A   0F4A         MOV.W   R10, R15
   \   00007C   0FDB         BIS.W   R11, R15
   \   00007E   0F93         CMP.W   #0x0, R15
   \   000080   1324         JEQ     ??zclGeneral_ProcessInIdentity_4
   1823              {
   1824                zclIdentifyQueryRsp_t rsp;
   1825          
   1826                rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   000082   2F4C         MOV.W   @R12, R15
   \   000084   3F500600     ADD.W   #0x6, R15
   \   000088   814F0000     MOV.W   R15, 0(SP)
   1827                rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   \   00008C   1F4C0800     MOV.W   0x8(R12), R15
   \   000090   6E4F         MOV.B   @R15, R14
   \   000092   5F4F0100     MOV.B   0x1(R15), R15
   \   000096                RPT     #0x8
   \   000096   47180F5F     RLAX.W  R15
   \   00009A   0E5F         ADD.W   R15, R14
   \   00009C   814E0200     MOV.W   R14, 0x2(SP)
   1828          
   1829                pCBs->pfnIdentifyQueryRsp( &rsp );
   \   0000A0   0C41         MOV.W   SP, R12
   \   0000A2   0C53         ADD.W   #0x0, R12
   \   0000A4   ........     CALLA   #?IndCallR11
   1830              }
   1831            }
   1832          
   1833            return ( ZSuccess );
   \                     ??zclGeneral_ProcessInIdentity_4:
   \   0000A8   4C43         MOV.B   #0x0, R12
   \                     ??zclGeneral_ProcessInIdentity_5:
   \   0000AA   31500600     ADD.W   #0x6, SP
   \   0000AE   3817         POPM.W  #0x4, R11
   \   0000B0   1001         RETA
   1834          }
   1835          #endif // ZCL_IDENTIFY
   1836          
   1837          #ifdef ZCL_GROUPS
   1838          
   1839          /*********************************************************************
   1840           * @fn      zclGeneral_AddGroup
   1841           *
   1842           * @brief   Add a Group.
   1843           *
   1844           * @param   endPoint - application endpoint
   1845           * @param   group - group to be added
   1846           * @param   pData - pointer to the group info
   1847           *
   1848           * @return  ZStatus_t
   1849           */
   1850          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
   1851          {
   1852            uint8 nameLen;
   1853            uint8 nameSupport = FALSE;
   1854          
   1855            pData += 2;   // Move past group ID
   1856            nameLen = *pData++;
   1857          
   1858            // Retrieve Name Support attribute
   1859            zcl_ReadAttrData( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS,
   1860                              ATTRID_GROUP_NAME_SUPPORT, &nameSupport, NULL );
   1861          
   1862            if ( nameSupport )
   1863            {
   1864              if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1865                 nameLen = (APS_GROUP_NAME_LEN-1);
   1866              group->name[0] = nameLen;
   1867              zcl_memcpy( &(group->name[1]), pData, nameLen );
   1868            }
   1869          
   1870            return ( aps_AddGroup( endPoint, group ) );
   1871          }
   1872          
   1873          /*********************************************************************
   1874           * @fn      zclGeneral_ProcessInGroupsServer
   1875           *
   1876           * @brief   Process in the received Groups Command.
   1877           *
   1878           * @param   pInMsg - pointer to the incoming message
   1879           *
   1880           * @return  ZStatus_t
   1881           */
   1882          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
   1883          {
   1884            aps_Group_t group;
   1885            aps_Group_t *pGroup;
   1886            uint8 *pData;
   1887            uint8 status;
   1888            uint8 grpCnt;
   1889            uint8 grpRspCnt = 0;
   1890            uint16 *grpList;
   1891            uint16 identifyTime = 0;
   1892            uint8 i;
   1893            ZStatus_t stat = ZSuccess;
   1894          
   1895            zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1896          
   1897            pData = pInMsg->pData;
   1898            group.ID = BUILD_UINT16( pData[0], pData[1] );
   1899            switch ( pInMsg->hdr.commandID )
   1900            {
   1901              case COMMAND_GROUP_ADD:
   1902                status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1903                if ( status != ZSuccess )
   1904                {
   1905                  if ( status == ZApsDuplicateEntry )
   1906                    status = ZCL_STATUS_DUPLICATE_EXISTS;
   1907                  else
   1908                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   1909                }
   1910                if ( UNICAST_MSG( pInMsg->msg ) )
   1911                {
   1912                  zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1913                                                   status, group.ID, true, pInMsg->hdr.transSeqNum );
   1914                  stat = ZCL_STATUS_CMD_HAS_RSP;
   1915                }
   1916                break;
   1917          
   1918              case COMMAND_GROUP_VIEW:
   1919                if ( UNICAST_MSG( pInMsg->msg ) )
   1920                {
   1921                  pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
   1922                  if ( pGroup )
   1923                  {
   1924                    status = ZCL_STATUS_SUCCESS;
   1925                  }
   1926                  else
   1927                  {
   1928                    // Group not found
   1929                    status = ZCL_STATUS_NOT_FOUND;
   1930                    pGroup = &group;
   1931                  }
   1932                  zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1933                                                    status, pGroup, true, pInMsg->hdr.transSeqNum );
   1934                  stat = ZCL_STATUS_CMD_HAS_RSP;
   1935                }
   1936                break;
   1937          
   1938              case COMMAND_GROUP_GET_MEMBERSHIP:
   1939                if ( UNICAST_MSG( pInMsg->msg ) )
   1940                {
   1941                  grpCnt = *pData++;
   1942          
   1943                  // Allocate space for the group list
   1944                  grpList = zcl_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
   1945                  if ( grpList != NULL )
   1946                  {
   1947                    if ( grpCnt == 0 )
   1948                    {
   1949                      // Find out all the groups of which the endpoint is a member.
   1950                      grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
   1951                    }
   1952                    else
   1953                    {
   1954                      // Find out the groups (in the list) of which the endpoint is a member.
   1955                      for ( i = 0; i < grpCnt; i++ )
   1956                      {
   1957                        group.ID = BUILD_UINT16( pData[0], pData[1] );
   1958                        pData += 2;
   1959          
   1960                        if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
   1961                          grpList[grpRspCnt++] = group.ID;
   1962                      }
   1963                    }
   1964          
   1965                    if ( grpCnt == 0 ||  grpRspCnt != 0 )
   1966                    {
   1967                      zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1968                                                                 aps_GroupsRemaingCapacity(), grpRspCnt,
   1969                                                                 grpList, true, pInMsg->hdr.transSeqNum );
   1970                    }
   1971          
   1972                    zcl_mem_free( grpList );
   1973                  }
   1974                  else
   1975                  {
   1976                    // Couldn't allocate space for the group list -- send a Default Response command back.
   1977                    zclDefaultRspCmd_t defaultRspCmd;
   1978          
   1979                    defaultRspCmd.commandID = pInMsg->hdr.commandID;
   1980                    defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
   1981                    zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   1982                                           pInMsg->msg->clusterId, &defaultRspCmd,
   1983                                           ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
   1984                  }
   1985          
   1986                  stat = ZCL_STATUS_CMD_HAS_RSP;
   1987                }
   1988                break;
   1989          
   1990              case COMMAND_GROUP_REMOVE:
   1991                if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
   1992                {
   1993                  status = ZCL_STATUS_SUCCESS;
   1994                }
   1995                else
   1996                {
   1997                  status = ZCL_STATUS_NOT_FOUND;
   1998                }
   1999          
   2000                if ( UNICAST_MSG( pInMsg->msg ) )
   2001                {
   2002                  zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2003                                                      status, group.ID, true, pInMsg->hdr.transSeqNum );
   2004                  stat = ZCL_STATUS_CMD_HAS_RSP;
   2005                }
   2006                break;
   2007          
   2008              case COMMAND_GROUP_REMOVE_ALL:
   2009                aps_RemoveAllGroup( pInMsg->msg->endPoint );
   2010                break;
   2011          
   2012              case COMMAND_GROUP_ADD_IF_IDENTIFYING:
   2013                // Retrieve Identify Time
   2014                zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
   2015                                  ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
   2016          
   2017                // Is device identifying itself?
   2018                if ( identifyTime > 0 )
   2019                  zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   2020                break;
   2021          
   2022              default:
   2023                stat = ZFailure;
   2024                break;
   2025            }
   2026          
   2027            return ( stat );
   2028          }
   2029          
   2030          /*********************************************************************
   2031           * @fn      zclGeneral_ProcessInGroupsClient
   2032           *
   2033           * @brief   Process in the received Groups Command.
   2034           *
   2035           * @param   pInMsg - pointer to the incoming message
   2036           *
   2037           * @return  ZStatus_t
   2038           */
   2039          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
   2040                                                             zclGeneral_AppCallbacks_t *pCBs )
   2041          {
   2042            aps_Group_t group;
   2043            uint8 *pData = pInMsg->pData;
   2044            uint8 grpCnt;
   2045            uint8 nameLen;
   2046            zclGroupRsp_t rsp;
   2047            uint8 i;
   2048            ZStatus_t stat = ZSuccess;
   2049          
   2050            zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   2051            zcl_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
   2052          
   2053            switch ( pInMsg->hdr.commandID )
   2054            {
   2055              case COMMAND_GROUP_ADD_RSP:
   2056              case COMMAND_GROUP_VIEW_RSP:
   2057              case COMMAND_GROUP_REMOVE_RSP:
   2058                rsp.status = *pData++;
   2059                group.ID = BUILD_UINT16( pData[0], pData[1] );
   2060          
   2061                if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
   2062                {
   2063                  pData += 2;   // Move past ID
   2064                  nameLen = *pData++;
   2065                  if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   2066                    nameLen = (APS_GROUP_NAME_LEN-1);
   2067                  group.name[0] = nameLen;
   2068                  zcl_memcpy( &(group.name[1]), pData, nameLen );
   2069                  rsp.grpName = group.name;
   2070                }
   2071          
   2072                if ( pCBs->pfnGroupRsp )
   2073                {
   2074                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2075                  rsp.cmdID = pInMsg->hdr.commandID;
   2076                  rsp.grpCnt = 1;
   2077                  rsp.grpList = &group.ID;
   2078                  rsp.capacity = 0;
   2079          
   2080                  pCBs->pfnGroupRsp( &rsp );
   2081                }
   2082                break;
   2083          
   2084              case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
   2085                {
   2086                  uint16 *grpList = NULL;
   2087                  rsp.capacity = *pData++;
   2088                  grpCnt = *pData++;
   2089          
   2090                  if ( grpCnt > 0 )
   2091                  {
   2092                    // Allocate space for the group list
   2093                    grpList = zcl_mem_alloc( sizeof( uint16 ) * grpCnt );
   2094                    if ( grpList != NULL )
   2095                    {
   2096                      rsp.grpCnt = grpCnt;
   2097                      for ( i = 0; i < grpCnt; i++ )
   2098                      {
   2099                        grpList[i] = BUILD_UINT16( pData[0], pData[1] );
   2100                        pData += 2;
   2101                      }
   2102                    }
   2103                  }
   2104          
   2105                  if ( pCBs->pfnGroupRsp )
   2106                  {
   2107                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2108                    rsp.cmdID = pInMsg->hdr.commandID;
   2109                    rsp.grpList = grpList;
   2110          
   2111                    pCBs->pfnGroupRsp( &rsp );
   2112                  }
   2113          
   2114                  if ( grpList != NULL )
   2115                  {
   2116                    zcl_mem_free( grpList );
   2117                  }
   2118                }
   2119                break;
   2120          
   2121              default:
   2122                stat = ZFailure;
   2123                break;
   2124            }
   2125          
   2126            return ( stat );
   2127          }
   2128          #endif // ZCL_GROUPS
   2129          
   2130          #if defined( ZCL_SCENES )
   2131          #if !defined ( ZCL_STANDALONE )
   2132          /*********************************************************************
   2133           * @fn      zclGeneral_AddScene
   2134           *
   2135           * @brief   Add a scene for an endpoint
   2136           *
   2137           * @param   endpoint -
   2138           * @param   scene - new scene item
   2139           *
   2140           * @return  ZStatus_t
   2141           */
   2142          ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
   2143          {
   2144            zclGenSceneItem_t *pNewItem;
   2145            zclGenSceneItem_t *pLoop;
   2146          
   2147            // Fill in the new profile list
   2148            pNewItem = zcl_mem_alloc( sizeof( zclGenSceneItem_t ) );
   2149            if ( pNewItem == NULL )
   2150              return ( ZMemError );
   2151          
   2152            // Fill in the plugin record.
   2153            pNewItem->next = (zclGenSceneItem_t *)NULL;
   2154            pNewItem->endpoint = endpoint;
   2155            zcl_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
   2156          
   2157            // Find spot in list
   2158            if (  zclGenSceneTable == NULL )
   2159            {
   2160              zclGenSceneTable = pNewItem;
   2161            }
   2162            else
   2163            {
   2164              // Look for end of list
   2165              pLoop = zclGenSceneTable;
   2166              while ( pLoop->next != NULL )
   2167                pLoop = pLoop->next;
   2168          
   2169              // Put new item at end of list
   2170              pLoop->next = pNewItem;
   2171            }
   2172          
   2173            // Update NV
   2174            zclGeneral_ScenesWriteNV();
   2175          
   2176            return ( ZSuccess );
   2177          }
   2178          #endif // ZCL_STANDALONE
   2179          
   2180          #if !defined ( ZCL_STANDALONE )
   2181          /*********************************************************************
   2182           * @fn      zclGeneral_FindScene
   2183           *
   2184           * @brief   Find a scene with endpoint and sceneID
   2185           *
   2186           * @param   endpoint -
   2187           * @param   groupID - what group the scene belongs to
   2188           * @param   sceneID - ID to look for scene
   2189           *
   2190           * @return  a pointer to the scene information, NULL if not found
   2191           */
   2192          zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   2193          {
   2194            zclGenSceneItem_t *pLoop;
   2195          
   2196            // Look for end of list
   2197            pLoop = zclGenSceneTable;
   2198            while ( pLoop )
   2199            {
   2200              if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
   2201                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   2202              {
   2203                return ( &(pLoop->scene) );
   2204              }
   2205              pLoop = pLoop->next;
   2206            }
   2207          
   2208            return ( (zclGeneral_Scene_t *)NULL );
   2209          }
   2210          #endif // ZCL_STANDALONE
   2211          
   2212          #if !defined ( ZCL_STANDALONE )
   2213          /*********************************************************************
   2214           * @fn      aps_FindAllScensForGroup
   2215           *
   2216           * @brief   Find all the scenes with groupID
   2217           *
   2218           * @param   endpoint - endpoint to look for
   2219           * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
   2220           *
   2221           * @return  number of scenes copied to sceneList
   2222           */
   2223          uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
   2224          {
   2225            zclGenSceneItem_t *pLoop;
   2226            uint8 cnt = 0;
   2227          
   2228            // Look for end of list
   2229            pLoop = zclGenSceneTable;
   2230            while ( pLoop )
   2231            {
   2232              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   2233                sceneList[cnt++] = pLoop->scene.ID;
   2234              pLoop = pLoop->next;
   2235            }
   2236            return ( cnt );
   2237          }
   2238          #endif // ZCL_STANDALONE
   2239          
   2240          #if !defined ( ZCL_STANDALONE )
   2241          /*********************************************************************
   2242           * @fn      zclGeneral_RemoveScene
   2243           *
   2244           * @brief   Remove a scene with endpoint and sceneID
   2245           *
   2246           * @param   endpoint -
   2247           * @param   groupID - what group the scene belongs to
   2248           * @param   sceneID - ID to look for scene
   2249           *
   2250           * @return  TRUE if removed, FALSE if not found
   2251           */
   2252          uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   2253          {
   2254            zclGenSceneItem_t *pLoop;
   2255            zclGenSceneItem_t *pPrev;
   2256          
   2257            // Look for end of list
   2258            pLoop = zclGenSceneTable;
   2259            pPrev = NULL;
   2260            while ( pLoop )
   2261            {
   2262              if ( pLoop->endpoint == endpoint
   2263                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   2264              {
   2265                if ( pPrev == NULL )
   2266                  zclGenSceneTable = pLoop->next;
   2267                else
   2268                  pPrev->next = pLoop->next;
   2269          
   2270                // Free the memory
   2271                zcl_mem_free( pLoop );
   2272          
   2273                // Update NV
   2274                zclGeneral_ScenesWriteNV();
   2275          
   2276                return ( TRUE );
   2277              }
   2278              pPrev = pLoop;
   2279              pLoop = pLoop->next;
   2280            }
   2281          
   2282            return ( FALSE );
   2283          }
   2284          #endif // ZCL_STANDALONE
   2285          
   2286          #if !defined ( ZCL_STANDALONE )
   2287          /*********************************************************************
   2288           * @fn      zclGeneral_RemoveAllScenes
   2289           *
   2290           * @brief   Remove all scenes with endpoint and group Id
   2291           *
   2292           * @param   endpoint -
   2293           * @param   groupID - ID to look for group
   2294           *
   2295           * @return  none
   2296           */
   2297          void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
   2298          {
   2299            zclGenSceneItem_t *pLoop;
   2300            zclGenSceneItem_t *pPrev;
   2301            zclGenSceneItem_t *pNext;
   2302          
   2303            // Look for end of list
   2304            pLoop = zclGenSceneTable;
   2305            pPrev = NULL;
   2306            while ( pLoop )
   2307            {
   2308              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   2309              {
   2310                if ( pPrev == NULL )
   2311                  zclGenSceneTable = pLoop->next;
   2312                else
   2313                  pPrev->next = pLoop->next;
   2314                pNext = pLoop->next;
   2315          
   2316                // Free the memory
   2317                zcl_mem_free( pLoop );
   2318                pLoop = pNext;
   2319              }
   2320              else
   2321              {
   2322                pPrev = pLoop;
   2323                pLoop = pLoop->next;
   2324              }
   2325            }
   2326          
   2327            // Update NV
   2328            zclGeneral_ScenesWriteNV();
   2329          }
   2330          #endif // ZCL_STANDALONE
   2331          
   2332          #if !defined ( ZCL_STANDALONE )
   2333          /*********************************************************************
   2334           * @fn      zclGeneral_CountScenes
   2335           *
   2336           * @brief   Count the number of scenes for an endpoint
   2337           *
   2338           * @param   endpoint -
   2339           *
   2340           * @return  number of scenes assigned to an endpoint
   2341           */
   2342          uint8 zclGeneral_CountScenes( uint8 endpoint )
   2343          {
   2344            zclGenSceneItem_t *pLoop;
   2345            uint8 cnt = 0;
   2346          
   2347            // Look for end of list
   2348            pLoop = zclGenSceneTable;
   2349            while ( pLoop )
   2350            {
   2351              if ( pLoop->endpoint == endpoint  )
   2352                cnt++;
   2353              pLoop = pLoop->next;
   2354            }
   2355            return ( cnt );
   2356          }
   2357          #endif
   2358          
   2359          #if !defined ( ZCL_STANDALONE )
   2360          /*********************************************************************
   2361           * @fn      zclGeneral_CountAllScenes
   2362           *
   2363           * @brief   Count the total number of scenes
   2364           *
   2365           * @param   none
   2366           *
   2367           * @return  number of scenes
   2368           */
   2369          uint8 zclGeneral_CountAllScenes( void )
   2370          {
   2371            zclGenSceneItem_t *pLoop;
   2372            uint8 cnt = 0;
   2373          
   2374            // Look for end of list
   2375            pLoop = zclGenSceneTable;
   2376            while ( pLoop )
   2377            {
   2378              cnt++;
   2379              pLoop = pLoop->next;
   2380            }
   2381            return ( cnt );
   2382          }
   2383          #endif // ZCL_STANDALONE
   2384          
   2385          /*********************************************************************
   2386           * @fn      zclGeneral_ReadSceneCountCB
   2387           *
   2388           * @brief   Read the number of scenes currently in the device's
   2389           *          scene table (i.e., the Scene Count attribute).
   2390           *
   2391           *          Note: This function gets called only when the pointer
   2392           *                'dataPtr' to the Scene Count attribute value is
   2393           *                NULL in the attribute database registered with
   2394           *                the ZCL.
   2395           *
   2396           * @param   clusterId - cluster that attribute belongs to
   2397           * @param   attrId - attribute to be read or written
   2398           * @param   oper - ZCL_OPER_LEN, ZCL_OPER_READ, or ZCL_OPER_WRITE
   2399           * @param   pValue - pointer to attribute value
   2400           * @param   pLen - pointer to length of attribute value read
   2401           *
   2402           * @return  status
   2403           */
   2404          ZStatus_t zclGeneral_ReadSceneCountCB( uint16 clusterId, uint16 attrId,
   2405                                                 uint8 oper, uint8 *pValue, uint16 *pLen )
   2406          {
   2407            ZStatus_t status = ZCL_STATUS_SUCCESS;
   2408          
   2409            // This callback function should only be called for the Scene Count attribute
   2410            switch ( oper )
   2411            {
   2412              case ZCL_OPER_LEN:
   2413                *pLen = 1; // uint8
   2414                break;
   2415          
   2416              case ZCL_OPER_READ:
   2417                *pValue = zclGeneral_CountAllScenes();
   2418          
   2419                if ( pLen != NULL )
   2420                {
   2421                  *pLen = 1;
   2422                }
   2423                break;
   2424          
   2425              case ZCL_OPER_WRITE:
   2426                // Fall through
   2427          
   2428              default:
   2429                status = ZCL_STATUS_SOFTWARE_FAILURE; // should never get here!
   2430                break;
   2431            }
   2432          
   2433            return ( status );
   2434          }
   2435          
   2436          /*********************************************************************
   2437           * @fn      zclGeneral_ProcessInScenesServer
   2438           *
   2439           * @brief   Process in the received Scenes Command.
   2440           *
   2441           * @param   pInMsg - pointer to the incoming message
   2442           *
   2443           * @return  ZStatus_t
   2444           */
   2445          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
   2446                                                             zclGeneral_AppCallbacks_t *pCBs )
   2447          {
   2448            zclGeneral_Scene_t scene;
   2449            zclGeneral_Scene_t *pScene;
   2450            uint8 *pData = pInMsg->pData;
   2451            uint8 nameLen;
   2452            uint8 status;
   2453            uint8 sceneCnt = 0;
   2454            uint8 *sceneList = NULL;
   2455            uint8 sendRsp = TRUE;
   2456            uint8 nameSupport = FALSE;
   2457            ZStatus_t stat = ZSuccess;
   2458          
   2459            zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2460          
   2461            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2462            pData += 2;   // Move past group ID
   2463            scene.ID = *pData++;
   2464          
   2465            switch ( pInMsg->hdr.commandID )
   2466            {
   2467              case COMMAND_SCENE_ADD:
   2468          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2469              case COMMAND_SCENE_ENHANCED_ADD:
   2470          #endif // ZCL_LIGHT_LINK_ENHANCE
   2471                // Parse the rest of the incoming message
   2472                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2473                pData += 2;
   2474          
   2475                if ( pInMsg->hdr.commandID == COMMAND_SCENE_ENHANCED_ADD )
   2476                {
   2477                  // Received transition time is in 1/10 second
   2478                  scene.transTime100ms = scene.transTime % 10;
   2479                  scene.transTime /= 10;
   2480                }
   2481          
   2482                nameLen= *pData++; // Name length
   2483          
   2484                // Retrieve Name Support attribute
   2485                zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES,
   2486                                  ATTRID_SCENES_NAME_SUPPORT, &nameSupport, NULL );
   2487          
   2488                if ( nameSupport )
   2489                {
   2490                  if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2491                    nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2492                  scene.name[0] = nameLen;
   2493                  zcl_memcpy( &(scene.name[1]), pData, nameLen );
   2494                }
   2495          
   2496                pData += nameLen; // move past name, use original length
   2497          
   2498                scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
   2499                if ( scene.extLen > 0 )
   2500                {
   2501                  // Copy the extention field(s)
   2502                  if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
   2503                  {
   2504                    scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
   2505                  }
   2506                  zcl_memcpy( scene.extField, pData, scene.extLen );
   2507                }
   2508          
   2509                if ( scene.groupID == 0x0000 ||
   2510                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2511                {
   2512                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2513                  // does and the corresponding Group exits
   2514                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2515                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2516                  {
   2517                    status = ZCL_STATUS_SUCCESS;
   2518                    if ( pScene != NULL )
   2519                    {
   2520                      // The Scene already exists so update it
   2521                      pScene->transTime = scene.transTime;
   2522                      zcl_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
   2523          
   2524                      // Use the new extention field(s)
   2525                      zcl_memcpy( pScene->extField, scene.extField, scene.extLen );
   2526                      pScene->extLen = scene.extLen;
   2527          
   2528                      // Save Scenes
   2529                      zclGeneral_ScenesSave();
   2530                    }
   2531                    else
   2532                    {
   2533                      // The Scene doesn't exist so add it
   2534                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2535                    }
   2536                  }
   2537                  else
   2538                  {
   2539                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2540                  }
   2541                }
   2542                else
   2543                {
   2544                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2545                }
   2546          
   2547                if ( UNICAST_MSG( pInMsg->msg ) )
   2548                {
   2549                  if ( pInMsg->hdr.commandID == COMMAND_SCENE_ADD )
   2550                  {
   2551                    zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2552                                                    status, scene.groupID, scene.ID,
   2553                                                    true, pInMsg->hdr.transSeqNum );
   2554                  }
   2555          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2556                  else // COMMAND_SCENE_ENHANCED_ADD
   2557                  {
   2558                    zclGeneral_SendSceneEnhancedAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2559                                                            status, scene.groupID, scene.ID,
   2560                                                            true, pInMsg->hdr.transSeqNum );
   2561                  }
   2562          #endif // ZCL_LIGHT_LINK_ENHANCE
   2563                }
   2564                stat = ZCL_STATUS_CMD_HAS_RSP;
   2565          
   2566                break;
   2567          
   2568              case COMMAND_SCENE_VIEW:
   2569          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2570              case COMMAND_SCENE_ENHANCED_VIEW:
   2571          #endif // ZCL_LIGHT_LINK_ENHANCE
   2572                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2573                if ( pScene != NULL )
   2574                {
   2575                  status = ZCL_STATUS_SUCCESS;
   2576                }
   2577                else
   2578                {
   2579                  // Scene not found
   2580                  if ( scene.groupID != 0x0000 &&
   2581                       aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2582                  {
   2583                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2584                  }
   2585                  else
   2586                  {
   2587                    status = ZCL_STATUS_NOT_FOUND;
   2588                  }
   2589                  pScene = &scene;
   2590                }
   2591          
   2592                if ( UNICAST_MSG( pInMsg->msg ) )
   2593                {
   2594                  if ( pInMsg->hdr.commandID == COMMAND_SCENE_VIEW )
   2595                  {
   2596                    zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2597                                                     status, pScene, true, pInMsg->hdr.transSeqNum );
   2598                  }
   2599          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2600                  else
   2601                  {
   2602                    zclGeneral_SendSceneEnhancedViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2603                                                             status, pScene, true, pInMsg->hdr.transSeqNum );
   2604                  }
   2605          #endif // ZCL_LIGHT_LINK_ENHANCE
   2606                }
   2607                stat = ZCL_STATUS_CMD_HAS_RSP;
   2608                break;
   2609          
   2610              case COMMAND_SCENE_REMOVE:
   2611                if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
   2612                {
   2613                  status = ZCL_STATUS_SUCCESS;
   2614                }
   2615                else
   2616                {
   2617                  // Scene not found
   2618                  if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2619                  {
   2620                    // The Group is not in the Group Table
   2621                    status = ZCL_STATUS_INVALID_FIELD;
   2622                  }
   2623                  else
   2624                  {
   2625                    status = ZCL_STATUS_NOT_FOUND;
   2626                  }
   2627                }
   2628          
   2629                if ( UNICAST_MSG( pInMsg->msg ) )
   2630                {
   2631                  // Addressed to this device (not to a group) - send a response back
   2632                  zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2633                                                      status, scene.groupID,
   2634                                                      scene.ID, true, pInMsg->hdr.transSeqNum );
   2635                }
   2636                stat = ZCL_STATUS_CMD_HAS_RSP;
   2637                break;
   2638          
   2639              case COMMAND_SCENE_REMOVE_ALL:
   2640                if ( scene.groupID == 0x0000 ||
   2641                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2642                {
   2643                  zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
   2644                  status = ZCL_STATUS_SUCCESS;
   2645                }
   2646                else
   2647                {
   2648                  status = ZCL_STATUS_INVALID_FIELD;
   2649                }
   2650          
   2651                if ( UNICAST_MSG( pInMsg->msg ) )
   2652                {
   2653                  // Addressed to this device (not to a group) - send a response back
   2654                  zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2655                                                         status, scene.groupID, true, pInMsg->hdr.transSeqNum );
   2656                }
   2657                stat = ZCL_STATUS_CMD_HAS_RSP;
   2658                break;
   2659          
   2660              case COMMAND_SCENE_STORE:
   2661                if ( scene.groupID == 0x0000 ||
   2662                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2663                {
   2664                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2665                  // does and the corresponding Group exits
   2666                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2667                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2668                  {
   2669                    uint8 sceneChanged = FALSE;
   2670          
   2671                    status = ZCL_STATUS_SUCCESS;
   2672                    if ( pScene == NULL )
   2673                    {
   2674                      // Haven't been added yet
   2675                      pScene = &scene;
   2676                    }
   2677          
   2678                    if ( pCBs->pfnSceneStoreReq )
   2679                    {
   2680                      zclSceneReq_t req;
   2681          
   2682                      req.srcAddr = &(pInMsg->msg->srcAddr);
   2683                      req.scene = pScene;
   2684          
   2685                      // Get the latest Scene info
   2686                      if ( pCBs->pfnSceneStoreReq( &req ) )
   2687                      {
   2688                        sceneChanged = TRUE;
   2689                      }
   2690                    }
   2691          
   2692                    if ( pScene == &scene )
   2693                    {
   2694                      // The Scene doesn't exist so add it
   2695                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2696                    }
   2697                    else if ( sceneChanged )
   2698                    {
   2699                      // The Scene already exists so update only NV
   2700                      zclGeneral_ScenesSave();
   2701                    }
   2702                  }
   2703                  else
   2704                  {
   2705                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2706                  }
   2707                }
   2708                else
   2709                {
   2710                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2711                }
   2712          
   2713                if ( UNICAST_MSG( pInMsg->msg ) )
   2714                {
   2715                  // Addressed to this device (not to a group) - send a response back
   2716                  zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2717                                                     status, scene.groupID, scene.ID,
   2718                                                     true, pInMsg->hdr.transSeqNum );
   2719                }
   2720                stat = ZCL_STATUS_CMD_HAS_RSP;
   2721                break;
   2722          
   2723              case COMMAND_SCENE_RECALL:
   2724                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2725                if ( pScene && pCBs->pfnSceneRecallReq )
   2726                {
   2727                  zclSceneReq_t req;
   2728          
   2729                  req.srcAddr = &(pInMsg->msg->srcAddr);
   2730                  req.scene = pScene;
   2731          
   2732                  pCBs->pfnSceneRecallReq( &req );
   2733                }
   2734                // No response
   2735                break;
   2736          
   2737              case COMMAND_SCENE_GET_MEMBERSHIP:
   2738                // Find all the Scenes corresponding to the Group ID
   2739                if ( scene.groupID == 0x0000 ||
   2740                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2741                {
   2742                  // Allocate space for the scene list
   2743                  sceneList = zcl_mem_alloc( ZCL_GEN_MAX_SCENES );
   2744                  if ( sceneList != NULL )
   2745                  {
   2746                    sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2747                                                                 scene.groupID, sceneList );
   2748                    status = ZCL_STATUS_SUCCESS;
   2749                    if ( ! UNICAST_MSG( pInMsg->msg ) )
   2750                    {
   2751                      // Addressed to the Group - ONLY send a response if an entry within the
   2752                      // Scene Table corresponds to the Group ID
   2753                      if ( sceneCnt == 0 )
   2754                      {
   2755                        sendRsp = FALSE;
   2756                      }
   2757                    }
   2758                  }
   2759                  else
   2760                  {
   2761                    // Couldn't allocate space for the scene list!
   2762                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   2763                  }
   2764                }
   2765                else
   2766                {
   2767                  // The Group is not in the Group Table - send a response back
   2768                  status = ZCL_STATUS_INVALID_FIELD;
   2769                }
   2770          
   2771          #ifdef ZCL_LIGHT_LINK_ENHANCE //ZLL allows response to unicast only
   2772                if ( sendRsp && UNICAST_MSG( pInMsg->msg ) )
   2773          #else
   2774                if ( sendRsp )
   2775          #endif //ZCL_LIGHT_LINK_ENHANCE
   2776                {
   2777                  zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2778                                              status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
   2779                                              scene.groupID, true, pInMsg->hdr.transSeqNum );
   2780                }
   2781          
   2782                if ( sceneList != NULL )
   2783                  zcl_mem_free( sceneList );
   2784          
   2785                stat = ZCL_STATUS_CMD_HAS_RSP;
   2786                break;
   2787          
   2788          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2789              case COMMAND_SCENE_COPY:
   2790                {
   2791                  uint8 mode;
   2792                  uint16 groupIDFrom, groupIDTo;
   2793                  uint8 sceneIDFrom, sceneIDTo;
   2794          
   2795                  pData = pInMsg->pData; // different payload format
   2796          
   2797                  mode = *pData++;
   2798                  groupIDFrom = BUILD_UINT16( pData[0], pData[1] ); // from group ID
   2799                  pData += 2;
   2800                  sceneIDFrom = *pData++; // from scene ID
   2801                  groupIDTo = BUILD_UINT16( pData[0], pData[1] ); // to group ID
   2802                  pData += 2;
   2803                  if ( (mode & SCENE_COPY_MODE_ALL_BIT) == 0 )
   2804                  {
   2805                    sceneIDTo = *pData++; // to scene ID
   2806                  }
   2807          
   2808                  // Make sure the groups exist
   2809                  if ( ( aps_FindGroup( pInMsg->msg->endPoint, groupIDFrom ) != NULL ) &&
   2810                       ( aps_FindGroup( pInMsg->msg->endPoint, groupIDTo ) != NULL ) )
   2811                  {
   2812                    // Allocate space for the scene list
   2813                    sceneList = zcl_mem_alloc( (mode & SCENE_COPY_MODE_ALL_BIT) ? ZCL_GEN_MAX_SCENES : 1 );
   2814                    if ( sceneList == NULL )
   2815                    {
   2816                      status = ZCL_STATUS_INSUFFICIENT_SPACE; // Couldn't allocate space for the scene list!
   2817                    }
   2818                    else
   2819                    {
   2820                      status = ZCL_STATUS_SUCCESS;
   2821                      if ( mode & SCENE_COPY_MODE_ALL_BIT ) // Copy all scenes
   2822                      {
   2823                        sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2824                                                                     groupIDFrom, sceneList );
   2825                      }
   2826                      else // Copy single scene
   2827                      {
   2828                        // Make sure the scene exists
   2829                        pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneIDFrom );
   2830                        if ( pScene != NULL )
   2831                        {
   2832                          sceneList[0] = sceneIDFrom;
   2833                          sceneCnt = 1;
   2834                        }
   2835                        else
   2836                        {
   2837                          status = ZCL_STATUS_INVALID_FIELD; // Scene not found
   2838                        }
   2839                      }
   2840                    }
   2841          
   2842                    if ( status == ZCL_STATUS_SUCCESS )
   2843                    {
   2844                      uint8 numScenesToAdd = 0;
   2845                      uint8 i;
   2846                      for ( i = 0; i < sceneCnt; i++ )
   2847                      {
   2848                        if ( zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, sceneList[i] ) == NULL )
   2849                        {
   2850                          numScenesToAdd++;
   2851                        }
   2852                      }
   2853                      if ( zclGeneral_ScenesRemaingCapacity() >= numScenesToAdd )
   2854                      {
   2855                        // Copy the scenes
   2856                        for ( i = 0; i < sceneCnt; i++ )
   2857                        {
   2858                          // Ignore scene ID from and scene ID to fields
   2859                          pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneList[i] );
   2860                          if ( pScene != NULL )
   2861                          {
   2862                            zclGeneral_Scene_t *pToScene;
   2863                            scene = *pScene;
   2864                            scene.groupID = groupIDTo;
   2865                            scene.ID = ( (mode & SCENE_COPY_MODE_ALL_BIT) ? sceneList[i] : sceneIDTo );
   2866          
   2867                            pToScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
   2868                            if( pToScene != NULL )
   2869                            {
   2870                              zclGeneral_RemoveScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
   2871                            }
   2872                            // Add the scene
   2873                            zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2874                          }
   2875                        }
   2876                      }
   2877                      else
   2878                      {
   2879                        status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2880                      }
   2881                    }
   2882                  }
   2883                  else
   2884                  {
   2885                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2886                  }
   2887          
   2888                  if ( UNICAST_MSG( pInMsg->msg ) )
   2889                  {
   2890                    if ( pScene == NULL )
   2891                    {
   2892                      pScene = &scene;
   2893                    }
   2894                    // Addressed to this device (not to a group) - send a response back
   2895                    zclGeneral_SendSceneCopyResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2896                                                      status, pScene->groupID, pScene->ID,
   2897                                                      true, pInMsg->hdr.transSeqNum );
   2898                  }
   2899          
   2900                  if ( sceneList != NULL )
   2901                  {
   2902                    zcl_mem_free( sceneList );
   2903                  }
   2904                }
   2905          
   2906                stat = ZCL_STATUS_CMD_HAS_RSP;
   2907                break;
   2908          #endif // ZCL_LIGHT_LINK_ENHANCE
   2909          
   2910              default:
   2911                stat = ZFailure;
   2912              break;
   2913            }
   2914          
   2915            return ( stat );
   2916          }
   2917          
   2918          /*********************************************************************
   2919           * @fn      zclGeneral_ProcessInScenesClient
   2920           *
   2921           * @brief   Process in the received Scenes Command.
   2922           *
   2923           * @param   pInMsg - pointer to the incoming message
   2924           *
   2925           * @return  ZStatus_t
   2926           */
   2927          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
   2928                                                             zclGeneral_AppCallbacks_t *pCBs )
   2929          {
   2930            zclGeneral_Scene_t scene;
   2931            uint8 *pData = pInMsg->pData;
   2932            uint8 nameLen;
   2933            zclSceneRsp_t rsp;
   2934            uint8 i;
   2935            ZStatus_t stat = ZSuccess;
   2936          
   2937            zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2938            zcl_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
   2939          
   2940            // Get the status field first
   2941            rsp.status = *pData++;
   2942          
   2943            if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
   2944            {
   2945              rsp.capacity = *pData++;
   2946            }
   2947          
   2948            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2949            pData += 2;   // Move past group ID
   2950          
   2951            switch ( pInMsg->hdr.commandID )
   2952            {
   2953              case COMMAND_SCENE_VIEW_RSP:
   2954                // Parse the rest of the incoming message
   2955                scene.ID = *pData++; // Not applicable to Remove All Response command
   2956                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2957                pData += 2;
   2958                nameLen = *pData++; // Name length
   2959                if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2960                  nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2961          
   2962                scene.name[0] = nameLen;
   2963                zcl_memcpy( &(scene.name[1]), pData, nameLen );
   2964          
   2965                pData += nameLen; // move past name, use original length
   2966          
   2967                //*** Do something with the extension field(s)
   2968          
   2969                // Fall through to callback - break is left off intentionally
   2970          
   2971              case COMMAND_SCENE_ADD_RSP:
   2972              case COMMAND_SCENE_REMOVE_RSP:
   2973              case COMMAND_SCENE_REMOVE_ALL_RSP:
   2974              case COMMAND_SCENE_STORE_RSP:
   2975                if ( pCBs->pfnSceneRsp )
   2976                {
   2977                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2978                  rsp.cmdID = pInMsg->hdr.commandID;
   2979                  rsp.scene = &scene;
   2980          
   2981                  pCBs->pfnSceneRsp( &rsp );
   2982                }
   2983                break;
   2984          
   2985              case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
   2986                {
   2987                  uint8 *sceneList = NULL;
   2988          
   2989                  if ( rsp.status == ZCL_STATUS_SUCCESS )
   2990                  {
   2991                    uint8 sceneCnt = *pData++;
   2992          
   2993                    if ( sceneCnt > 0 )
   2994                    {
   2995                      // Allocate space for the scene list
   2996                      sceneList = zcl_mem_alloc( sceneCnt );
   2997                      if ( sceneList != NULL )
   2998                      {
   2999                        rsp.sceneCnt = sceneCnt;
   3000                        for ( i = 0; i < sceneCnt; i++ )
   3001                          sceneList[i] = *pData++;
   3002                      }
   3003                    }
   3004                  }
   3005          
   3006                  if ( pCBs->pfnSceneRsp )
   3007                  {
   3008                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3009                    rsp.cmdID = pInMsg->hdr.commandID;
   3010                    rsp.sceneList = sceneList;
   3011                    rsp.scene = &scene;
   3012          
   3013                    pCBs->pfnSceneRsp( &rsp);
   3014                  }
   3015          
   3016                  if ( sceneList != NULL )
   3017                  {
   3018                    zcl_mem_free( sceneList );
   3019                  }
   3020                }
   3021                break;
   3022          
   3023              default:
   3024                stat = ZFailure;
   3025                break;
   3026            }
   3027          
   3028            return ( stat );
   3029          }
   3030          #endif // ZCL_SCENES
   3031          
   3032          #ifdef ZCL_ON_OFF
   3033          /*********************************************************************
   3034           * @fn      zclGeneral_ProcessInCmdOnOff
   3035           *
   3036           * @brief   Process in the received On/Off Command.
   3037           *
   3038           * @param   pInMsg - pointer to the incoming message
   3039           *
   3040           * @return  ZStatus_t
   3041           */
   3042          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
   3043                                                      zclGeneral_AppCallbacks_t *pCBs )
   3044          {
   3045            ZStatus_t stat = ZSuccess;
   3046          
   3047            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   3048            {
   3049              switch ( pInMsg->hdr.commandID )
   3050              {
   3051                case COMMAND_OFF:
   3052                case COMMAND_ON:
   3053                case COMMAND_TOGGLE:
   3054                  if ( pCBs->pfnOnOff )
   3055                  {
   3056                    pCBs->pfnOnOff( pInMsg->hdr.commandID );
   3057                  }
   3058                  break;
   3059          
   3060          #ifdef ZCL_LIGHT_LINK_ENHANCE
   3061                case COMMAND_OFF_WITH_EFFECT:
   3062                  if ( pCBs->pfnOnOff_OffWithEffect )
   3063                  {
   3064                    zclOffWithEffect_t cmd;
   3065          
   3066                    cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3067                    cmd.effectId = pInMsg->pData[0];
   3068                    cmd.effectVariant = pInMsg->pData[1];
   3069          
   3070                    pCBs->pfnOnOff_OffWithEffect( &cmd );
   3071                  }
   3072                  break;
   3073          
   3074                case COMMAND_ON_WITH_RECALL_GLOBAL_SCENE:
   3075                  if ( pCBs->pfnOnOff_OnWithRecallGlobalScene )
   3076                  {
   3077                    pCBs->pfnOnOff_OnWithRecallGlobalScene();
   3078                  }
   3079                  break;
   3080          
   3081                case COMMAND_ON_WITH_TIMED_OFF:
   3082                  if ( pCBs->pfnOnOff_OnWithTimedOff )
   3083                  {
   3084                    zclOnWithTimedOff_t cmd;
   3085          
   3086                    cmd.onOffCtrl.byte = pInMsg->pData[0];
   3087                    cmd.onTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   3088                    cmd.offWaitTime = BUILD_UINT16( pInMsg->pData[3], pInMsg->pData[4] );
   3089                    pCBs->pfnOnOff_OnWithTimedOff( &cmd );
   3090                  }
   3091                  break;
   3092          #endif // ZCL_LIGHT_LINK_ENHANCE
   3093          
   3094                default:
   3095                  stat = ZFailure;
   3096                  break;
   3097              }
   3098            }
   3099            // no Client command
   3100          
   3101            return ( stat );
   3102          }
   3103          #endif // ZCL_ON_OFF
   3104          
   3105          #ifdef ZCL_LEVEL_CTRL
   3106          /*********************************************************************
   3107           * @fn      zclGeneral_ProcessInLevelControl
   3108           *
   3109           * @brief   Process in the received Level Control Command.
   3110           *
   3111           * @param   pInMsg - pointer to the incoming message
   3112           *
   3113           * @return  ZStatus_t
   3114           */
   3115          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
   3116                                                             zclGeneral_AppCallbacks_t *pCBs )
   3117          {
   3118            uint8 withOnOff = FALSE;
   3119            ZStatus_t stat = ZSuccess;
   3120          
   3121            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   3122            {
   3123              switch ( pInMsg->hdr.commandID )
   3124              {
   3125                case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
   3126                  withOnOff = TRUE;
   3127                  // fall through
   3128                case COMMAND_LEVEL_MOVE_TO_LEVEL:
   3129                  if ( pCBs->pfnLevelControlMoveToLevel )
   3130                  {
   3131                    zclLCMoveToLevel_t cmd;
   3132          
   3133                    cmd.level = pInMsg->pData[0];
   3134                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   3135                    cmd.withOnOff = withOnOff;
   3136          
   3137                    pCBs->pfnLevelControlMoveToLevel( &cmd );
   3138                  }
   3139                  break;
   3140          
   3141                case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
   3142                  withOnOff = TRUE;
   3143                  // fall through
   3144                case COMMAND_LEVEL_MOVE:
   3145                  if ( pCBs->pfnLevelControlMove )
   3146                  {
   3147                    zclLCMove_t cmd;
   3148          
   3149                    cmd.moveMode = pInMsg->pData[0];
   3150                    cmd.rate = pInMsg->pData[1];
   3151                    cmd.withOnOff = withOnOff;
   3152          
   3153                    pCBs->pfnLevelControlMove( &cmd );
   3154                  }
   3155                  break;
   3156          
   3157                case COMMAND_LEVEL_STEP_WITH_ON_OFF:
   3158                  withOnOff = TRUE;
   3159                  // fall through
   3160                case COMMAND_LEVEL_STEP:
   3161                  if ( pCBs->pfnLevelControlStep )
   3162                  {
   3163                    zclLCStep_t cmd;
   3164          
   3165                    cmd.stepMode = pInMsg->pData[0];
   3166                    cmd.amount =  pInMsg->pData[1];
   3167                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   3168                    cmd.withOnOff = withOnOff;
   3169          
   3170                    pCBs->pfnLevelControlStep( &cmd );
   3171                  }
   3172                  break;
   3173          
   3174                case COMMAND_LEVEL_STOP:
   3175                case COMMAND_LEVEL_STOP_WITH_ON_OFF:
   3176                  // Both Stop commands are identical
   3177                  if ( pCBs->pfnLevelControlStop )
   3178                  {
   3179                    pCBs->pfnLevelControlStop();
   3180                  }
   3181                  break;
   3182          
   3183                default:
   3184                  stat = ZFailure;
   3185                  break;
   3186              }
   3187            }
   3188            // no Client command
   3189          
   3190            return ( stat );
   3191          }
   3192          #endif // ZCL_LEVEL_CTRL
   3193          
   3194          #ifdef ZCL_ALARMS
   3195          /*********************************************************************
   3196           * @fn      zclGeneral_AddAlarm
   3197           *
   3198           * @brief   Add an alarm for a cluster
   3199           *
   3200           * @param   endpoint -
   3201           * @param   alarm - new alarm item
   3202           *
   3203           * @return  ZStatus_t
   3204           */
   3205          ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
   3206          {
   3207            zclGenAlarmItem_t *pNewItem;
   3208            zclGenAlarmItem_t *pLoop;
   3209          
   3210            // Fill in the new profile list
   3211            pNewItem = zcl_mem_alloc( sizeof( zclGenAlarmItem_t ) );
   3212            if ( pNewItem == NULL )
   3213              return ( ZMemError );
   3214          
   3215            // Fill in the plugin record.
   3216            pNewItem->next = (zclGenAlarmItem_t *)NULL;
   3217            pNewItem->endpoint =  endpoint;
   3218            zcl_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
   3219          
   3220            // Find spot in list
   3221            if (  zclGenAlarmTable == NULL )
   3222            {
   3223              zclGenAlarmTable = pNewItem;
   3224            }
   3225            else
   3226            {
   3227              // Look for end of list
   3228              pLoop = zclGenAlarmTable;
   3229              while ( pLoop->next != NULL )
   3230                pLoop = pLoop->next;
   3231          
   3232              // Put new item at end of list
   3233              pLoop->next = pNewItem;
   3234            }
   3235          
   3236            return ( ZSuccess );
   3237          }
   3238          
   3239          /*********************************************************************
   3240           * @fn      zclGeneral_FindAlarm
   3241           *
   3242           * @brief   Find an alarm with alarmCode and clusterID
   3243           *
   3244           * @param   endpoint -
   3245           * @param   groupID - what group the scene belongs to
   3246           * @param   sceneID - ID to look for scene
   3247           *
   3248           * @return  a pointer to the alarm information, NULL if not found
   3249           */
   3250          zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   3251          {
   3252            zclGenAlarmItem_t *pLoop;
   3253          
   3254            // Look for the alarm
   3255            pLoop = zclGenAlarmTable;
   3256            while ( pLoop )
   3257            {
   3258              if ( pLoop->endpoint == endpoint &&
   3259                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   3260              {
   3261                return ( &(pLoop->alarm) );
   3262              }
   3263              pLoop = pLoop->next;
   3264            }
   3265          
   3266            return ( (zclGeneral_Alarm_t *)NULL );
   3267          }
   3268          
   3269          /*********************************************************************
   3270           * @fn      zclGeneral_FindEarliestAlarm
   3271           *
   3272           * @brief   Find an alarm with the earliest timestamp
   3273           *
   3274           * @param   endpoint -
   3275           *
   3276           * @return  a pointer to the alarm information, NULL if not found
   3277           */
   3278          zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
   3279          {
   3280            zclGenAlarmItem_t *pLoop;
   3281            zclGenAlarmItem_t earliestAlarm;
   3282            zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
   3283          
   3284            pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
   3285          
   3286            // Look for alarm with earliest time
   3287            pLoop = zclGenAlarmTable;
   3288            while ( pLoop )
   3289            {
   3290              if ( pLoop->endpoint == endpoint &&
   3291                   pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
   3292              {
   3293                pEarliestAlarm = pLoop;
   3294              }
   3295              pLoop = pLoop->next;
   3296            }
   3297          
   3298            if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
   3299              return ( &(pEarliestAlarm->alarm) );
   3300          
   3301            // No alarm
   3302            return ( (zclGeneral_Alarm_t *)NULL );
   3303          }
   3304          
   3305          /*********************************************************************
   3306           * @fn      zclGeneral_ResetAlarm
   3307           *
   3308           * @brief   Remove a scene with endpoint and sceneID
   3309           *
   3310           * @param   endpoint -
   3311           * @param   alarmCode -
   3312           * @param   clusterID -
   3313           *
   3314           * @return  TRUE if removed, FALSE if not found
   3315           */
   3316          void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   3317          {
   3318            zclGenAlarmItem_t *pLoop;
   3319            zclGenAlarmItem_t *pPrev;
   3320          
   3321            // Look for end of list
   3322            pLoop = zclGenAlarmTable;
   3323            pPrev = NULL;
   3324            while ( pLoop )
   3325            {
   3326              if ( pLoop->endpoint == endpoint &&
   3327                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   3328              {
   3329                if ( pPrev == NULL )
   3330                  zclGenAlarmTable = pLoop->next;
   3331                else
   3332                  pPrev->next = pLoop->next;
   3333          
   3334                // Free the memory
   3335                zcl_mem_free( pLoop );
   3336          
   3337                // Notify the Application so that if the alarm condition still active then
   3338                // a new notification will be generated, and a new alarm record will be
   3339                // added to the alarm log
   3340                // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
   3341                return;
   3342              }
   3343              pPrev = pLoop;
   3344              pLoop = pLoop->next;
   3345            }
   3346          }
   3347          
   3348          /*********************************************************************
   3349           * @fn      zclGeneral_ResetAllAlarms
   3350           *
   3351           * @brief   Remove all alarms with endpoint
   3352           *
   3353           * @param   endpoint -
   3354           * @param   notifyApp -
   3355           *
   3356           * @return  none
   3357           */
   3358          void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
   3359          {
   3360            zclGenAlarmItem_t *pLoop;
   3361            zclGenAlarmItem_t *pPrev;
   3362            zclGenAlarmItem_t *pNext;
   3363          
   3364            // Look for end of list
   3365            pLoop = zclGenAlarmTable;
   3366            pPrev = NULL;
   3367            while ( pLoop )
   3368            {
   3369              if (  pLoop->endpoint == endpoint )
   3370              {
   3371                if ( pPrev == NULL )
   3372                  zclGenAlarmTable = pLoop->next;
   3373                else
   3374                  pPrev->next = pLoop->next;
   3375          
   3376                pNext = pLoop->next;
   3377          
   3378                // Free the memory
   3379                zcl_mem_free( pLoop );
   3380          
   3381                pLoop = pNext;
   3382              }
   3383              else
   3384              {
   3385                pPrev = pLoop;
   3386                pLoop = pLoop->next;
   3387              }
   3388            }
   3389          
   3390            if ( notifyApp )
   3391            {
   3392              // Notify the Application so that if any alarm conditions still active then
   3393              // a new notification will be generated, and a new alarm record will be
   3394              // added to the alarm log
   3395              // zclGeneral_NotifyResetAll(); // callback function?
   3396            }
   3397          }
   3398          
   3399          /*********************************************************************
   3400           * @fn      zclGeneral_ProcessInAlarmsServer
   3401           *
   3402           * @brief   Process in the received Alarms Command.
   3403           *
   3404           * @param   pInMsg - pointer to the incoming message
   3405           *
   3406           * @return  ZStatus_t
   3407           */
   3408          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
   3409                                                             zclGeneral_AppCallbacks_t *pCBs )
   3410          {
   3411            zclAlarm_t alarm;
   3412            zclGeneral_Alarm_t *pAlarm;
   3413            uint8 *pData = pInMsg->pData;
   3414            ZStatus_t stat = ZSuccess;
   3415          
   3416            switch ( pInMsg->hdr.commandID )
   3417            {
   3418              case COMMAND_ALARMS_RESET:
   3419                if ( pCBs->pfnAlarm )
   3420                {
   3421                  alarm.cmdID = pInMsg->hdr.commandID;
   3422                  alarm.alarmCode = pData[0];
   3423                  alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
   3424          
   3425                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3426                }
   3427                else
   3428                {
   3429                  stat = ZCL_STATUS_FAILURE;
   3430                }
   3431                break;
   3432          
   3433              case COMMAND_ALARMS_RESET_ALL:
   3434                if ( pCBs->pfnAlarm )
   3435                {
   3436                  alarm.cmdID = pInMsg->hdr.commandID;
   3437          
   3438                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3439                }
   3440                else
   3441                {
   3442                  stat = ZCL_STATUS_FAILURE;
   3443                }
   3444                break;
   3445          
   3446              case COMMAND_ALARMS_GET:
   3447                if ( pCBs->pfnAlarm )
   3448                {
   3449                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3450                  alarm.cmdID = pInMsg->hdr.commandID;
   3451          
   3452                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3453          
   3454                  pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
   3455                  if ( pAlarm )
   3456                  {
   3457                    // Send a response back
   3458                    zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3459                                                     ZCL_STATUS_SUCCESS, pAlarm->code,
   3460                                                     pAlarm->clusterID, pAlarm->timeStamp,
   3461                                                     true, pInMsg->hdr.transSeqNum );
   3462                    // Remove the entry from the Alarm table
   3463                    zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
   3464                  }
   3465                  else
   3466                  {
   3467                    // Send a response back
   3468                    zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3469                                                     ZCL_STATUS_NOT_FOUND, 0, 0, 0,
   3470                                                     true, pInMsg->hdr.transSeqNum );
   3471                  }
   3472                  stat = ZCL_STATUS_CMD_HAS_RSP;
   3473                }
   3474                else
   3475                {
   3476                  stat = ZCL_STATUS_FAILURE;
   3477                }
   3478                break;
   3479          
   3480              case COMMAND_ALARMS_RESET_LOG:
   3481                if ( pCBs->pfnAlarm )
   3482                {
   3483                  alarm.cmdID = pInMsg->hdr.commandID;
   3484          
   3485                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3486          
   3487                  zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
   3488                }
   3489                else
   3490                {
   3491                  stat = ZCL_STATUS_FAILURE;
   3492                }
   3493                break;
   3494          
   3495          #ifdef SE_UK_EXT
   3496              case COMMAND_ALARMS_PUBLISH_EVENT_LOG:
   3497                if ( pCBs->pfnPublishEventLog )
   3498                {
   3499                  zclPublishEventLog_t eventLog;
   3500          
   3501                  eventLog.logID = *pData++;
   3502                  eventLog.cmdIndex = *pData++;
   3503                  eventLog.totalCmds = *pData++;
   3504          
   3505                  // First try to find out number of Sub Log Payloads
   3506                  eventLog.numSubLogs = (pInMsg->pDataLen-3)/(1+4); // event ID + event time
   3507                  if ( eventLog.numSubLogs > 0 )
   3508                  {
   3509                    // Try to alloc space for Log Payload
   3510                    eventLog.pLogs = (zclEventLogPayload_t *)zcl_mem_alloc( sizeof( zclEventLogPayload_t ) *
   3511                                                                             eventLog.numSubLogs );
   3512                    if ( eventLog.pLogs != NULL )
   3513                    {
   3514                      // Copy Log Payload
   3515                      for ( uint8 i = 0; i < eventLog.numSubLogs; i++ )
   3516                      {
   3517                        eventLog.pLogs[i].eventId = *pData++;
   3518                        eventLog.pLogs[i].eventTime = zcl_build_uint32( pData, 4 );
   3519                        pData += 4;
   3520                      }
   3521                    }
   3522                    else
   3523                    {
   3524                      stat = ZCL_STATUS_SOFTWARE_FAILURE;
   3525                    }
   3526                  }
   3527                  else
   3528                  {
   3529                    eventLog.pLogs = NULL;
   3530                  }
   3531          
   3532                  if ( stat == ZSuccess )
   3533                  {
   3534                    pCBs->pfnPublishEventLog( &(pInMsg->msg->srcAddr), &eventLog );
   3535                  }
   3536          
   3537                  if ( eventLog.pLogs != NULL )
   3538                  {
   3539                    zcl_mem_free( eventLog.pLogs );
   3540                  }
   3541                }
   3542                break;
   3543          #endif // SE_UK_EXT
   3544          
   3545              default:
   3546                stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   3547                break;
   3548            }
   3549          
   3550            return ( stat );
   3551          }
   3552          
   3553          /*********************************************************************
   3554           * @fn      zclGeneral_ProcessInAlarmsClient
   3555           *
   3556           * @brief   Process in the received Alarms Command.
   3557           *
   3558           * @param   pInMsg - pointer to the incoming message
   3559           *
   3560           * @return  ZStatus_t
   3561           */
   3562          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
   3563                                                             zclGeneral_AppCallbacks_t *pCBs )
   3564          {
   3565            uint8 *pData = pInMsg->pData;
   3566            zclAlarm_t alarm;
   3567            ZStatus_t stat = ZSuccess;
   3568          
   3569            zcl_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
   3570          
   3571            switch ( pInMsg->hdr.commandID )
   3572            {
   3573              case COMMAND_ALARMS_ALARM:
   3574                if ( pCBs->pfnAlarm )
   3575                {
   3576                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3577                  alarm.cmdID = pInMsg->hdr.commandID;
   3578                  alarm.alarmCode = pData[0];
   3579                  alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
   3580          
   3581                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3582                }
   3583                else
   3584                {
   3585                  stat = ZCL_STATUS_FAILURE;
   3586                }
   3587                break;
   3588          
   3589              case COMMAND_ALARMS_GET_RSP:
   3590                if ( pCBs->pfnAlarm )
   3591                {
   3592                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3593                  alarm.cmdID = pInMsg->hdr.commandID;
   3594                  alarm.alarmCode = *pData++;
   3595                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   3596          
   3597                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3598                }
   3599                else
   3600                {
   3601                  stat = ZCL_STATUS_FAILURE;
   3602                }
   3603                break;
   3604          
   3605          #ifdef SE_UK_EXT
   3606              case COMMAND_ALARMS_GET_EVENT_LOG:
   3607                if ( pCBs->pfnGetEventLog )
   3608                {
   3609                  zclGetEventLog_t eventLog;
   3610          
   3611                  eventLog.logID = *pData++;
   3612                  eventLog.startTime = zcl_build_uint32( pData, 4 );
   3613                  pData += 4;
   3614                  eventLog.endTime = zcl_build_uint32( pData, 4 );
   3615                  pData += 4;
   3616                  eventLog.numEvents = *pData;
   3617          
   3618                  pCBs->pfnGetEventLog( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3619                                        &eventLog, pInMsg->hdr.transSeqNum );
   3620                }
   3621                break;
   3622          #endif // SE_UK_EXT
   3623          
   3624              default:
   3625                stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   3626                break;
   3627            }
   3628          
   3629            return ( stat );
   3630          }
   3631          #endif // ZCL_ALARMS
   3632          
   3633          #ifdef ZCL_LOCATION
   3634          /*********************************************************************
   3635           * @fn      zclGeneral_ProcessInLocationServer
   3636           *
   3637           * @brief   Process in the received Location Command.
   3638           *
   3639           * @param   pInMsg - pointer to the incoming message
   3640           *
   3641           * @return  ZStatus_t
   3642           */
   3643          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
   3644                                                               zclGeneral_AppCallbacks_t *pCBs )
   3645          {
   3646            uint8 *pData = pInMsg->pData;
   3647            zclLocation_t cmd;
   3648            ZStatus_t stat = ZSuccess;
   3649          
   3650            zcl_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
   3651          
   3652            switch ( pInMsg->hdr.commandID )
   3653            {
   3654              case COMMAND_LOCATION_SET_ABSOLUTE:
   3655                cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3656                pData += 2;
   3657                cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3658                pData += 2;
   3659                cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3660                pData += 2;
   3661                cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3662                pData += 2;
   3663                cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3664          
   3665                if ( pCBs->pfnLocation )
   3666                {
   3667                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3668                  cmd.cmdID = pInMsg->hdr.commandID;
   3669          
   3670                  // Update the absolute location info
   3671                  pCBs->pfnLocation( &cmd );
   3672                }
   3673                break;
   3674          
   3675              case COMMAND_LOCATION_SET_DEV_CFG:
   3676                cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
   3677                pData += 2;
   3678                cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3679                pData += 2;
   3680                cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3681                pData += 2;
   3682                cmd.un.devCfg.numMeasurements = *pData++;
   3683                cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3684          
   3685                if ( pCBs->pfnLocation )
   3686                {
   3687                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3688                  cmd.cmdID = pInMsg->hdr.commandID;
   3689          
   3690                  // Update the device configuration info
   3691                  pCBs->pfnLocation( &cmd );
   3692                }
   3693                break;
   3694          
   3695              case COMMAND_LOCATION_GET_DEV_CFG:
   3696                cmd.un.ieeeAddr = pData;
   3697          
   3698                if ( pCBs->pfnLocation )
   3699                {
   3700                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3701                  cmd.cmdID = pInMsg->hdr.commandID;
   3702                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3703          
   3704                  // Retreive the Device Configuration
   3705                  pCBs->pfnLocation( &cmd );
   3706                }
   3707                stat = ZCL_STATUS_CMD_HAS_RSP;
   3708                break;
   3709          
   3710              case COMMAND_LOCATION_GET_DATA:
   3711                cmd.un.loc.bitmap.locByte = *pData++;
   3712                cmd.un.loc.numResponses = *pData++;
   3713          
   3714                if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
   3715                  zcl_memcpy( cmd.un.loc.targetAddr, pData, 8 );
   3716          
   3717                if ( pCBs->pfnLocation )
   3718                {
   3719                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3720                  cmd.cmdID = pInMsg->hdr.commandID;
   3721                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3722          
   3723                  // Retreive the Location Data
   3724                  pCBs->pfnLocation( &cmd );
   3725                }
   3726                stat = ZCL_STATUS_CMD_HAS_RSP;
   3727                break;
   3728          
   3729              default:
   3730                stat = ZFailure;
   3731                break;
   3732            }
   3733          
   3734            return ( stat );
   3735          }
   3736          
   3737          /*********************************************************************
   3738           * @fn      zclGeneral_ProcessInLocationDataRsp
   3739           *
   3740           * @brief   Process in the received Location Command.
   3741           *
   3742           * @param   pInMsg - pointer to the incoming message
   3743           *
   3744           * @return  ZStatus_t
   3745           */
   3746          static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
   3747                                                           zclGeneral_AppCallbacks_t *pCBs )
   3748          {
   3749            uint8 *pData = pInMsg->pData;
   3750            zclLocationRsp_t rsp;
   3751          
   3752            zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3753          
   3754            if ( pCBs->pfnLocationRsp )
   3755            {
   3756              if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
   3757                rsp.un.loc.status = *pData++;
   3758          
   3759              if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
   3760                   rsp.un.loc.status == ZCL_STATUS_SUCCESS )
   3761              {
   3762                rsp.un.loc.data.type = *pData++;
   3763                rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3764                pData += 2;
   3765                rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3766                pData += 2;
   3767          
   3768                if ( locationType2D( rsp.un.loc.data.type ) == 0 )
   3769                {
   3770                  rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3771                  pData += 2;
   3772                }
   3773          
   3774                if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3775                {
   3776                  rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3777                  pData += 2;
   3778                  rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3779                  pData += 2;
   3780                }
   3781          
   3782                if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
   3783                {
   3784                  if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3785                    rsp.un.loc.data.calcLoc.locationMethod = *pData++;
   3786          
   3787                  rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
   3788                  rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
   3789                }
   3790              }
   3791          
   3792              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3793              rsp.cmdID = pInMsg->hdr.commandID;
   3794          
   3795              // Notify the Application
   3796              pCBs->pfnLocationRsp( &rsp );
   3797            }
   3798          }
   3799          
   3800          /*********************************************************************
   3801           * @fn      zclGeneral_ProcessInLocationClient
   3802           *
   3803           * @brief   Process in the received Location Command.
   3804           *
   3805           * @param   pInMsg - pointer to the incoming message
   3806           *
   3807           * @return  ZStatus_t
   3808           */
   3809          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
   3810                                                               zclGeneral_AppCallbacks_t *pCBs )
   3811          {
   3812            uint8 *pData = pInMsg->pData;
   3813            zclLocationRsp_t rsp;
   3814            ZStatus_t stat = ZSuccess;
   3815          
   3816            zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3817          
   3818            switch ( pInMsg->hdr.commandID )
   3819            {
   3820              case COMMAND_LOCATION_DEV_CFG_RSP:
   3821                if ( pCBs->pfnLocationRsp )
   3822                {
   3823                  rsp.un.devCfg.status = *pData++;
   3824                  if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
   3825                  {
   3826                    rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
   3827                    pData += 2;
   3828                    rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3829                    pData += 2;
   3830                    rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3831                    pData += 2;
   3832                    rsp.un.devCfg.data.numMeasurements = *pData++;
   3833                    rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3834          
   3835                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3836                    rsp.cmdID = pInMsg->hdr.commandID;
   3837          
   3838                    // Notify the Application
   3839                    pCBs->pfnLocationRsp( &rsp );
   3840                  }
   3841                }
   3842                break;
   3843          
   3844              case COMMAND_LOCATION_DATA_RSP:
   3845              case COMMAND_LOCATION_DATA_NOTIF:
   3846              case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
   3847                zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
   3848                break;
   3849          
   3850              case COMMAND_LOCATION_RSSI_PING:
   3851                if ( pCBs->pfnLocationRsp )
   3852                {
   3853                  rsp.un.locationType = *pData;
   3854          
   3855                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3856                  rsp.cmdID = pInMsg->hdr.commandID;
   3857          
   3858                  // Notify the Application
   3859                  pCBs->pfnLocationRsp( &rsp );
   3860                }
   3861                break;
   3862          
   3863              default:
   3864                stat = ZFailure;
   3865                break;
   3866            }
   3867          
   3868            return ( stat );
   3869          }
   3870          #endif // ZCL_LOCATION
   3871          
   3872          #ifdef ZCL_SCENES
   3873          #if !defined ( ZCL_STANDALONE )
   3874          /*********************************************************************
   3875           * @fn      zclGeneral_ScenesInitNV
   3876           *
   3877           * @brief   Initialize the NV Scene Table Items
   3878           *
   3879           * @param   none
   3880           *
   3881           * @return  number of scenes
   3882           */
   3883          static uint8 zclGeneral_ScenesInitNV( void )
   3884          {
   3885            uint8  status;
   3886            uint16 size;
   3887          
   3888            size = (uint16)((sizeof ( nvGenScenesHdr_t ))
   3889                            + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
   3890          
   3891            status = zcl_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
   3892          
   3893            if ( status != ZSUCCESS )
   3894            {
   3895              zclGeneral_ScenesSetDefaultNV();
   3896            }
   3897          
   3898            return status;
   3899          }
   3900          #endif // ZCL_STANDALONE
   3901          
   3902          #if !defined ( ZCL_STANDALONE )
   3903          /*********************************************************************
   3904           * @fn          zclGeneral_ScenesSetDefaultNV
   3905           *
   3906           * @brief       Write the defaults to NV
   3907           *
   3908           * @param       none
   3909           *
   3910           * @return      none
   3911           */
   3912          static void zclGeneral_ScenesSetDefaultNV( void )
   3913          {
   3914            nvGenScenesHdr_t hdr;
   3915          
   3916            // Initialize the header
   3917            hdr.numRecs = 0;
   3918          
   3919            // Save off the header
   3920            zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3921          }
   3922          #endif // ZCL_STANDALONE
   3923          
   3924          #if !defined ( ZCL_STANDALONE )
   3925          /*********************************************************************
   3926           * @fn          zclGeneral_ScenesWriteNV
   3927           *
   3928           * @brief       Save the Scene Table in NV
   3929           *
   3930           * @param       none
   3931           *
   3932           * @return      none
   3933           */
   3934          static void zclGeneral_ScenesWriteNV( void )
   3935          {
   3936            nvGenScenesHdr_t hdr;
   3937            zclGenSceneItem_t *pLoop;
   3938            zclGenSceneNVItem_t item;
   3939          
   3940            hdr.numRecs = 0;
   3941          
   3942            // Look for end of list
   3943            pLoop = zclGenSceneTable;
   3944            while ( pLoop )
   3945            {
   3946              // Build the record
   3947              item.endpoint = pLoop->endpoint;
   3948              zcl_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
   3949          
   3950              // Save the record to NV
   3951              zcl_nv_write( ZCD_NV_SCENE_TABLE,
   3952                      (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
   3953                              sizeof ( zclGenSceneNVItem_t ), &item );
   3954          
   3955              hdr.numRecs++;
   3956          
   3957              pLoop = pLoop->next;
   3958            }
   3959          
   3960            // Save off the header
   3961            zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3962          }
   3963          #endif // ZCL_STANDALONE
   3964          
   3965          #if !defined ( ZCL_STANDALONE )
   3966          /*********************************************************************
   3967           * @fn          zclGeneral_ScenesRestoreFromNV
   3968           *
   3969           * @brief       Restore the Scene table from NV
   3970           *
   3971           * @param       none
   3972           *
   3973           * @return      Number of entries restored
   3974           */
   3975          static uint16 zclGeneral_ScenesRestoreFromNV( void )
   3976          {
   3977            uint16 x;
   3978            nvGenScenesHdr_t hdr;
   3979          
   3980            zclGenSceneNVItem_t item;
   3981            uint16 numAdded = 0;
   3982          
   3983            if ( zcl_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
   3984            {
   3985              // Read in the device list
   3986              for ( x = 0; x < hdr.numRecs; x++ )
   3987              {
   3988                if ( zcl_nv_read( ZCD_NV_SCENE_TABLE,
   3989                          (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
   3990                                            sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
   3991                {
   3992                  // Add the scene
   3993                  if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
   3994                  {
   3995                    numAdded++;
   3996                  }
   3997                }
   3998              }
   3999            }
   4000          
   4001            return ( numAdded );
   4002          }
   4003          #endif // ZCL_STANDALONE
   4004          
   4005          #if !defined ( ZCL_STANDALONE )
   4006          /*********************************************************************
   4007           * @fn          zclGeneral_ScenesInit
   4008           *
   4009           * @brief       Initialize the scenes table
   4010           *
   4011           * @param       none
   4012           *
   4013           * @return      none
   4014           */
   4015          void zclGeneral_ScenesInit( void )
   4016          {
   4017            // Initialize NV items
   4018            zclGeneral_ScenesInitNV();
   4019          
   4020            // Restore the Scene table
   4021            zclGeneral_ScenesRestoreFromNV();
   4022          }
   4023          #endif // ZCL_STANDALONE
   4024          
   4025          #if !defined ( ZCL_STANDALONE )
   4026          /*********************************************************************
   4027           * @fn          zclGeneral_ScenesSave
   4028           *
   4029           * @brief       Save the scenes table
   4030           *
   4031           * @param       none
   4032           *
   4033           * @return      none
   4034           */
   4035          void zclGeneral_ScenesSave( void )
   4036          {
   4037            // Update NV
   4038            zclGeneral_ScenesWriteNV();
   4039          }
   4040          #endif // ZCL_STANDALONE
   4041          
   4042          #endif // ZCL_SCENES
   4043          
   4044          /***************************************************************************
   4045          ****************************************************************************/

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   zclGeneral_HdlInSpecificCommands
        6   -- Indirect call
        6   -> zclGeneral_ProcessInIdentity
      4   zclGeneral_HdlIncoming
        4   -> zclGeneral_HdlInSpecificCommands
     20   zclGeneral_ProcessInIdentity
       18   -- Indirect call
       20   -> zclGeneral_SendIdentifyQueryResponse
       20   -> zcl_ReadAttrData
      8   zclGeneral_RegisterCmdCallbacks
        8   -> osal_mem_alloc
        8   -> zcl_registerPlugin
     20   zclGeneral_SendIdentify
       20   -> zcl_SendCommand
     20   zclGeneral_SendIdentifyEZModeInvoke
       20   -> zcl_SendCommand
     20   zclGeneral_SendIdentifyQueryResponse
       20   -> zcl_SendCommand
     20   zclGeneral_SendIdentifyUpdateCommState
       20   -> zcl_SendCommand


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??Subroutine2_0
      10  ??Subroutine3_0
       4  ?Subroutine0
      18  ?Subroutine1
       2  zclGenCBs
       1  zclGenPluginRegisted
     158  zclGeneral_HdlInSpecificCommands
      20  zclGeneral_HdlIncoming
     178  zclGeneral_ProcessInIdentity
      96  zclGeneral_RegisterCmdCallbacks
      24  zclGeneral_SendIdentify
      32  zclGeneral_SendIdentifyEZModeInvoke
      24  zclGeneral_SendIdentifyQueryResponse
      42  zclGeneral_SendIdentifyUpdateCommState

 
 610 bytes in segment CODE
   3 bytes in segment DATA16_Z
 
 610 bytes of CODE memory
   3 bytes of DATA memory

Errors: none
Warnings: none
