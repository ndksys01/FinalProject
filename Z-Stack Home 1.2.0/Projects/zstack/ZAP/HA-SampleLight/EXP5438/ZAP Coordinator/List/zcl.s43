///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.60.5.50814/W32 for MSP430      08/Apr/2014  21:14:23 /
// Copyright 1996-2013 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Texas Instruments\Z-Stack Home                      /
//                     1.2.0\Components\stack\zcl\zcl.c                       /
//    Command line  =  -f "C:\Texas Instruments\Z-Stack Home                  /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \Source\zap.cfg" (-DZAP_PHY_SPI=1                      /
//                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE   /
//                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                 /
//                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE              /
//                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE           /
//                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE           /
//                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG           /
//                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC              /
//                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC         /
//                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0        /
//                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000          /
//                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4) -f  /
//                     "C:\Texas Instruments\Z-Stack Home                     /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\Tools\MSP5438\f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE  /
//                     -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF                /
//                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4         /
//                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10        /
//                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10       /
//                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING               /
//                     -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU  /
//                     -DZCL_DEVICE_MGMT) "C:\Texas Instruments\Z-Stack Home  /
//                     1.2.0\Components\stack\zcl\zcl.c" -D                   /
//                     FEATURE_GREEN_POWER -D FEATURE_ENHANCED_BEACON -D      /
//                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -lC           /
//                     "C:\Texas Instruments\Z-Stack Home                     /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP   /
//                     Coordinator\List\" -lA "C:\Texas Instruments\Z-Stack   /
//                     Home 1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ /
//                     ZAP Coordinator\List\" --remarks --diag_suppress       /
//                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                   /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\ZAP Coordinator\Obj\" --debug      /
//                     -D__MSP430F5438__ -e --double=32 --clib -I "C:\Texas   /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\" -I "C:\Texas                     /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\Source\" -I "C:\Texas           /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\Source\" -I "C:\Texas        /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\hal\targ /
//                     et\MSP5438ZAP\" -I "C:\Texas Instruments\Z-Stack Home  /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\hal\include\" -I "C:\Texas        /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\mac\incl /
//                     ude\" -I "C:\Texas Instruments\Z-Stack Home            /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\mt\" -I "C:\Texas                 /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\osal\inc /
//                     lude\" -I "C:\Texas Instruments\Z-Stack Home           /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\osal\mcu\msp430\" -I "C:\Texas    /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\services /
//                     \saddr\" -I "C:\Texas Instruments\Z-Stack Home         /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\services\sdata\" -I "C:\Texas     /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\stack\af /
//                     \" -I "C:\Texas Instruments\Z-Stack Home               /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\stack\nwk\" -I "C:\Texas          /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\stack\sa /
//                     pi\" -I "C:\Texas Instruments\Z-Stack Home             /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\stack\sec\" -I "C:\Texas          /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\stack\sy /
//                     s\" -I "C:\Texas Instruments\Z-Stack Home              /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\stack\zcl\" -I "C:\Texas          /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\stack\zd /
//                     o\" -I "C:\Texas Instruments\Z-Stack Home              /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\..\.. /
//                     \..\..\..\Components\zmac\" -I "C:\Texas               /
//                     Instruments\Z-Stack Home 1.2.0\Projects\zstack\ZAP\HA- /
//                     SampleLight\EXP5438\..\..\..\..\..\Components\zmac\f8w /
//                     \" --core=430X --data_model=small -Ohz                 /
//                     --multiplier=32 --multiplier_location=4C0              /
//                     --require_prototypes --hw_workaround=CPU40             /
//                     --hw_workaround=CPU39                                  /
//    List file     =  C:\Texas Instruments\Z-Stack Home                      /
//                     1.2.0\Projects\zstack\ZAP\HA-SampleLight\EXP5438\ZAP   /
//                     Coordinator\List\zcl.s43                               /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME zcl

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?IndCallR11
        EXTERN ?IndCallR15
        EXTERN ?CopyMemoryWords
        EXTERN ?cstart_init_copy
        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        FUNCTION zclAuthorizeWrite,061203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        FUNCTION zclBuildHdr,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC zclFindAttrRec
        FUNCTION zclFindAttrRec,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        FUNCTION zclFindAttrRecsList,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION zclFindClusterOption,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC zclGetAttrDataLength
        FUNCTION zclGetAttrDataLength,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION zclGetAttrDataLengthUsingCB,061203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 16, STACK
        FUNCTION zclGetAuthorizeCB,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION zclGetClusterOption,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC zclGetDataTypeLength
        FUNCTION zclGetDataTypeLength,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION zclGetReadWriteCB,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC zclParseHdr
        FUNCTION zclParseHdr,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        FUNCTION zclParseInDefaultRspCmd,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC zclParseInReadCmd
        FUNCTION zclParseInReadCmd,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        FUNCTION zclParseInReadRspCmd,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC zclParseInWriteCmd
        FUNCTION zclParseInWriteCmd,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        FUNCTION zclParseInWriteRspCmd,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        FUNCTION zclProcessInReadCmd,061603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 34, STACK
        FUNCTION zclProcessInWriteCmd,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 34, STACK
        FUNCTION zclProcessInWriteUndividedCmd,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 38, STACK
        PUBLIC zclReadAttrData
        FUNCTION zclReadAttrData,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        FUNCTION zclReadAttrDataUsingCB,061203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 18, STACK
        FUNCTION zclRevertWriteUndividedCmd,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 24, STACK
        PUBLIC zclSerializeData
        FUNCTION zclSerializeData,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION zclSetSecurityOption,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        FUNCTION zclWriteAttrData,061203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        FUNCTION zclWriteAttrDataUsingCB,061203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 14, STACK
        FUNCTION zcl_DeviceOperational,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 14, STACK
        PUBLIC zcl_HandleExternal
        FUNCTION zcl_HandleExternal,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC zcl_Init
        FUNCTION zcl_Init,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC zcl_ProcessMessageMSG
        FUNCTION zcl_ProcessMessageMSG,061203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 42, STACK
        PUBLIC zcl_ReadAttrData
        FUNCTION zcl_ReadAttrData,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 22, STACK
        PUBLIC zcl_RegisteredMsgTaskID
        PUBLIC zcl_SendCommand
        FUNCTION zcl_SendCommand,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 34, STACK
        PUBLIC zcl_SendDefaultRspCmd
        FUNCTION zcl_SendDefaultRspCmd,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC zcl_SendRead
        FUNCTION zcl_SendRead,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 30, STACK
        PUBLIC zcl_SendReadRsp
        FUNCTION zcl_SendReadRsp,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 36, STACK
        PUBLIC zcl_SendWriteRequest
        FUNCTION zcl_SendWriteRequest,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 34, STACK
        PUBLIC zcl_SendWriteRsp
        FUNCTION zcl_SendWriteRsp,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 30, STACK
        PUBLIC zcl_SeqNum
        PUBLIC zcl_TaskID
        PUBLIC zcl_ValidateAttrDataCB
        PUBLIC zcl_event_loop
        FUNCTION zcl_event_loop,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC zcl_getRawAFMsg
        FUNCTION zcl_getRawAFMsg,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC zcl_registerAttrList
        FUNCTION zcl_registerAttrList,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC zcl_registerClusterOptionList
        FUNCTION zcl_registerClusterOptionList,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC zcl_registerForMsg
        FUNCTION zcl_registerForMsg,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC zcl_registerPlugin
        FUNCTION zcl_registerPlugin,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC zcl_registerReadWriteCB
        FUNCTION zcl_registerReadWriteCB,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC zcl_registerValidateAttrData
        FUNCTION zcl_registerValidateAttrData,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        EXTERN osal_mem_alloc
        FUNCTION osal_mem_alloc,0202H
        EXTERN osal_mem_free
        FUNCTION osal_mem_free,0202H
        EXTERN osal_memcpy
        FUNCTION osal_memcpy,0202H
        EXTERN osal_buffer_uint32
        FUNCTION osal_buffer_uint32,0202H
        EXTERN osal_memset
        FUNCTION osal_memset,0202H
        EXTERN afFindEndPointDesc
        FUNCTION afFindEndPointDesc,0202H
        EXTERN AF_DataRequest
        FUNCTION AF_DataRequest,0202H
        EXTERN osal_msg_allocate
        FUNCTION osal_msg_allocate,0202H
        EXTERN osal_msg_send
        FUNCTION osal_msg_send,0202H
        EXTERN osal_msg_receive
        FUNCTION osal_msg_receive,0202H
        EXTERN osal_msg_deallocate
        FUNCTION osal_msg_deallocate,0202H

// C:\Texas Instruments\Z-Stack Home 1.2.0\Components\stack\zcl\zcl.c
//    1 /**************************************************************************************************
//    2   Filename:       zcl.c
//    3   Revised:        $Date: 2013-11-22 17:43:52 -0800 (Fri, 22 Nov 2013) $
//    4   Revision:       $Revision: 36225 $
//    5 
//    6   Description:    This file contains the Zigbee Cluster Library Foundation functions.
//    7 
//    8 
//    9   Copyright 2006-2013 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 #include "ZComDef.h"
//   44 #include "AF.h"
//   45 
//   46 #include "zcl.h"
//   47 #include "zcl_general.h"
//   48 
//   49 #if defined ( INTER_PAN )
//   50   #include "stub_aps.h"
//   51 #endif
//   52 
//   53 /*********************************************************************
//   54  * MACROS
//   55  */
//   56 /*** Frame Control ***/
//   57 #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
//   58 #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
//   59 #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
//   60 #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
//   61 
//   62 /*** Attribute Access Control ***/
//   63 #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
//   64 #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
//   65 #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
//   66 #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
//   67 #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
//   68 
//   69 #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
//   70 #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
//   71 
//   72 #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \ 
//   73                                         (zclHdr).fc.manuSpecific == 0          && \ 
//   74                                         (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
//   75 
//   76 // Commands that have corresponding responses
//   77 #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \ 
//   78                                         (cmd) == ZCL_CMD_WRITE                  || \ 
//   79                                         (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \ 
//   80                                         (cmd) == ZCL_CMD_CONFIG_REPORT          || \ 
//   81                                         (cmd) == ZCL_CMD_READ_REPORT_CFG        || \ 
//   82                                         (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \ 
//   83                                         (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \ 
//   84                                         (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \ 
//   85                                         (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \ 
//   86                                         (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
//   87 
//   88 /*********************************************************************
//   89  * CONSTANTS
//   90  */
//   91 
//   92 /*********************************************************************
//   93  * TYPEDEFS
//   94  */
//   95 typedef struct zclLibPlugin
//   96 {
//   97   struct zclLibPlugin *next;
//   98   uint16              startClusterID;    // starting cluster ID
//   99   uint16              endClusterID;      // ending cluster ID
//  100   zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
//  101 } zclLibPlugin_t;
//  102 
//  103 // Command record list
//  104 typedef struct zclCmdRecsList
//  105 {
//  106   struct zclCmdRecsList *pNext;
//  107   uint8                 endpoint;
//  108   uint8                 numCommands;
//  109   CONST zclCommandRec_t *pCmdRecs;
//  110 } zclCmdRecsList_t;
//  111 
//  112 // Attribute record list item
//  113 typedef struct zclAttrRecsList
//  114 {
//  115   struct zclAttrRecsList *next;
//  116   uint8                  endpoint;      // Used to link it into the endpoint descriptor
//  117   zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
//  118   zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
//  119   uint8                  numAttributes; // Number of the following records
//  120   CONST zclAttrRec_t     *attrs;        // attribute records
//  121 } zclAttrRecsList;
//  122 
//  123 // Cluster option list item
//  124 typedef struct zclClusterOptionList
//  125 {
//  126   struct zclClusterOptionList *next;
//  127   uint8                       endpoint;   // Used to link it into the endpoint descriptor
//  128   uint8                       numOptions; // Number of the following records
//  129   zclOptionRec_t              *options;   // option records
//  130 } zclClusterOptionList;
//  131 
//  132 typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
//  133 typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
//  134 
//  135 typedef struct
//  136 {
//  137   zclParseInProfileCmd_t   pfnParseInProfile;
//  138   zclProcessInProfileCmd_t pfnProcessInProfile;
//  139 } zclCmdItems_t;
//  140 
//  141 
//  142 /*********************************************************************
//  143  * GLOBAL VARIABLES
//  144  */
//  145 
//  146 #if !defined ( ZCL_STANDALONE )

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  147   uint8 zcl_TaskID;
zcl_TaskID:
        DS8 1
//  148 
//  149   // The task Id of the Application where the unprocessed Foundation
//  150   // Command/Response messages will be sent to.

        RSEG DATA16_I:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_copy
//  151   uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
zcl_RegisteredMsgTaskID:
        DS8 1
        REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
//  152 #endif
//  153 
//  154 // The Application should register its attribute data validation function

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  155 zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
zcl_ValidateAttrDataCB:
        DS8 4
//  156 
//  157 // ZCL Sequence number

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  158 uint8 zcl_SeqNum = 0x00;
zcl_SeqNum:
        DS8 1
//  159 
//  160 /*********************************************************************
//  161  * EXTERNAL VARIABLES
//  162  */
//  163 
//  164 /*********************************************************************
//  165  * EXTERNAL FUNCTIONS
//  166  */
//  167 
//  168 /*********************************************************************
//  169  * LOCAL VARIABLES
//  170  */

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  171 static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
plugins:
        DS8 2
//  172 
//  173 #if defined ( ZCL_DISCOVER )
//  174   static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
//  175 #endif
//  176 

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  177 static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
attrList:
        DS8 2

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  178 static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
clusterOptionList:
        DS8 2

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  179 static uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
zcl_TransID:
        DS8 1
//  180 

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  181 static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
rawAFMsg:
        DS8 2
//  182 
//  183 /*********************************************************************
//  184  * LOCAL FUNCTIONS
//  185  */
//  186 void zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt );  // Not static for ZNP build.
//  187 static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
//  188 static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
//  189 static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
//  190 
//  191 #if defined ( ZCL_DISCOVER )
//  192   static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
//  193 #endif
//  194 
//  195 static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
//  196 static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
//  197 static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
//  198 static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
//  199 
//  200 static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
//  201 
//  202 #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
//  203 static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
//  204 static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
//  205 #endif // ZCL_READ || ZCL_WRITE
//  206 
//  207 #ifdef ZCL_READ
//  208 ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
//  209 static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
//  210 static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
//  211                                          uint8 *pAttrData, uint16 *pDataLen );
//  212 static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
//  213 static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
//  214 static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
//  215 #endif // ZCL_READ
//  216 
//  217 #ifdef ZCL_WRITE
//  218 static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
//  219                                    zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
//  220 static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
//  221                                           zclAttrRec_t *pAttr, uint8 *pAttrData );
//  222 static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
//  223 static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
//  224 static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
//  225 static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
//  226 #endif // ZCL_WRITE
//  227 
//  228 #ifdef ZCL_REPORT
//  229 static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
//  230 static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
//  231 #endif // ZCL_REPORT
//  232 
//  233 static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
//  234 
//  235 #ifdef ZCL_DISCOVER
//  236 static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
//  237 static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
//  238 static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
//  239 static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
//  240 static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
//  241 static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
//  242 static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
//  243 static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
//  244 static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
//  245 #endif // ZCL_DISCOVER
//  246 
//  247 /*********************************************************************
//  248  * Parse Profile Command Function Table
//  249  */
//  250 

        RSEG DATA16_C:CONST:SORT:NOROOT(1)
//  251 static CONST zclCmdItems_t zclCmdTable[] =
zclCmdTable:
        DC32 zclParseInReadCmd, zclProcessInReadCmd, zclParseInReadRspCmd
        DC32 zcl_HandleExternal, zclParseInWriteCmd, zclProcessInWriteCmd
        DC32 zclParseInWriteCmd, zclProcessInWriteUndividedCmd
        DC32 zclParseInWriteRspCmd, zcl_HandleExternal, zclParseInWriteCmd
        DC32 zclProcessInWriteCmd, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H
        DC32 zclParseInDefaultRspCmd, zcl_HandleExternal, 0H, 0H, 0H, 0H, 0H
        DC32 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H
//  252 {
//  253 #ifdef ZCL_READ
//  254   /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
//  255   /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
//  256 #else
//  257   /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
//  258   /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
//  259 #endif // ZCL_READ
//  260 
//  261 #ifdef ZCL_WRITE
//  262   /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
//  263   /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
//  264   /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
//  265   /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
//  266 #else
//  267   /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
//  268   /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
//  269   /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
//  270   /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
//  271 #endif // ZCL_WRITE
//  272 
//  273 #ifdef ZCL_REPORT
//  274   /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
//  275   /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
//  276   /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
//  277   /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
//  278   /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
//  279 #else
//  280   /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
//  281   /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
//  282   /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
//  283   /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
//  284   /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
//  285 #endif // ZCL_REPORT
//  286 
//  287   /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
//  288 
//  289 #ifdef ZCL_DISCOVER
//  290   /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
//  291   /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
//  292   /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
//  293   /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
//  294   /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
//  295   /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
//  296   /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
//  297   /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
//  298   /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
//  299   /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
//  300   /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
//  301 #else
//  302   /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
//  303   /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
//  304   /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
//  305   /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
//  306   /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
//  307   /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
//  308   /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
//  309   /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
//  310   /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
//  311   /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
//  312   /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
//  313 #endif // ZCL_DISCOVER
//  314 };
//  315 
//  316 /*********************************************************************
//  317  * PUBLIC FUNCTIONS
//  318  *********************************************************************/
//  319 
//  320 #if !defined ( ZCL_STANDALONE )
//  321 /*********************************************************************
//  322  * @fn          zcl_Init
//  323  *
//  324  * @brief       Initialization function for the zcl layer.
//  325  *
//  326  * @param       task_id - ZCL task id
//  327  *
//  328  * @return      none
//  329  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  330 void zcl_Init( uint8 task_id )
zcl_Init:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function zcl_Init
//  331 {
//  332   zcl_TaskID = task_id;
        MOV.B   R12, &zcl_TaskID
//  333 }
        RETA
          CFI EndBlock cfiBlock0
//  334 #endif
//  335 
//  336 #if !defined ( ZCL_STANDALONE )
//  337 /*********************************************************************
//  338  * @fn          zcl_event_loop
//  339  *
//  340  * @brief       Event Loop Processor for zcl.
//  341  *
//  342  * @param       task_id - task id
//  343  * @param       events - event bitmap
//  344  *
//  345  * @return      unprocessed events
//  346  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  347 uint16 zcl_event_loop( uint8 task_id, uint16 events )
zcl_event_loop:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function zcl_event_loop
//  348 {
        FUNCALL zcl_event_loop, osal_msg_receive
        LOCFRAME CSTACK, 8, STACK
        FUNCALL zcl_event_loop, zcl_ProcessMessageMSG
        LOCFRAME CSTACK, 8, STACK
        FUNCALL zcl_event_loop, osal_msg_deallocate
        LOCFRAME CSTACK, 8, STACK
        FUNCALL zcl_event_loop, osal_msg_receive
        LOCFRAME CSTACK, 8, STACK
        FUNCALL zcl_event_loop, osal_msg_send
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.W   R13, R10
//  349   uint8 *msgPtr;
//  350 
//  351   (void)task_id;  // Intentionally unreferenced parameter
//  352 
//  353   if ( events & SYS_EVENT_MSG )
        CMP.W   #0x0, R13
        JGE     ??zcl_event_loop_3
//  354   {
//  355     msgPtr = osal_msg_receive( zcl_TaskID );
        JMP     ??zcl_event_loop_2
//  356     while ( msgPtr != NULL )
//  357     {
//  358       uint8 dealloc = TRUE;
//  359 
//  360       if ( *msgPtr == AF_INCOMING_MSG_CMD )
//  361       {
//  362         zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
??zcl_event_loop_0:
        MOV.W   R11, R12
        CALLA   #zcl_ProcessMessageMSG
//  363       }
//  364       else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
//  365       {
//  366         // send it to another task to process.
//  367         osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
//  368         dealloc = FALSE;
//  369       }
//  370 
//  371       // Release the memory
//  372       if ( dealloc )
//  373       {
//  374         osal_msg_deallocate( msgPtr );
??zcl_event_loop_1:
        MOV.W   R11, R12
        CALLA   #osal_msg_deallocate
//  375       }
//  376 
//  377       // Next
//  378       msgPtr = osal_msg_receive( zcl_TaskID );
??zcl_event_loop_2:
        MOV.B   &zcl_TaskID, R12
        CALLA   #osal_msg_receive
        MOV.W   R12, R11
        CMP.W   #0x0, R11
        JEQ     ??zcl_event_loop_4
        CMP.B   #0x1a, 0(R11)
        JEQ     ??zcl_event_loop_0
        CMP.B   #0xff, &zcl_RegisteredMsgTaskID
        JEQ     ??zcl_event_loop_1
        CALLA   #?Subroutine17
??CrossCallReturnLabel_10:
        JMP     ??zcl_event_loop_2
//  379     }
//  380 
//  381     // return unprocessed events
//  382     return (events ^ SYS_EVENT_MSG);
??zcl_event_loop_4:
        XOR.W   #0x8000, R10
        MOV.W   R10, R12
        JMP     ??zcl_event_loop_5
//  383   }
//  384 
//  385   // Discard unknown events
//  386   return 0;
??zcl_event_loop_3:
        MOV.W   #0x0, R12
??zcl_event_loop_5:
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//  387 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine17:
          CFI Block cfiCond2 Using cfiCommon0
          CFI Function zcl_HandleExternal
          CFI Conditional ??zcl_HandleExternal_0
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
          CFI Block cfiCond3 Using cfiCommon0
          CFI (cfiCond3) Function zcl_event_loop
          CFI (cfiCond3) Conditional ??CrossCallReturnLabel_10
          CFI (cfiCond3) R10L Frame(CFA, -8)
          CFI (cfiCond3) R11L Frame(CFA, -6)
          CFI (cfiCond3) CFA SP+12
          CFI Block cfiPicker4 Using cfiCommon1
          CFI (cfiPicker4) NoFunction
          CFI (cfiPicker4) Picker
        MOV.W   R11, R13
        MOV.B   &zcl_RegisteredMsgTaskID, R12
        BRA     #osal_msg_send
          CFI EndBlock cfiCond2
          CFI EndBlock cfiCond3
          CFI EndBlock cfiPicker4
//  388 #endif
//  389 
//  390 #if !defined ( ZCL_STANDALONE )
//  391 /*********************************************************************
//  392  * @fn      zcl_registerForMsg
//  393  *
//  394  * @brief   The ZCL is setup to send all incoming Foundation Command/Response
//  395  *          messages that aren't processed to one task (if a task is
//  396  *          registered).
//  397  *
//  398  * @param   taskId - task Id of the Application where commands will be sent to
//  399  *
//  400  * @return  TRUE if task registeration successful, FALSE otherwise
//  401  *********************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  402 uint8 zcl_registerForMsg( uint8 taskId )
zcl_registerForMsg:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function zcl_registerForMsg
//  403 {
//  404   // Allow only the first task
//  405   if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
        CMP.B   #0xff, &zcl_RegisteredMsgTaskID
        JNE     ??zcl_registerForMsg_0
//  406   {
//  407     zcl_RegisteredMsgTaskID = taskId;
        MOV.B   R12, &zcl_RegisteredMsgTaskID
//  408 
//  409     return ( true );
        MOV.B   #0x1, R12
        RETA
//  410   }
//  411 
//  412   return ( false );
??zcl_registerForMsg_0:
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock5
//  413 }
//  414 #endif
//  415 
//  416 #if !defined ( ZCL_STANDALONE )
//  417 /*********************************************************************
//  418  * @fn      zcl_HandleExternal
//  419  *
//  420  * @brief
//  421  *
//  422  * @param   pInMsg - incoming message to process
//  423  *
//  424  * @return  TRUE
//  425  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  426 uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
zcl_HandleExternal:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function zcl_HandleExternal
//  427 {
        FUNCALL zcl_HandleExternal, osal_msg_allocate
        LOCFRAME CSTACK, 8, STACK
        FUNCALL zcl_HandleExternal, osal_msg_send
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.W   R12, R10
//  428   zclIncomingMsg_t *pCmd;
//  429 
//  430   if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
        CMP.B   #0xff, &zcl_RegisteredMsgTaskID
        JEQ     ??zcl_HandleExternal_0
//  431   {
//  432     return ( TRUE );
//  433   }
//  434 
//  435   pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
        MOV.W   #0x1a, R12
        CALLA   #osal_msg_allocate
        MOV.W   R12, R11
//  436   if ( pCmd != NULL )
        CMP.W   #0x0, R12
        JEQ     ??zcl_HandleExternal_0
//  437   {
//  438     // fill in the message
//  439     pCmd->hdr.event = ZCL_INCOMING_MSG;
        MOV.B   #0x34, 0(R12)
//  440     pCmd->zclHdr    = pInMsg->hdr;
        MOV.W   R10, R15
        ADD.W   #0x2, R15
        MOV.W   @R15+, 0x2(R12)
        MOV.W   @R15+, 0x4(R12)
        MOV.W   @R15+, 0x6(R12)
//  441     pCmd->clusterId = pInMsg->msg->clusterId;
        MOV.W   @R10, R14
        MOV.W   0x4(R14), 0x8(R12)
//  442     pCmd->srcAddr   = pInMsg->msg->srcAddr;
        ADD.W   #0xa, R12
        ADD.W   #0x6, R14
        MOV.W   #0x6, R13
        CALLA   #?CopyMemoryWords
//  443     pCmd->endPoint  = pInMsg->msg->endPoint;
        MOV.W   @R10, R15
        MOV.B   0x14(R15), 0x16(R11)
//  444     pCmd->attrCmd   = pInMsg->attrCmd;
        MOV.W   0xc(R10), 0x18(R11)
//  445 
//  446     // Application will free the attrCmd buffer
//  447     pInMsg->attrCmd = NULL;
        MOV.W   #0x0, 0xc(R10)
//  448 
//  449     /* send message through task message */
//  450     osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
        CALLA   #?Subroutine17
//  451   }
//  452 
//  453   return ( TRUE );
??zcl_HandleExternal_0:
        MOV.B   #0x1, R12
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock6
//  454 }
//  455 #endif
//  456 
//  457 
//  458 /*********************************************************************
//  459  * @fn          zcl_getRawAFMsg
//  460  *
//  461  * @brief       Call to get original unprocessed AF message
//  462  *              (not parsed by ZCL).
//  463  *
//  464  *   NOTE:  This function can only be called during a ZCL callback function
//  465  *          and the calling function must NOT change any data in the message.
//  466  *
//  467  * @param       none
//  468  *
//  469  * @return      pointer to original AF message, NULL if not processing
//  470  *              AF message.
//  471  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  472 afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
zcl_getRawAFMsg:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function zcl_getRawAFMsg
//  473 {
//  474   return ( rawAFMsg );
        MOV.W   &rawAFMsg, R12
        RETA
          CFI EndBlock cfiBlock7
//  475 }
//  476 
//  477 /*********************************************************************
//  478  * @fn          zcl_registerPlugin
//  479  *
//  480  * @brief       Add a Cluster Library handler
//  481  *
//  482  * @param       startClusterID - starting cluster ID
//  483  * @param       endClusterID - ending cluster ID
//  484  * @param       pfnHdlr - function pointer to incoming message handler
//  485  *
//  486  * @return      ZSuccess if OK
//  487  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  488 ZStatus_t zcl_registerPlugin( uint16 startClusterID,
zcl_registerPlugin:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function zcl_registerPlugin
//  489           uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
//  490 {
        FUNCALL zcl_registerPlugin, osal_mem_alloc
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R12, R8
        MOV.W   R13, R9
        MOV.W   R14, R10
        MOV.W   R15, R11
//  491   zclLibPlugin_t *pNewItem;
//  492   zclLibPlugin_t *pLoop;
//  493 
//  494   // Fill in the new profile list
//  495   pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
        MOV.W   #0xa, R12
        CALLA   #??Subroutine5_0
//  496   if ( pNewItem == NULL )
??CrossCallReturnLabel_50:
        JNE     ??zcl_registerPlugin_3
//  497   {
//  498     return (ZMemError);
        MOV.B   #0x10, R12
        JMP     ??zcl_registerPlugin_4
//  499   }
//  500 
//  501   // Fill in the plugin record.
//  502   pNewItem->next = (zclLibPlugin_t *)NULL;
??zcl_registerPlugin_3:
        MOV.W   #0x0, 0(R12)
//  503   pNewItem->startClusterID = startClusterID;
        MOV.W   R8, 0x2(R12)
//  504   pNewItem->endClusterID = endClusterID;
        MOV.W   R9, 0x4(R12)
//  505   pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
        MOV.W   R10, 0x6(R12)
        MOV.W   R11, 0x8(R12)
//  506 
//  507   // Find spot in list
//  508   if (  plugins == NULL )
        MOV.W   &plugins, R15
        CMP.W   #0x0, R15
        JNE     ??zcl_registerPlugin_2
//  509   {
//  510     plugins = pNewItem;
        MOV.W   R12, &plugins
        JMP     ??zcl_registerPlugin_5
//  511   }
//  512   else
//  513   {
//  514     // Look for end of list
//  515     pLoop = plugins;
//  516     while ( pLoop->next != NULL )
//  517     {
//  518       pLoop = pLoop->next;
??zcl_registerPlugin_0:
        MOV.W   R11, R15
//  519     }
??zcl_registerPlugin_2:
        MOV.W   @R15, R11
        CMP.W   #0x0, R11
        JNE     ??zcl_registerPlugin_0
//  520 
//  521     // Put new item at end of list
//  522     pLoop->next = pNewItem;
        MOV.W   R12, 0(R15)
//  523   }
//  524 
//  525   return ( ZSuccess );
??zcl_registerPlugin_5:
        MOV.B   #0x0, R12
??zcl_registerPlugin_4:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock8
//  526 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine5:
          CFI Block cfiCond9 Using cfiCommon0
          CFI Function zclParseInWriteRspCmd
          CFI Conditional ??CrossCallReturnLabel_45
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
          CFI Block cfiCond10 Using cfiCommon0
          CFI (cfiCond10) Function zclParseInReadCmd
          CFI (cfiCond10) Conditional ??CrossCallReturnLabel_46
          CFI (cfiCond10) R10L Frame(CFA, -8)
          CFI (cfiCond10) R11L Frame(CFA, -6)
          CFI (cfiCond10) CFA SP+12
          CFI Block cfiPicker11 Using cfiCommon1
          CFI (cfiPicker11) NoFunction
          CFI (cfiPicker11) Picker
        MOV.W   0x2(R11), R12
        ADD.W   #0x2, R12
          CFI EndBlock cfiCond9
          CFI EndBlock cfiCond10
          CFI EndBlock cfiPicker11
        REQUIRE ??Subroutine5_0
        // Fall through to label ??Subroutine5_0

        RSEG CODE:CODE:REORDER:NOROOT(1)
??Subroutine5_0:
          CFI Block cfiCond12 Using cfiCommon0
          CFI Function zclParseInDefaultRspCmd
          CFI Conditional ??CrossCallReturnLabel_47
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+10
          CFI Block cfiCond13 Using cfiCommon0
          CFI (cfiCond13) Function zcl_registerClusterOptionList
          CFI (cfiCond13) Conditional ??CrossCallReturnLabel_48
          CFI (cfiCond13) R8L Frame(CFA, -12)
          CFI (cfiCond13) R9L Frame(CFA, -10)
          CFI (cfiCond13) R10L Frame(CFA, -8)
          CFI (cfiCond13) R11L Frame(CFA, -6)
          CFI (cfiCond13) CFA SP+16
          CFI Block cfiCond14 Using cfiCommon0
          CFI (cfiCond14) Function zcl_registerAttrList
          CFI (cfiCond14) Conditional ??CrossCallReturnLabel_49
          CFI (cfiCond14) R8L Frame(CFA, -12)
          CFI (cfiCond14) R9L Frame(CFA, -10)
          CFI (cfiCond14) R10L Frame(CFA, -8)
          CFI (cfiCond14) R11L Frame(CFA, -6)
          CFI (cfiCond14) CFA SP+16
          CFI Block cfiCond15 Using cfiCommon0
          CFI (cfiCond15) Function zcl_registerPlugin
          CFI (cfiCond15) Conditional ??CrossCallReturnLabel_50
          CFI (cfiCond15) R8L Frame(CFA, -12)
          CFI (cfiCond15) R9L Frame(CFA, -10)
          CFI (cfiCond15) R10L Frame(CFA, -8)
          CFI (cfiCond15) R11L Frame(CFA, -6)
          CFI (cfiCond15) CFA SP+16
          CFI Block cfiCond16 Using cfiCommon0
          CFI (cfiCond16) Function zclParseInWriteRspCmd
          CFI (cfiCond16) Conditional ??CrossCallReturnLabel_45
          CFI (cfiCond16) R8L Frame(CFA, -12)
          CFI (cfiCond16) R9L Frame(CFA, -10)
          CFI (cfiCond16) R10L Frame(CFA, -8)
          CFI (cfiCond16) R11L Frame(CFA, -6)
          CFI (cfiCond16) CFA SP+16
          CFI Block cfiCond17 Using cfiCommon0
          CFI (cfiCond17) Function zclParseInReadCmd
          CFI (cfiCond17) Conditional ??CrossCallReturnLabel_46
          CFI (cfiCond17) R10L Frame(CFA, -8)
          CFI (cfiCond17) R11L Frame(CFA, -6)
          CFI (cfiCond17) CFA SP+12
          CFI Block cfiPicker18 Using cfiCommon1
          CFI (cfiPicker18) NoFunction
          CFI (cfiPicker18) Picker
        CALLA   #osal_mem_alloc
        CMP.W   #0x0, R12
        RETA
          CFI EndBlock cfiCond12
          CFI EndBlock cfiCond13
          CFI EndBlock cfiCond14
          CFI EndBlock cfiCond15
          CFI EndBlock cfiCond16
          CFI EndBlock cfiCond17
          CFI EndBlock cfiPicker18
//  527 
//  528 #ifdef ZCL_DISCOVER
//  529 /*********************************************************************
//  530  * @fn          zcl_registerCmdList
//  531  *
//  532  * @brief       Register a Command List with ZCL Foundation
//  533  *
//  534  * @param       endpoint - endpoint the attribute list belongs to
//  535  * @param       newCmdList - array of command records
//  536  *
//  537  * @return      ZSuccess if OK
//  538  */
//  539 ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 numAttrs, CONST zclCommandRec_t zclTestApp_Cmds[] );
//  540 ZStatus_t zcl_registerCmdList( uint8 endpoint, uint8 zclCmdsArraySize, CONST zclCommandRec_t newCmdList[] )
//  541 {
//  542   zclCmdRecsList_t *pNewItem;
//  543   zclCmdRecsList_t *pLoop;
//  544 
//  545   // Fill in the new profile list
//  546   pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
//  547   if ( pNewItem == NULL )
//  548   {
//  549     return (ZMemError);
//  550   }
//  551 
//  552   pNewItem->pNext = (zclCmdRecsList_t *)NULL;
//  553   pNewItem->endpoint = endpoint;
//  554   pNewItem->numCommands = zclCmdsArraySize;
//  555   pNewItem->pCmdRecs = newCmdList;
//  556 
//  557   // Find spot in list
//  558   if ( gpCmdList == NULL )
//  559   {
//  560     gpCmdList = pNewItem;
//  561   }
//  562   else
//  563   {
//  564     // Look for end of list
//  565     pLoop = gpCmdList;
//  566     while ( pLoop->pNext != NULL )
//  567     {
//  568       pLoop = pLoop->pNext;
//  569     }
//  570 
//  571     // Put new item at end of list
//  572     pLoop->pNext = pNewItem;
//  573   }
//  574 
//  575   return ( ZSuccess );
//  576 }
//  577 #endif  // ZCL_DISCOVER
//  578 
//  579 /*********************************************************************
//  580  * @fn          zcl_registerAttrList
//  581  *
//  582  * @brief       Register an Attribute List with ZCL Foundation
//  583  *
//  584  * @param       endpoint - endpoint the attribute list belongs to
//  585  * @param       numAttr - number of attributes in list
//  586  * @param       newAttrList - array of Attribute records.
//  587  *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
//  588  *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
//  589  *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
//  590  *
//  591  * @return      ZSuccess if OK
//  592  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  593 ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
zcl_registerAttrList:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function zcl_registerAttrList
//  594 {
        FUNCALL zcl_registerAttrList, osal_mem_alloc
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.B   R12, R10
        MOV.B   R13, R11
        MOV.W   R14, R8
//  595   zclAttrRecsList *pNewItem;
//  596   zclAttrRecsList *pLoop;
//  597 
//  598   // Fill in the new profile list
//  599   pNewItem = zcl_mem_alloc( sizeof( zclAttrRecsList ) );
        MOV.W   #0x10, R12
        CALLA   #??Subroutine5_0
//  600   if ( pNewItem == NULL )
??CrossCallReturnLabel_49:
        JNE     ??zcl_registerAttrList_3
//  601   {
//  602     return (ZMemError);
        MOV.B   #0x10, R12
        JMP     ??zcl_registerAttrList_4
//  603   }
//  604 
//  605   pNewItem->next = (zclAttrRecsList *)NULL;
??zcl_registerAttrList_3:
        MOV.W   #0x0, 0(R12)
//  606   pNewItem->endpoint = endpoint;
        MOV.B   R10, 0x2(R12)
//  607   pNewItem->pfnReadWriteCB = NULL;
        MOV.W   #0x0, 0x4(R12)
        MOV.W   #0x0, 0x6(R12)
//  608   pNewItem->numAttributes = numAttr;
        MOV.B   R11, 0xc(R12)
//  609   pNewItem->attrs = newAttrList;
        MOV.W   R8, 0xe(R12)
//  610 
//  611   // Find spot in list
//  612   if ( attrList == NULL )
        MOV.W   &attrList, R15
        CMP.W   #0x0, R15
        JNE     ??zcl_registerAttrList_2
//  613   {
//  614     attrList = pNewItem;
        MOV.W   R12, &attrList
        JMP     ??zcl_registerAttrList_5
//  615   }
//  616   else
//  617   {
//  618     // Look for end of list
//  619     pLoop = attrList;
//  620     while ( pLoop->next != NULL )
//  621     {
//  622       pLoop = pLoop->next;
??zcl_registerAttrList_0:
        MOV.W   R11, R15
//  623     }
??zcl_registerAttrList_2:
        MOV.W   @R15, R11
        CMP.W   #0x0, R11
        JNE     ??zcl_registerAttrList_0
//  624 
//  625     // Put new item at end of list
//  626     pLoop->next = pNewItem;
        MOV.W   R12, 0(R15)
//  627   }
//  628 
//  629   return ( ZSuccess );
??zcl_registerAttrList_5:
        MOV.B   #0x0, R12
??zcl_registerAttrList_4:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock19
//  630 }
//  631 
//  632 /*********************************************************************
//  633  * @fn          zcl_registerClusterOptionList
//  634  *
//  635  * @brief       Register a Cluster Option List with ZCL Foundation
//  636  *
//  637  * @param       endpoint - endpoint the option list belongs to
//  638  * @param       numOption - number of options in list
//  639  * @param       optionList - array of cluster option records.
//  640  *
//  641  *              NOTE: This API should be called to enable 'Application
//  642  *                    Link Key' security and/or 'APS ACK' for a specific
//  643  *                    Cluster. The 'Application Link Key' is discarded
//  644  *                    if security isn't enabled on the device.
//  645  *                    The default behavior is 'Network Key' when security
//  646  *                    is enabled and no 'APS ACK' for the ZCL messages.
//  647  *
//  648  * @return      ZSuccess if OK
//  649  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  650 ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
zcl_registerClusterOptionList:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function zcl_registerClusterOptionList
//  651 {
        FUNCALL zcl_registerClusterOptionList, osal_mem_alloc
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.B   R12, R10
        MOV.B   R13, R11
        MOV.W   R14, R8
//  652   zclClusterOptionList *pNewItem;
//  653   zclClusterOptionList *pLoop;
//  654 
//  655   // Fill in the new profile list
//  656   pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
        MOV.W   #0x6, R12
        CALLA   #??Subroutine5_0
//  657   if ( pNewItem == NULL )
??CrossCallReturnLabel_48:
        JNE     ??zcl_registerClusterOptionList_3
//  658   {
//  659     return (ZMemError);
        MOV.B   #0x10, R12
        JMP     ??zcl_registerClusterOptionList_4
//  660   }
//  661 
//  662   pNewItem->next = (zclClusterOptionList *)NULL;
??zcl_registerClusterOptionList_3:
        MOV.W   #0x0, 0(R12)
//  663   pNewItem->endpoint = endpoint;
        MOV.B   R10, 0x2(R12)
//  664   pNewItem->numOptions = numOption;
        MOV.B   R11, 0x3(R12)
//  665   pNewItem->options = optionList;
        MOV.W   R8, 0x4(R12)
//  666 
//  667   // Find spot in list
//  668   if ( clusterOptionList == NULL )
        MOV.W   &clusterOptionList, R15
        CMP.W   #0x0, R15
        JNE     ??zcl_registerClusterOptionList_2
//  669   {
//  670     clusterOptionList = pNewItem;
        MOV.W   R12, &clusterOptionList
        JMP     ??zcl_registerClusterOptionList_5
//  671   }
//  672   else
//  673   {
//  674     // Look for end of list
//  675     pLoop = clusterOptionList;
//  676     while ( pLoop->next != NULL )
//  677     {
//  678       pLoop = pLoop->next;
??zcl_registerClusterOptionList_0:
        MOV.W   R11, R15
//  679     }
??zcl_registerClusterOptionList_2:
        MOV.W   @R15, R11
        CMP.W   #0x0, R11
        JNE     ??zcl_registerClusterOptionList_0
//  680 
//  681     // Put new item at end of list
//  682     pLoop->next = pNewItem;
        MOV.W   R12, 0(R15)
//  683   }
//  684 
//  685   return ( ZSuccess );
??zcl_registerClusterOptionList_5:
        MOV.B   #0x0, R12
??zcl_registerClusterOptionList_4:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock20
//  686 }
//  687 
//  688 /*********************************************************************
//  689  * @fn          zcl_registerValidateAttrData
//  690  *
//  691  * @brief       Add a validation function for attribute data
//  692  *
//  693  * @param       pfnValidateAttrData - function pointer to validate routine
//  694  *
//  695  * @return      ZSuccess if OK
//  696  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  697 ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
zcl_registerValidateAttrData:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function zcl_registerValidateAttrData
//  698 {
//  699   zcl_ValidateAttrDataCB = pfnValidateAttrData;
        MOV.W   R12, &zcl_ValidateAttrDataCB
        MOV.W   R13, &zcl_ValidateAttrDataCB + 2
//  700 
//  701   return ( ZSuccess );
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock21
//  702 }
//  703 
//  704 /*********************************************************************
//  705  * @fn          zcl_registerReadWriteCB
//  706  *
//  707  * @brief       Register the application's callback function to read/write
//  708  *              attribute data, and authorize read/write operation.
//  709  *
//  710  *              Note: The pfnReadWriteCB callback function is only required
//  711  *                    when the attribute data format is unknown to ZCL. The
//  712  *                    callback function gets called when the pointer 'dataPtr'
//  713  *                    to the attribute value is NULL in the attribute database
//  714  *                    registered with the ZCL.
//  715  *
//  716  *              Note: The pfnAuthorizeCB callback function is only required
//  717  *                    when the Read/Write operation on an attribute requires
//  718  *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
//  719  *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
//  720  *
//  721  * @param       endpoint - application's endpoint
//  722  * @param       pfnReadWriteCB - function pointer to read/write routine
//  723  * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
//  724  *
//  725  * @return      ZSuccess if successful. ZFailure, otherwise.
//  726  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  727 ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
zcl_registerReadWriteCB:
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function zcl_registerReadWriteCB
//  728                                    zclAuthorizeCB_t pfnAuthorizeCB )
//  729 {
        FUNCALL zcl_registerReadWriteCB, zclFindAttrRecsList
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.W   R15, R11
//  730   zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
        CALLA   #zclFindAttrRecsList
//  731 
//  732   if ( pRec != NULL )
        CMP.W   #0x0, R12
        JEQ     ??zcl_registerReadWriteCB_0
//  733   {
//  734     pRec->pfnReadWriteCB = pfnReadWriteCB;
        MOV.W   R14, 0x4(R12)
        MOV.W   R11, 0x6(R12)
//  735     pRec->pfnAuthorizeCB = pfnAuthorizeCB;
        MOV.W   0x8(SP), 0x8(R12)
        MOV.W   0xa(SP), 0xa(R12)
//  736 
//  737     return ( ZSuccess );
        MOV.B   #0x0, R12
        JMP     ??zcl_registerReadWriteCB_1
//  738   }
//  739 
//  740   return ( ZFailure );
??zcl_registerReadWriteCB_0:
        MOV.B   #0x1, R12
??zcl_registerReadWriteCB_1:
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock22
//  741 }
//  742 
//  743 /*********************************************************************
//  744  * @fn      zcl_DeviceOperational
//  745  *
//  746  * @brief   Used to see whether or not the device can send or respond
//  747  *          to application level commands.
//  748  *
//  749  * @param   srcEP - source endpoint
//  750  * @param   clusterID - cluster ID
//  751  * @param   frameType - command type
//  752  * @param   cmd - command ID
//  753  *
//  754  * @return  TRUE if device is operational, FALSE otherwise
//  755  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  756 static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
zcl_DeviceOperational:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function zcl_DeviceOperational
//  757                                     uint8 frameType, uint8 cmd, uint16 profileID )
//  758 {
        FUNCALL zcl_DeviceOperational, zclFindAttrRec
        LOCFRAME CSTACK, 14, STACK
        FUNCALL zcl_DeviceOperational, zclReadAttrData
        LOCFRAME CSTACK, 14, STACK
        SUB.W   #0xa, SP
          CFI CFA SP+14
//  759   zclAttrRec_t attrRec;
//  760   uint8 deviceEnabled = DEVICE_ENABLED; // default value
        MOV.B   #0x1, 0(SP)
//  761 
//  762   (void)profileID;  // Intentionally unreferenced parameter
//  763 
//  764   // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
//  765   // cannot send or respond to application level commands, other than commands
//  766   // to read or write attributes. Note that the Identify cluster cannot be
//  767   // disabled, and remains functional regardless of this setting.
//  768   if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
        CMP.B   #0x0, R14
        JNE     ??zcl_DeviceOperational_4
        CMP.B   #0x6, R15
        JNC     ??zcl_DeviceOperational_1
//  769   {
//  770     return ( TRUE );
//  771   }
//  772 
//  773   if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
??zcl_DeviceOperational_4:
        CMP.W   #0x3, R13
        JEQ     ??zcl_DeviceOperational_1
//  774   {
//  775     return ( TRUE );
//  776   }
//  777 
//  778   // Is device enabled?
//  779   if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
//  780                        ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
        MOV.W   SP, R15
        ADD.W   #0x2, R15
        MOV.W   #0x12, R14
        MOV.W   #0x0, R13
        CALLA   #??Subroutine9_0
??CrossCallReturnLabel_44:
        JEQ     ??zcl_DeviceOperational_5
//  781   {
//  782 #ifdef ZCL_READ
//  783     zclReadAttrData( &deviceEnabled, &attrRec, NULL );
        MOV.W   #0x0, R14
        MOV.W   SP, R13
        ADD.W   #0x2, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #zclReadAttrData
//  784 #endif
//  785   }
//  786 
//  787   return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
??zcl_DeviceOperational_5:
        CMP.B   #0x1, 0(SP)
        JEQ     ??zcl_DeviceOperational_1
        MOV.B   #0x0, R12
        JMP     ??zcl_DeviceOperational_0
??zcl_DeviceOperational_1:
        MOV.B   #0x1, R12
??zcl_DeviceOperational_0:
        ADD.W   #0xa, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock23
//  788 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine9:
          CFI Block cfiCond24 Using cfiCommon0
          CFI Function zclProcessInWriteUndividedCmd
          CFI Conditional ??CrossCallReturnLabel_38
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+36
          CFI Block cfiCond25 Using cfiCommon0
          CFI (cfiCond25) Function zclProcessInWriteCmd
          CFI (cfiCond25) Conditional ??CrossCallReturnLabel_39
          CFI (cfiCond25) R4L Frame(CFA, -20)
          CFI (cfiCond25) R5L Frame(CFA, -18)
          CFI (cfiCond25) R6L Frame(CFA, -16)
          CFI (cfiCond25) R7L Frame(CFA, -14)
          CFI (cfiCond25) R8L Frame(CFA, -12)
          CFI (cfiCond25) R9L Frame(CFA, -10)
          CFI (cfiCond25) R10L Frame(CFA, -8)
          CFI (cfiCond25) R11L Frame(CFA, -6)
          CFI (cfiCond25) CFA SP+32
          CFI Block cfiPicker26 Using cfiCommon1
          CFI (cfiPicker26) NoFunction
          CFI (cfiPicker26) Picker
        MOV.W   @R4, R14
          CFI EndBlock cfiCond24
          CFI EndBlock cfiCond25
          CFI EndBlock cfiPicker26
        REQUIRE ??Subroutine28_0
        // Fall through to label ??Subroutine28_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine28_0:
          CFI Block cfiCond27 Using cfiCommon0
          CFI Function zclRevertWriteUndividedCmd
          CFI Conditional ??CrossCallReturnLabel_40
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+28
          CFI Block cfiCond28 Using cfiCommon0
          CFI (cfiCond28) Function zclProcessInWriteUndividedCmd
          CFI (cfiCond28) Conditional ??CrossCallReturnLabel_38
          CFI (cfiCond28) R4L Frame(CFA, -20)
          CFI (cfiCond28) R5L Frame(CFA, -18)
          CFI (cfiCond28) R6L Frame(CFA, -16)
          CFI (cfiCond28) R7L Frame(CFA, -14)
          CFI (cfiCond28) R8L Frame(CFA, -12)
          CFI (cfiCond28) R9L Frame(CFA, -10)
          CFI (cfiCond28) R10L Frame(CFA, -8)
          CFI (cfiCond28) R11L Frame(CFA, -6)
          CFI (cfiCond28) CFA SP+36
          CFI Block cfiCond29 Using cfiCommon0
          CFI (cfiCond29) Function zclProcessInWriteCmd
          CFI (cfiCond29) Conditional ??CrossCallReturnLabel_39
          CFI (cfiCond29) R4L Frame(CFA, -20)
          CFI (cfiCond29) R5L Frame(CFA, -18)
          CFI (cfiCond29) R6L Frame(CFA, -16)
          CFI (cfiCond29) R7L Frame(CFA, -14)
          CFI (cfiCond29) R8L Frame(CFA, -12)
          CFI (cfiCond29) R9L Frame(CFA, -10)
          CFI (cfiCond29) R10L Frame(CFA, -8)
          CFI (cfiCond29) R11L Frame(CFA, -6)
          CFI (cfiCond29) CFA SP+32
          CFI Block cfiPicker30 Using cfiCommon1
          CFI (cfiPicker30) NoFunction
          CFI (cfiPicker30) Picker
        MOV.W   0x4(R12), R13
        MOV.B   0x14(R12), R12
          CFI EndBlock cfiCond27
          CFI EndBlock cfiCond28
          CFI EndBlock cfiCond29
          CFI EndBlock cfiPicker30
        REQUIRE ??Subroutine9_0
        // Fall through to label ??Subroutine9_0

        RSEG CODE:CODE:REORDER:NOROOT(1)
??Subroutine9_0:
          CFI Block cfiCond31 Using cfiCommon0
          CFI Function zclProcessInWriteUndividedCmd
          CFI Conditional ??CrossCallReturnLabel_41
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+36
          CFI Block cfiCond32 Using cfiCommon0
          CFI (cfiCond32) Function zclProcessInReadCmd
          CFI (cfiCond32) Conditional ??CrossCallReturnLabel_42
          CFI (cfiCond32) R4L Frame(CFA, -20)
          CFI (cfiCond32) R5L Frame(CFA, -18)
          CFI (cfiCond32) R6L Frame(CFA, -16)
          CFI (cfiCond32) R7L Frame(CFA, -14)
          CFI (cfiCond32) R8L Frame(CFA, -12)
          CFI (cfiCond32) R9L Frame(CFA, -10)
          CFI (cfiCond32) R10L Frame(CFA, -8)
          CFI (cfiCond32) R11L Frame(CFA, -6)
          CFI (cfiCond32) CFA SP+32
          CFI Block cfiCond33 Using cfiCommon0
          CFI (cfiCond33) Function zcl_ReadAttrData
          CFI (cfiCond33) Conditional ??CrossCallReturnLabel_43
          CFI (cfiCond33) R8L Frame(CFA, -12)
          CFI (cfiCond33) R9L Frame(CFA, -10)
          CFI (cfiCond33) R10L Frame(CFA, -8)
          CFI (cfiCond33) R11L Frame(CFA, -6)
          CFI (cfiCond33) CFA SP+24
          CFI Block cfiCond34 Using cfiCommon0
          CFI (cfiCond34) Function zcl_DeviceOperational
          CFI (cfiCond34) Conditional ??CrossCallReturnLabel_44
          CFI (cfiCond34) CFA SP+18
          CFI Block cfiCond35 Using cfiCommon0
          CFI (cfiCond35) Function zclRevertWriteUndividedCmd
          CFI (cfiCond35) Conditional ??CrossCallReturnLabel_40
          CFI (cfiCond35) R6L Frame(CFA, -16)
          CFI (cfiCond35) R7L Frame(CFA, -14)
          CFI (cfiCond35) R8L Frame(CFA, -12)
          CFI (cfiCond35) R9L Frame(CFA, -10)
          CFI (cfiCond35) R10L Frame(CFA, -8)
          CFI (cfiCond35) R11L Frame(CFA, -6)
          CFI (cfiCond35) CFA SP+28
          CFI Block cfiCond36 Using cfiCommon0
          CFI (cfiCond36) Function zclProcessInWriteUndividedCmd
          CFI (cfiCond36) Conditional ??CrossCallReturnLabel_38
          CFI (cfiCond36) R4L Frame(CFA, -20)
          CFI (cfiCond36) R5L Frame(CFA, -18)
          CFI (cfiCond36) R6L Frame(CFA, -16)
          CFI (cfiCond36) R7L Frame(CFA, -14)
          CFI (cfiCond36) R8L Frame(CFA, -12)
          CFI (cfiCond36) R9L Frame(CFA, -10)
          CFI (cfiCond36) R10L Frame(CFA, -8)
          CFI (cfiCond36) R11L Frame(CFA, -6)
          CFI (cfiCond36) CFA SP+36
          CFI Block cfiCond37 Using cfiCommon0
          CFI (cfiCond37) Function zclProcessInWriteCmd
          CFI (cfiCond37) Conditional ??CrossCallReturnLabel_39
          CFI (cfiCond37) R4L Frame(CFA, -20)
          CFI (cfiCond37) R5L Frame(CFA, -18)
          CFI (cfiCond37) R6L Frame(CFA, -16)
          CFI (cfiCond37) R7L Frame(CFA, -14)
          CFI (cfiCond37) R8L Frame(CFA, -12)
          CFI (cfiCond37) R9L Frame(CFA, -10)
          CFI (cfiCond37) R10L Frame(CFA, -8)
          CFI (cfiCond37) R11L Frame(CFA, -6)
          CFI (cfiCond37) CFA SP+32
          CFI Block cfiPicker38 Using cfiCommon1
          CFI (cfiPicker38) NoFunction
          CFI (cfiPicker38) Picker
        CALLA   #zclFindAttrRec
        CMP.B   #0x0, R12
        RETA
          CFI EndBlock cfiCond31
          CFI EndBlock cfiCond32
          CFI EndBlock cfiCond33
          CFI EndBlock cfiCond34
          CFI EndBlock cfiCond35
          CFI EndBlock cfiCond36
          CFI EndBlock cfiCond37
          CFI EndBlock cfiPicker38
//  789 
//  790 /*********************************************************************
//  791  * @fn      zcl_SendCommand
//  792  *
//  793  * @brief   Used to send Profile and Cluster Specific Command messages.
//  794  *
//  795  *          NOTE: The calling application is responsible for incrementing
//  796  *                the Sequence Number.
//  797  *
//  798  * @param   srcEp - source endpoint
//  799  * @param   destAddr - destination address
//  800  * @param   clusterID - cluster ID
//  801  * @param   cmd - command ID
//  802  * @param   specific - whether the command is Cluster Specific
//  803  * @param   direction - client/server direction of the command
//  804  * @param   disableDefaultRsp - disable Default Response command
//  805  * @param   manuCode - manufacturer code for proprietary extensions to a profile
//  806  * @param   seqNumber - identification number for the transaction
//  807  * @param   cmdFormatLen - length of the command to be sent
//  808  * @param   cmdFormat - command to be sent
//  809  *
//  810  * @return  ZSuccess if OK
//  811  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine6:
          CFI Block cfiCond39 Using cfiCommon0
          CFI Function zclProcessInWriteUndividedCmd
          CFI Conditional ??CrossCallReturnLabel_0
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+36
          CFI Block cfiCond40 Using cfiCommon0
          CFI (cfiCond40) Function zclProcessInReadCmd
          CFI (cfiCond40) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond40) R4L Frame(CFA, -20)
          CFI (cfiCond40) R5L Frame(CFA, -18)
          CFI (cfiCond40) R6L Frame(CFA, -16)
          CFI (cfiCond40) R7L Frame(CFA, -14)
          CFI (cfiCond40) R8L Frame(CFA, -12)
          CFI (cfiCond40) R9L Frame(CFA, -10)
          CFI (cfiCond40) R10L Frame(CFA, -8)
          CFI (cfiCond40) R11L Frame(CFA, -6)
          CFI (cfiCond40) CFA SP+32
          CFI Block cfiCond41 Using cfiCommon0
          CFI (cfiCond41) Function zcl_SendCommand
          CFI (cfiCond41) Conditional ??CrossCallReturnLabel_2
          CFI (cfiCond41) R4L Frame(CFA, -20)
          CFI (cfiCond41) R5L Frame(CFA, -18)
          CFI (cfiCond41) R6L Frame(CFA, -16)
          CFI (cfiCond41) R7L Frame(CFA, -14)
          CFI (cfiCond41) R8L Frame(CFA, -12)
          CFI (cfiCond41) R9L Frame(CFA, -10)
          CFI (cfiCond41) R10L Frame(CFA, -8)
          CFI (cfiCond41) R11L Frame(CFA, -6)
          CFI (cfiCond41) CFA SP+30
          CFI Block cfiPicker42 Using cfiCommon1
          CFI (cfiPicker42) NoFunction
          CFI (cfiPicker42) Picker
        CALLA   #osal_mem_alloc
        MOV.W   R12, R6
        CMP.W   #0x0, R12
        RETA
          CFI EndBlock cfiCond39
          CFI EndBlock cfiCond40
          CFI EndBlock cfiCond41
          CFI EndBlock cfiPicker42

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  812 ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
zcl_SendCommand:
          CFI Block cfiBlock43 Using cfiCommon0
          CFI Function zcl_SendCommand
//  813                            uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
//  814                            uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
//  815                            uint16 cmdFormatLen, uint8 *cmdFormat )
//  816 {
        FUNCALL zcl_SendCommand, afFindEndPointDesc
        LOCFRAME CSTACK, 26, STACK
        FUNCALL zcl_SendCommand, zclGetClusterOption
        LOCFRAME CSTACK, 26, STACK
        FUNCALL zcl_SendCommand, osal_memset
        LOCFRAME CSTACK, 26, STACK
        FUNCALL zcl_SendCommand, zcl_DeviceOperational
        LOCFRAME CSTACK, 28, STACK
        FUNCALL zcl_SendCommand, osal_mem_alloc
        LOCFRAME CSTACK, 26, STACK
        FUNCALL zcl_SendCommand, zclBuildHdr
        LOCFRAME CSTACK, 26, STACK
        FUNCALL zcl_SendCommand, osal_memcpy
        LOCFRAME CSTACK, 26, STACK
        FUNCALL zcl_SendCommand, AF_DataRequest
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zcl_SendCommand, osal_mem_free
        LOCFRAME CSTACK, 34, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        SUB.W   #0x6, SP
          CFI CFA SP+26
        MOV.B   R12, R10
        MOV.W   R13, R7
        MOV.W   R14, R11
        MOV.B   R15, R6
//  817   endPointDesc_t *epDesc;
//  818   zclFrameHdr_t hdr;
//  819   uint8 *msgBuf;
//  820   uint16 msgLen;
//  821   uint8 *pBuf;
//  822   uint8 options;
//  823   ZStatus_t status;
//  824 
//  825   epDesc = afFindEndPointDesc( srcEP );
        CALLA   #afFindEndPointDesc
        MOV.W   R12, R8
//  826   if ( epDesc == NULL )
        CMP.W   #0x0, R12
        JNE     ??zcl_SendCommand_1
//  827   {
//  828     return ( ZInvalidParameter ); // EMBEDDED RETURN
        MOV.B   #0x2, R12
        JMP     ??zcl_SendCommand_2
//  829   }
//  830 
//  831 #if defined ( INTER_PAN )
//  832   if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
//  833   {
//  834     options = AF_TX_OPTIONS_NONE;
//  835   }
//  836   else
//  837 #endif
//  838   {
//  839     options = zclGetClusterOption( srcEP, clusterID );
??zcl_SendCommand_1:
        MOV.W   R11, R13
        MOV.B   R10, R12
        CALLA   #zclGetClusterOption
        MOV.B   R12, R9
//  840 
//  841     // The cluster might not have been defined to use security but if this message
//  842     // is in response to another message that was using APS security this message
//  843     // will be sent with APS security
//  844     if ( !( options & AF_EN_SECURITY ) )
        BIT.B   #0x40, R12
        JC      ??zcl_SendCommand_3
//  845     {
//  846       afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
        MOV.W   &rawAFMsg, R15
//  847 
//  848       if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
        CMP.W   #0x0, R15
        JEQ     ??zcl_SendCommand_3
        CMP.B   #0x1, 0x19(R15)
        JNE     ??zcl_SendCommand_3
//  849       {
//  850         options |= AF_EN_SECURITY;
        BIS.B   #0x40, R9
//  851       }
//  852     }
//  853   }
//  854 
//  855   zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
??zcl_SendCommand_3:
        MOV.W   #0x6, R14
        MOV.B   #0x0, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #osal_memset
//  856 
//  857   // Not Profile wide command (like READ, WRITE)
//  858   if ( specific )
        MOV.W   @SP, R15
        AND.W   #0xfffc, R15
        CMP.B   #0x0, 0x1a(SP)
        JEQ     ??zcl_SendCommand_0
//  859   {
//  860     hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
        BIS.W   #0x1, R15
//  861   }
//  862   else
//  863   {
//  864     hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
??zcl_SendCommand_0:
        MOV.W   R15, 0(SP)
//  865   }
//  866 
//  867   if ( ( epDesc->simpleDesc == NULL ) ||
//  868        ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
//  869                                 cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
        MOV.W   0x4(R8), R15
        CMP.W   #0x0, R15
        JEQ     ??zcl_SendCommand_4
        PUSH.W  0x2(R15)
          CFI CFA SP+28
        MOV.B   R6, R15
        MOV.B   0x2(SP), R14
        AND.B   #0x3, R14
        MOV.W   R11, R13
        MOV.B   R10, R12
        CALLA   #zcl_DeviceOperational
        ADD.W   #0x2, SP
          CFI CFA SP+26
        CMP.B   #0x0, R12
        JNE     ??zcl_SendCommand_5
//  870   {
//  871     return ( ZFailure ); // EMBEDDED RETURN
??zcl_SendCommand_4:
        MOV.B   #0x1, R12
        JMP     ??zcl_SendCommand_2
//  872   }
??zcl_SendCommand_5:
        MOV.W   0x20(SP), R15
//  873 
//  874   // Fill in the Maufacturer Code
//  875   if ( manuCode != 0 )
        CMP.W   #0x0, R15
        JEQ     ??zcl_SendCommand_6
//  876   {
//  877     hdr.fc.manuSpecific = 1;
        BIS.W   #0x4, 0(SP)
//  878     hdr.manuCode = manuCode;
        MOV.W   R15, 0x2(SP)
//  879   }
//  880 
//  881   // Set the Command Direction
//  882   if ( direction )
??zcl_SendCommand_6:
        CMP.B   #0x0, 0x1c(SP)
        JEQ     ??zcl_SendCommand_7
//  883   {
//  884     hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
        BIS.W   #0x8, 0(SP)
        JMP     ??zcl_SendCommand_8
//  885   }
//  886   else
//  887   {
//  888     hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
??zcl_SendCommand_7:
        BIC.W   #0x8, 0(SP)
//  889   }
//  890 
//  891   // Set the Disable Default Response field
//  892   if ( disableDefaultRsp )
??zcl_SendCommand_8:
        CMP.B   #0x0, 0x1e(SP)
        JEQ     ??zcl_SendCommand_9
//  893   {
//  894     hdr.fc.disableDefaultRsp = 1;
        BIS.W   #0x10, 0(SP)
        JMP     ??zcl_SendCommand_10
//  895   }
//  896   else
//  897   {
//  898     hdr.fc.disableDefaultRsp = 0;
??zcl_SendCommand_9:
        BIC.W   #0x10, 0(SP)
//  899   }
//  900 
//  901   // Fill in the Transaction Sequence Number
//  902   hdr.transSeqNum = seqNum;
??zcl_SendCommand_10:
        MOV.B   0x22(SP), 0x4(SP)
//  903 
//  904   // Fill in the command
//  905   hdr.commandID = cmd;
        MOV.B   R6, 0x5(SP)
//  906 
//  907   // calculate the needed buffer size
//  908   msgLen = zclCalcHdrSize( &hdr );
        MOV.B   #0x3, R10
        BIT.W   #0x4, 0(SP)
        JNC     ??zcl_SendCommand_11
        MOV.B   #0x5, R10
??zcl_SendCommand_11:
        MOV.W   0x24(SP), R4
//  909   msgLen += cmdFormatLen;
        ADD.W   R4, R10
//  910 
//  911   // Allocate the buffer needed
//  912   msgBuf = zcl_mem_alloc( msgLen );
        MOV.W   R10, R12
        CALLA   #?Subroutine6
//  913   if ( msgBuf != NULL )
??CrossCallReturnLabel_2:
        JEQ     ??zcl_SendCommand_12
//  914   {
//  915     // Fill in the ZCL Header
//  916     pBuf = zclBuildHdr( &hdr, msgBuf );
        MOV.W   R12, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #zclBuildHdr
//  917 
//  918     // Fill in the command frame
//  919     zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
        MOV.W   R4, R14
        MOV.W   0x26(SP), R13
        CALLA   #osal_memcpy
//  920 
//  921     status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
//  922                              &zcl_TransID, options, AF_DEFAULT_RADIUS );
        PUSH.B  #0x1e
          CFI CFA SP+28
        PUSH.B  R9
          CFI CFA SP+30
        PUSH.W  #zcl_TransID
          CFI CFA SP+32
        PUSH.W  R6
          CFI CFA SP+34
        MOV.W   R10, R15
        MOV.W   R11, R14
        MOV.W   R8, R13
        MOV.W   R7, R12
        CALLA   #AF_DataRequest
        MOV.B   R12, R10
//  923     zcl_mem_free ( msgBuf );
        MOV.W   R6, R12
        CALLA   #osal_mem_free
        ADD.W   #0x8, SP
          CFI CFA SP+26
        JMP     ??zcl_SendCommand_13
//  924   }
//  925   else
//  926   {
//  927     status = ZMemError;
??zcl_SendCommand_12:
        MOV.B   #0x10, R10
//  928   }
//  929 
//  930   return ( status );
??zcl_SendCommand_13:
        MOV.B   R10, R12
??zcl_SendCommand_2:
        ADD.W   #0x6, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock43
//  931 }

        RSEG CODE:CODE:NOROOT(1)
zcl_SendWriteRsp:
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function zcl_SendWriteRsp
        FUNCALL zcl_SendWriteRsp, osal_mem_alloc
        LOCFRAME CSTACK, 16, STACK
        FUNCALL zcl_SendWriteRsp, zcl_SendCommand
        LOCFRAME CSTACK, 30, STACK
        FUNCALL zcl_SendWriteRsp, osal_mem_free
        LOCFRAME CSTACK, 30, STACK
        PUSHM.W #0x6, R11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
        MOV.B   R12, R10
        MOV.W   R13, R11
        MOV.W   R14, R8
        MOV.W   R15, R6
        MOV.B   @R6, R15
        MOV.W   R15, R7
        RPT     #0x2
        ADDX.W  R15, R7
        MOV.W   R7, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, R9
        CMP.W   #0x0, R12
        JEQ     ??zcl_SendWriteRsp_1
        MOV.W   R12, R15
        MOV.B   #0x0, R14
        JMP     ??zcl_SendWriteRsp_2
??zcl_SendWriteRsp_0:
        MOV.B   R14, R12
        RLAM.W  #0x2, R12
        MOV.W   R6, R13
        ADD.W   R12, R13
        MOV.B   0x2(R13), 0(R15)
        ADD.W   #0x1, R15
        ADD.W   #0x4, R13
        CALLA   #?Subroutine8
??zcl_SendWriteRsp_2:
        MOV.B   @R6, R13
        CMP.B   R13, R14
        JNC     ??zcl_SendWriteRsp_0
        CMP.B   #0x1, R13
        JNE     ??zcl_SendWriteRsp_3
        CMP.B   #0x0, 0x2(R6)
        JNE     ??zcl_SendWriteRsp_3
        MOV.W   #0x1, R7
??zcl_SendWriteRsp_3:
        PUSH.W  R9
          CFI CFA SP+18
        PUSH.W  R7
          CFI CFA SP+20
        PUSH.B  0x1a(SP)
          CFI CFA SP+22
        PUSH.W  #0x0
          CFI CFA SP+24
        PUSH.B  0x1c(SP)
          CFI CFA SP+26
        PUSH.B  0x1c(SP)
          CFI CFA SP+28
        PUSH.B  #0x0
          CFI CFA SP+30
        MOV.B   #0x4, R15
        MOV.W   R8, R14
        MOV.W   R11, R13
        CALLA   #?Subroutine20
??CrossCallReturnLabel_16:
        MOV.B   R12, R10
        MOV.W   R9, R12
        CALLA   #osal_mem_free
        ADD.W   #0xe, SP
          CFI CFA SP+16
        JMP     ??zcl_SendWriteRsp_4
??zcl_SendWriteRsp_1:
        MOV.B   #0x10, R10
          CFI EndBlock cfiBlock44
??zcl_SendWriteRsp_4:
        REQUIRE ?Subroutine3
        // Fall through to label ?Subroutine3
//  932 
//  933 #ifdef ZCL_READ
//  934 /*********************************************************************
//  935  * @fn      zcl_SendRead
//  936  *
//  937  * @brief   Send a Read command
//  938  *
//  939  * @param   srcEP - Application's endpoint
//  940  * @param   dstAddr - destination address
//  941  * @param   clusterID - cluster ID
//  942  * @param   readCmd - read command to be sent
//  943  * @param   direction - direction of the command
//  944  * @param   seqNum - transaction sequence number
//  945  *
//  946  * @return  ZSuccess if OK
//  947  */

        RSEG CODE:CODE:NOROOT(1)
?Subroutine3:
          CFI Block cfiBlock45 Using cfiCommon0
          CFI NoFunction
          CFI CFA SP+16
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
//  948 ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
//  949                         uint16 clusterID, zclReadCmd_t *readCmd,
//  950                         uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
//  951 {
//  952   uint16 dataLen;
//  953   uint8 *buf;
//  954   uint8 *pBuf;
//  955   ZStatus_t status;
//  956 
//  957   dataLen = readCmd->numAttr * 2; // Attribute ID
//  958 
//  959   buf = zcl_mem_alloc( dataLen );
//  960   if ( buf != NULL )
//  961   {
//  962     uint8 i;
//  963 
//  964     // Load the buffer - serially
//  965     pBuf = buf;
//  966     for (i = 0; i < readCmd->numAttr; i++)
//  967     {
//  968       *pBuf++ = LO_UINT16( readCmd->attrID[i] );
//  969       *pBuf++ = HI_UINT16( readCmd->attrID[i] );
//  970     }
//  971 
//  972     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
//  973                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
//  974     zcl_mem_free( buf );
//  975   }
//  976   else
//  977   {
//  978     status = ZMemError;
//  979   }
//  980 
//  981   return ( status );
        MOV.B   R10, R12
        POPM.W  #0x6, R11
          CFI CFA SP+4
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI R10L SameValue
          CFI R11L SameValue
        RETA
          CFI EndBlock cfiBlock45

        RSEG CODE:CODE:NOROOT(1)
zcl_SendWriteRequest:
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function zcl_SendWriteRequest
        FUNCALL zcl_SendWriteRequest, zclGetAttrDataLength
        LOCFRAME CSTACK, 20, STACK
        FUNCALL zcl_SendWriteRequest, osal_mem_alloc
        LOCFRAME CSTACK, 20, STACK
        FUNCALL zcl_SendWriteRequest, zclSerializeData
        LOCFRAME CSTACK, 20, STACK
        FUNCALL zcl_SendWriteRequest, zcl_SendCommand
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zcl_SendWriteRequest, osal_mem_free
        LOCFRAME CSTACK, 34, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        MOV.B   R12, R10
        MOV.W   R13, R8
        MOV.W   R14, R9
        MOV.W   R15, R6
        MOV.W   #0x0, R7
        MOV.B   #0x0, R4
        JMP     ??zcl_SendWriteRequest_2
??zcl_SendWriteRequest_0:
        MOV.W   R4, R11
        RPT     #0x5
        ADDX.W  R4, R11
        MOV.W   R6, R15
        ADD.W   R11, R15
        ADD.W   #0x2, R15
        MOV.W   0x4(R15), R13
        MOV.B   0x2(R15), R12
        CALLA   #zclGetAttrDataLength
        ADD.W   #0x3, R12
        ADD.W   R12, R7
        ADD.B   #0x1, R4
??zcl_SendWriteRequest_2:
        CMP.B   @R6, R4
        JNC     ??zcl_SendWriteRequest_0
        MOV.W   R7, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, R11
        CMP.W   #0x0, R12
        JEQ     ??zcl_SendWriteRequest_3
        MOV.W   R12, R14
        MOV.B   #0x0, R4
        JMP     ??zcl_SendWriteRequest_4
??zcl_SendWriteRequest_1:
        MOV.W   R4, R13
        RPT     #0x5
        ADDX.W  R4, R13
        MOV.W   R6, R15
        ADD.W   R13, R15
        ADD.W   #0x2, R15
        MOV.B   @R15, 0(R14)
        ADD.W   #0x1, R14
        MOV.B   0x1(R15), 0(R14)
        ADD.W   #0x1, R14
        MOV.B   0x2(R15), 0(R14)
        ADD.W   #0x1, R14
        MOV.W   0x4(R15), R13
        MOV.B   0x2(R15), R12
        CALLA   #zclSerializeData
        MOV.W   R12, R14
        ADD.B   #0x1, R4
??zcl_SendWriteRequest_4:
        CMP.B   @R6, R4
        JNC     ??zcl_SendWriteRequest_1
        PUSH.W  R11
          CFI CFA SP+22
        PUSH.W  R7
          CFI CFA SP+24
        PUSH.B  0x20(SP)
          CFI CFA SP+26
        PUSH.W  #0x0
          CFI CFA SP+28
        PUSH.B  0x22(SP)
          CFI CFA SP+30
        PUSH.B  0x22(SP)
          CFI CFA SP+32
        PUSH.B  #0x0
          CFI CFA SP+34
        MOV.B   0x22(SP), R15
        MOV.W   R9, R14
        MOV.W   R8, R13
        CALLA   #?Subroutine20
??CrossCallReturnLabel_15:
        MOV.B   R12, R10
        MOV.W   R11, R12
        CALLA   #osal_mem_free
        ADD.W   #0xe, SP
          CFI CFA SP+20
        JMP     ??zcl_SendWriteRequest_5
??zcl_SendWriteRequest_3:
        MOV.B   #0x10, R10
??zcl_SendWriteRequest_5:
        MOV.B   R10, R12
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock46

        RSEG CODE:CODE:NOROOT(1)
zcl_SendReadRsp:
          CFI Block cfiBlock47 Using cfiCommon0
          CFI Function zcl_SendReadRsp
        FUNCALL zcl_SendReadRsp, zclGetAttrDataLengthUsingCB
        LOCFRAME CSTACK, 22, STACK
        FUNCALL zcl_SendReadRsp, zclGetAttrDataLength
        LOCFRAME CSTACK, 22, STACK
        FUNCALL zcl_SendReadRsp, osal_mem_alloc
        LOCFRAME CSTACK, 22, STACK
        FUNCALL zcl_SendReadRsp, zclReadAttrDataUsingCB
        LOCFRAME CSTACK, 24, STACK
        FUNCALL zcl_SendReadRsp, zclSerializeData
        LOCFRAME CSTACK, 22, STACK
        FUNCALL zcl_SendReadRsp, zcl_SendCommand
        LOCFRAME CSTACK, 36, STACK
        FUNCALL zcl_SendReadRsp, osal_mem_free
        LOCFRAME CSTACK, 36, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        SUB.W   #0x2, SP
          CFI CFA SP+22
        MOV.B   R12, R10
        MOV.W   R13, R5
        MOV.W   R14, R11
        MOV.W   R15, R9
        MOV.W   #0x0, R6
        MOV.B   #0x0, R7
        JMP     ??zcl_SendReadRsp_4
??zcl_SendReadRsp_1:
        MOV.W   @R15, R14
        MOV.W   R11, R13
        MOV.B   R10, R12
        CALLA   #zclGetAttrDataLengthUsingCB
??zcl_SendReadRsp_6:
        ADD.W   R12, R6
??zcl_SendReadRsp_0:
        ADD.B   #0x1, R7
??zcl_SendReadRsp_4:
        CMP.B   @R9, R7
        JC      ??zcl_SendReadRsp_5
        MOV.W   R7, R14
        RPT     #0x5
        ADDX.W  R7, R14
        MOV.W   R9, R15
        ADD.W   R14, R15
        ADD.W   #0x2, R15
        ADD.W   #0x3, R6
        CMP.B   #0x0, 0x2(R15)
        JNE     ??zcl_SendReadRsp_0
        ADD.W   #0x1, R6
        MOV.W   0x4(R15), R13
        CMP.W   #0x0, R13
        JEQ     ??zcl_SendReadRsp_1
        MOV.B   0x3(R15), R12
        CALLA   #zclGetAttrDataLength
        JMP     ??zcl_SendReadRsp_6
??zcl_SendReadRsp_5:
        MOV.W   R6, R12
        CALLA   #??Subroutine4_0
??CrossCallReturnLabel_36:
        JEQ     ??zcl_SendReadRsp_7
        MOV.W   R12, R4
        MOV.B   #0x0, R7
        JMP     ??zcl_SendReadRsp_8
??zcl_SendReadRsp_3:
        MOV.W   SP, R15
        ADD.W   #0x0, R15
        PUSH.W  R15
          CFI CFA SP+24
        MOV.W   R4, R15
        MOV.W   @R12, R14
        MOV.W   R11, R13
        MOV.B   R10, R12
        CALLA   #zclReadAttrDataUsingCB
        ADD.W   0x2(SP), R4
        ADD.W   #0x2, SP
          CFI CFA SP+22
??zcl_SendReadRsp_2:
        ADD.B   #0x1, R7
??zcl_SendReadRsp_8:
        CMP.B   @R9, R7
        JC      ??zcl_SendReadRsp_9
        MOV.W   R7, R15
        RPT     #0x5
        ADDX.W  R7, R15
        MOV.W   R9, R12
        ADD.W   R15, R12
        ADD.W   #0x2, R12
        MOV.B   @R12, 0(R4)
        ADD.W   #0x1, R4
        MOV.B   0x1(R12), 0(R4)
        ADD.W   #0x1, R4
        MOV.B   0x2(R12), 0(R4)
        ADD.W   #0x1, R4
        CMP.B   #0x0, 0x2(R12)
        JNE     ??zcl_SendReadRsp_2
        MOV.B   0x3(R12), 0(R4)
        ADD.W   #0x1, R4
        MOV.W   0x4(R12), R13
        CMP.W   #0x0, R13
        JEQ     ??zcl_SendReadRsp_3
        MOV.W   R4, R14
        MOV.B   0x3(R12), R12
        CALLA   #zclSerializeData
        MOV.W   R12, R4
        JMP     ??zcl_SendReadRsp_2
??zcl_SendReadRsp_9:
        PUSH.W  R8
          CFI CFA SP+24
        PUSH.W  R6
          CFI CFA SP+26
        PUSH.B  0x20(SP)
          CFI CFA SP+28
        PUSH.W  #0x0
          CFI CFA SP+30
        PUSH.B  0x22(SP)
          CFI CFA SP+32
        PUSH.B  0x22(SP)
          CFI CFA SP+34
        PUSH.B  #0x0
          CFI CFA SP+36
        MOV.B   #0x1, R15
        MOV.W   R11, R14
        MOV.W   R5, R13
        CALLA   #?Subroutine20
??CrossCallReturnLabel_14:
        CALLA   #?Subroutine14
??CrossCallReturnLabel_32:
        ADD.W   #0xe, SP
          CFI CFA SP+22
        JMP     ??zcl_SendReadRsp_10
??zcl_SendReadRsp_7:
        MOV.B   #0x10, R10
??zcl_SendReadRsp_10:
        MOV.B   R10, R12
        ADD.W   #0x2, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock47

        RSEG CODE:CODE:NOROOT(1)
?Subroutine20:
          CFI Block cfiCond48 Using cfiCommon0
          CFI Function zcl_SendWriteRsp
          CFI Conditional ??CrossCallReturnLabel_16
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+34
          CFI Block cfiCond49 Using cfiCommon0
          CFI (cfiCond49) Function zcl_SendWriteRequest
          CFI (cfiCond49) Conditional ??CrossCallReturnLabel_15
          CFI (cfiCond49) R4L Frame(CFA, -20)
          CFI (cfiCond49) R5L Frame(CFA, -18)
          CFI (cfiCond49) R6L Frame(CFA, -16)
          CFI (cfiCond49) R7L Frame(CFA, -14)
          CFI (cfiCond49) R8L Frame(CFA, -12)
          CFI (cfiCond49) R9L Frame(CFA, -10)
          CFI (cfiCond49) R10L Frame(CFA, -8)
          CFI (cfiCond49) R11L Frame(CFA, -6)
          CFI (cfiCond49) CFA SP+38
          CFI Block cfiCond50 Using cfiCommon0
          CFI (cfiCond50) Function zcl_SendReadRsp
          CFI (cfiCond50) Conditional ??CrossCallReturnLabel_14
          CFI (cfiCond50) R4L Frame(CFA, -20)
          CFI (cfiCond50) R5L Frame(CFA, -18)
          CFI (cfiCond50) R6L Frame(CFA, -16)
          CFI (cfiCond50) R7L Frame(CFA, -14)
          CFI (cfiCond50) R8L Frame(CFA, -12)
          CFI (cfiCond50) R9L Frame(CFA, -10)
          CFI (cfiCond50) R10L Frame(CFA, -8)
          CFI (cfiCond50) R11L Frame(CFA, -6)
          CFI (cfiCond50) CFA SP+40
          CFI Block cfiCond51 Using cfiCommon0
          CFI (cfiCond51) Function zcl_SendRead
          CFI (cfiCond51) Conditional ??CrossCallReturnLabel_13
          CFI (cfiCond51) R6L Frame(CFA, -16)
          CFI (cfiCond51) R7L Frame(CFA, -14)
          CFI (cfiCond51) R8L Frame(CFA, -12)
          CFI (cfiCond51) R9L Frame(CFA, -10)
          CFI (cfiCond51) R10L Frame(CFA, -8)
          CFI (cfiCond51) R11L Frame(CFA, -6)
          CFI (cfiCond51) CFA SP+34
          CFI Block cfiPicker52 Using cfiCommon1
          CFI (cfiPicker52) NoFunction
          CFI (cfiPicker52) Picker
        MOV.B   R10, R12
        BRA     #zcl_SendCommand
          CFI EndBlock cfiCond48
          CFI EndBlock cfiCond49
          CFI EndBlock cfiCond50
          CFI EndBlock cfiCond51
          CFI EndBlock cfiPicker52

        RSEG CODE:CODE:NOROOT(1)
?Subroutine14:
          CFI Block cfiCond53 Using cfiCommon0
          CFI Function zcl_SendReadRsp
          CFI Conditional ??CrossCallReturnLabel_32
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+40
          CFI Block cfiCond54 Using cfiCommon0
          CFI (cfiCond54) Function zcl_SendRead
          CFI (cfiCond54) Conditional ??CrossCallReturnLabel_31
          CFI (cfiCond54) R6L Frame(CFA, -16)
          CFI (cfiCond54) R7L Frame(CFA, -14)
          CFI (cfiCond54) R8L Frame(CFA, -12)
          CFI (cfiCond54) R9L Frame(CFA, -10)
          CFI (cfiCond54) R10L Frame(CFA, -8)
          CFI (cfiCond54) R11L Frame(CFA, -6)
          CFI (cfiCond54) CFA SP+34
          CFI Block cfiPicker55 Using cfiCommon1
          CFI (cfiPicker55) NoFunction
          CFI (cfiPicker55) Picker
        MOV.B   R12, R10
          CFI EndBlock cfiCond53
          CFI EndBlock cfiCond54
          CFI EndBlock cfiPicker55
        REQUIRE ??Subroutine26_0
        // Fall through to label ??Subroutine26_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine26_0:
          CFI Block cfiCond56 Using cfiCommon0
          CFI Function zclProcessInWriteCmd
          CFI Conditional ??CrossCallReturnLabel_30
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+38
          CFI Block cfiCond57 Using cfiCommon0
          CFI (cfiCond57) Function zcl_SendReadRsp
          CFI (cfiCond57) Conditional ??CrossCallReturnLabel_32
          CFI (cfiCond57) R4L Frame(CFA, -20)
          CFI (cfiCond57) R5L Frame(CFA, -18)
          CFI (cfiCond57) R6L Frame(CFA, -16)
          CFI (cfiCond57) R7L Frame(CFA, -14)
          CFI (cfiCond57) R8L Frame(CFA, -12)
          CFI (cfiCond57) R9L Frame(CFA, -10)
          CFI (cfiCond57) R10L Frame(CFA, -8)
          CFI (cfiCond57) R11L Frame(CFA, -6)
          CFI (cfiCond57) CFA SP+40
          CFI Block cfiCond58 Using cfiCommon0
          CFI (cfiCond58) Function zcl_SendRead
          CFI (cfiCond58) Conditional ??CrossCallReturnLabel_31
          CFI (cfiCond58) R6L Frame(CFA, -16)
          CFI (cfiCond58) R7L Frame(CFA, -14)
          CFI (cfiCond58) R8L Frame(CFA, -12)
          CFI (cfiCond58) R9L Frame(CFA, -10)
          CFI (cfiCond58) R10L Frame(CFA, -8)
          CFI (cfiCond58) R11L Frame(CFA, -6)
          CFI (cfiCond58) CFA SP+34
          CFI Block cfiPicker59 Using cfiCommon1
          CFI (cfiPicker59) NoFunction
          CFI (cfiPicker59) Picker
        MOV.W   R8, R12
        BRA     #osal_mem_free
          CFI EndBlock cfiCond56
          CFI EndBlock cfiCond57
          CFI EndBlock cfiCond58
          CFI EndBlock cfiPicker59

        RSEG CODE:CODE:REORDER:NOROOT(1)
zcl_SendRead:
          CFI Block cfiBlock60 Using cfiCommon0
          CFI Function zcl_SendRead
        FUNCALL zcl_SendRead, osal_mem_alloc
        LOCFRAME CSTACK, 16, STACK
        FUNCALL zcl_SendRead, zcl_SendCommand
        LOCFRAME CSTACK, 30, STACK
        FUNCALL zcl_SendRead, osal_mem_free
        LOCFRAME CSTACK, 30, STACK
        PUSHM.W #0x6, R11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
        MOV.B   R12, R10
        MOV.W   R13, R9
        MOV.W   R14, R6
        MOV.W   R15, R7
        MOV.B   @R15, R11
        RLA.W   R11
        MOV.W   R11, R12
        CALLA   #??Subroutine4_0
??CrossCallReturnLabel_37:
        JEQ     ??zcl_SendRead_1
        MOV.W   R12, R15
        MOV.B   #0x0, R14
        JMP     ??zcl_SendRead_2
??zcl_SendRead_0:
        MOV.B   R14, R12
        RLA.W   R12
        MOV.W   R7, R13
        ADD.W   R12, R13
        ADD.W   #0x2, R13
        CALLA   #?Subroutine8
??zcl_SendRead_2:
        CMP.B   @R7, R14
        JNC     ??zcl_SendRead_0
        PUSH.W  R8
          CFI CFA SP+18
        PUSH.W  R11
          CFI CFA SP+20
        PUSH.B  0x1a(SP)
          CFI CFA SP+22
        PUSH.W  #0x0
          CFI CFA SP+24
        PUSH.B  0x1c(SP)
          CFI CFA SP+26
        PUSH.B  0x1c(SP)
          CFI CFA SP+28
        PUSH.B  #0x0
          CFI CFA SP+30
        MOV.B   #0x0, R15
        MOV.W   R6, R14
        MOV.W   R9, R13
        CALLA   #?Subroutine20
??CrossCallReturnLabel_13:
        CALLA   #?Subroutine14
??CrossCallReturnLabel_31:
        ADD.W   #0xe, SP
          CFI CFA SP+16
        JMP     ??zcl_SendRead_3
??zcl_SendRead_1:
        MOV.B   #0x10, R10
??zcl_SendRead_3:
        JMP     ?Subroutine3
        NOP
          CFI EndBlock cfiBlock60
//  982 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine8:
          CFI Block cfiCond61 Using cfiCommon0
          CFI Function zcl_SendWriteRsp
          CFI Conditional ??zcl_SendWriteRsp_2
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
          CFI Block cfiCond62 Using cfiCommon0
          CFI (cfiCond62) Function zcl_SendRead
          CFI (cfiCond62) Conditional ??zcl_SendRead_2
          CFI (cfiCond62) R6L Frame(CFA, -16)
          CFI (cfiCond62) R7L Frame(CFA, -14)
          CFI (cfiCond62) R8L Frame(CFA, -12)
          CFI (cfiCond62) R9L Frame(CFA, -10)
          CFI (cfiCond62) R10L Frame(CFA, -8)
          CFI (cfiCond62) R11L Frame(CFA, -6)
          CFI (cfiCond62) CFA SP+20
          CFI Block cfiPicker63 Using cfiCommon1
          CFI (cfiPicker63) NoFunction
          CFI (cfiPicker63) Picker
//  983 
//  984 /*********************************************************************
//  985  * @fn      zcl_SendReadRsp
//  986  *
//  987  * @brief   Send a Read Response command.
//  988  *
//  989  * @param   srcEP - Application's endpoint
//  990  * @param   dstAddr - destination address
//  991  * @param   clusterID - cluster ID
//  992  * @param   readRspCmd - read response command to be sent
//  993  * @param   direction - direction of the command
//  994  * @param   seqNum - transaction sequence number
//  995  *
//  996  * @return  ZSuccess if OK
//  997  */
//  998 ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
//  999                            uint16 clusterID, zclReadRspCmd_t *readRspCmd,
// 1000                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1001 {
// 1002   uint8 *buf;
// 1003   uint16 len = 0;
// 1004   ZStatus_t status;
// 1005   uint8 i;
// 1006 
// 1007   // calculate the size of the command
// 1008   for ( i = 0; i < readRspCmd->numAttr; i++ )
// 1009   {
// 1010     zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
// 1011 
// 1012     len += 2 + 1; // Attribute ID + Status
// 1013 
// 1014     if ( statusRec->status == ZCL_STATUS_SUCCESS )
// 1015     {
// 1016       len++; // Attribute Data Type length
// 1017 
// 1018       // Attribute Data length
// 1019       if ( statusRec->data != NULL )
// 1020       {
// 1021         len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
// 1022       }
// 1023       else
// 1024       {
// 1025         len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
// 1026       }
// 1027     }
// 1028   }
// 1029 
// 1030   buf = zcl_mem_alloc( len );
// 1031   if ( buf != NULL )
// 1032   {
// 1033     // Load the buffer - serially
// 1034     uint8 *pBuf = buf;
// 1035 
// 1036     for ( i = 0; i < readRspCmd->numAttr; i++ )
// 1037     {
// 1038       zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
// 1039 
// 1040       *pBuf++ = LO_UINT16( statusRec->attrID );
// 1041       *pBuf++ = HI_UINT16( statusRec->attrID );
// 1042       *pBuf++ = statusRec->status;
// 1043 
// 1044       if ( statusRec->status == ZCL_STATUS_SUCCESS )
// 1045       {
// 1046         *pBuf++ = statusRec->dataType;
// 1047 
// 1048         if ( statusRec->data != NULL )
// 1049         {
// 1050           // Copy attribute data to the buffer to be sent out
// 1051           pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
// 1052         }
// 1053         else
// 1054         {
// 1055           uint16 dataLen;
// 1056 
// 1057           // Read attribute data directly into the buffer to be sent out
// 1058           zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
// 1059           pBuf += dataLen;
// 1060         }
// 1061       }
// 1062     } // for loop
// 1063 
// 1064     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
// 1065                               direction, disableDefaultRsp, 0, seqNum, len, buf );
// 1066     zcl_mem_free( buf );
// 1067   }
// 1068   else
// 1069   {
// 1070     status = ZMemError;
// 1071   }
// 1072 
// 1073   return ( status );
// 1074 }
// 1075 #endif // ZCL_READ
// 1076 
// 1077 #ifdef ZCL_WRITE
// 1078 /*********************************************************************
// 1079  * @fn      sendWriteRequest
// 1080  *
// 1081  * @brief   Send a Write command
// 1082  *
// 1083  * @param   dstAddr - destination address
// 1084  * @param   clusterID - cluster ID
// 1085  * @param   writeCmd - write command to be sent
// 1086  * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
// 1087  * @param   direction - direction of the command
// 1088  * @param   seqNum - transaction sequence number
// 1089  *
// 1090  * @return  ZSuccess if OK
// 1091  */
// 1092 ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
// 1093                                 zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
// 1094                                 uint8 disableDefaultRsp, uint8 seqNum )
// 1095 {
// 1096   uint8 *buf;
// 1097   uint16 dataLen = 0;
// 1098   ZStatus_t status;
// 1099   uint8 i;
// 1100 
// 1101   for ( i = 0; i < writeCmd->numAttr; i++ )
// 1102   {
// 1103     zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
// 1104 
// 1105     dataLen += 2 + 1; // Attribute ID + Attribute Type
// 1106 
// 1107     // Attribute Data
// 1108     dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
// 1109   }
// 1110 
// 1111   buf = zcl_mem_alloc( dataLen );
// 1112   if ( buf != NULL )
// 1113   {
// 1114     // Load the buffer - serially
// 1115     uint8 *pBuf = buf;
// 1116     for ( i = 0; i < writeCmd->numAttr; i++ )
// 1117     {
// 1118       zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
// 1119 
// 1120       *pBuf++ = LO_UINT16( statusRec->attrID );
// 1121       *pBuf++ = HI_UINT16( statusRec->attrID );
// 1122       *pBuf++ = statusRec->dataType;
// 1123 
// 1124       pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
// 1125     }
// 1126 
// 1127     status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
// 1128                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
// 1129     zcl_mem_free( buf );
// 1130   }
// 1131   else
// 1132   {
// 1133     status = ZMemError;
// 1134   }
// 1135 
// 1136   return ( status);
// 1137 }
// 1138 
// 1139 /*********************************************************************
// 1140  * @fn      zcl_SendWriteRsp
// 1141  *
// 1142  * @brief   Send a Write Response command
// 1143  *
// 1144  * @param   dstAddr - destination address
// 1145  * @param   clusterID - cluster ID
// 1146  * @param   wrtieRspCmd - write response command to be sent
// 1147  * @param   direction - direction of the command
// 1148  * @param   seqNum - transaction sequence number
// 1149  *
// 1150  * @return  ZSuccess if OK
// 1151  */
// 1152 ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
// 1153                             uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
// 1154                             uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1155 {
// 1156   uint16 dataLen;
// 1157   uint8 *buf;
// 1158   ZStatus_t status;
// 1159 
// 1160   dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
// 1161 
// 1162   buf = zcl_mem_alloc( dataLen );
// 1163   if ( buf != NULL )
// 1164   {
// 1165     // Load the buffer - serially
// 1166     uint8 i;
// 1167     uint8 *pBuf = buf;
// 1168     for ( i = 0; i < writeRspCmd->numAttr; i++ )
// 1169     {
// 1170       *pBuf++ = writeRspCmd->attrList[i].status;
// 1171       *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
        MOV.B   @R13, 0(R15)
        ADD.W   #0x1, R15
// 1172       *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
        MOV.B   0x1(R13), 0(R15)
        ADD.W   #0x1, R15
        ADD.B   #0x1, R14
        RETA
          CFI EndBlock cfiCond61
          CFI EndBlock cfiCond62
          CFI EndBlock cfiPicker63

        RSEG CODE:CODE:NOROOT(1)
?Subroutine4:
          CFI Block cfiCond64 Using cfiCommon0
          CFI Function zclParseInWriteCmd
          CFI Conditional ??CrossCallReturnLabel_33
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+24
          CFI Block cfiCond65 Using cfiCommon0
          CFI (cfiCond65) Function zclParseInReadRspCmd
          CFI (cfiCond65) Conditional ??CrossCallReturnLabel_34
          CFI (cfiCond65) R4L Frame(CFA, -20)
          CFI (cfiCond65) R5L Frame(CFA, -18)
          CFI (cfiCond65) R6L Frame(CFA, -16)
          CFI (cfiCond65) R7L Frame(CFA, -14)
          CFI (cfiCond65) R8L Frame(CFA, -12)
          CFI (cfiCond65) R9L Frame(CFA, -10)
          CFI (cfiCond65) R10L Frame(CFA, -8)
          CFI (cfiCond65) R11L Frame(CFA, -6)
          CFI (cfiCond65) CFA SP+24
          CFI Block cfiPicker66 Using cfiCommon1
          CFI (cfiPicker66) NoFunction
          CFI (cfiPicker66) Picker
        MOV.B   #0x2, R10
        RPT     #0x6
        ADDX.B  R11, R10
        MOV.B   R10, R12
        ADD.W   R8, R12
          CFI EndBlock cfiCond64
          CFI EndBlock cfiCond65
          CFI EndBlock cfiPicker66
        REQUIRE ??Subroutine4_0
        // Fall through to label ??Subroutine4_0

        RSEG CODE:CODE:REORDER:NOROOT(1)
??Subroutine4_0:
          CFI Block cfiCond67 Using cfiCommon0
          CFI Function zclProcessInWriteCmd
          CFI Conditional ??CrossCallReturnLabel_35
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+32
          CFI Block cfiCond68 Using cfiCommon0
          CFI (cfiCond68) Function zcl_SendReadRsp
          CFI (cfiCond68) Conditional ??CrossCallReturnLabel_36
          CFI (cfiCond68) R4L Frame(CFA, -20)
          CFI (cfiCond68) R5L Frame(CFA, -18)
          CFI (cfiCond68) R6L Frame(CFA, -16)
          CFI (cfiCond68) R7L Frame(CFA, -14)
          CFI (cfiCond68) R8L Frame(CFA, -12)
          CFI (cfiCond68) R9L Frame(CFA, -10)
          CFI (cfiCond68) R10L Frame(CFA, -8)
          CFI (cfiCond68) R11L Frame(CFA, -6)
          CFI (cfiCond68) CFA SP+26
          CFI Block cfiCond69 Using cfiCommon0
          CFI (cfiCond69) Function zcl_SendRead
          CFI (cfiCond69) Conditional ??CrossCallReturnLabel_37
          CFI (cfiCond69) R6L Frame(CFA, -16)
          CFI (cfiCond69) R7L Frame(CFA, -14)
          CFI (cfiCond69) R8L Frame(CFA, -12)
          CFI (cfiCond69) R9L Frame(CFA, -10)
          CFI (cfiCond69) R10L Frame(CFA, -8)
          CFI (cfiCond69) R11L Frame(CFA, -6)
          CFI (cfiCond69) CFA SP+20
          CFI Block cfiCond70 Using cfiCommon0
          CFI (cfiCond70) Function zclParseInWriteCmd
          CFI (cfiCond70) Conditional ??CrossCallReturnLabel_33
          CFI (cfiCond70) R4L Frame(CFA, -20)
          CFI (cfiCond70) R5L Frame(CFA, -18)
          CFI (cfiCond70) R6L Frame(CFA, -16)
          CFI (cfiCond70) R7L Frame(CFA, -14)
          CFI (cfiCond70) R8L Frame(CFA, -12)
          CFI (cfiCond70) R9L Frame(CFA, -10)
          CFI (cfiCond70) R10L Frame(CFA, -8)
          CFI (cfiCond70) R11L Frame(CFA, -6)
          CFI (cfiCond70) CFA SP+24
          CFI Block cfiCond71 Using cfiCommon0
          CFI (cfiCond71) Function zclParseInReadRspCmd
          CFI (cfiCond71) Conditional ??CrossCallReturnLabel_34
          CFI (cfiCond71) R4L Frame(CFA, -20)
          CFI (cfiCond71) R5L Frame(CFA, -18)
          CFI (cfiCond71) R6L Frame(CFA, -16)
          CFI (cfiCond71) R7L Frame(CFA, -14)
          CFI (cfiCond71) R8L Frame(CFA, -12)
          CFI (cfiCond71) R9L Frame(CFA, -10)
          CFI (cfiCond71) R10L Frame(CFA, -8)
          CFI (cfiCond71) R11L Frame(CFA, -6)
          CFI (cfiCond71) CFA SP+24
          CFI Block cfiPicker72 Using cfiCommon1
          CFI (cfiPicker72) NoFunction
          CFI (cfiPicker72) Picker
        CALLA   #osal_mem_alloc
        MOV.W   R12, R8
        CMP.W   #0x0, R12
        RETA
          CFI EndBlock cfiCond67
          CFI EndBlock cfiCond68
          CFI EndBlock cfiCond69
          CFI EndBlock cfiCond70
          CFI EndBlock cfiCond71
          CFI EndBlock cfiPicker72
// 1173     }
// 1174 
// 1175     // If there's only a single status record and its status field is set to
// 1176     // SUCCESS then omit the attribute ID field.
// 1177     if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
// 1178     {
// 1179       dataLen = 1;
// 1180     }
// 1181 
// 1182     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
// 1183                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
// 1184     zcl_mem_free( buf );
// 1185   }
// 1186   else
// 1187   {
// 1188     status = ZMemError;
// 1189   }
// 1190 
// 1191   return ( status );
// 1192 }
// 1193 #endif // ZCL_WRITE
// 1194 
// 1195 #ifdef ZCL_REPORT
// 1196 /*********************************************************************
// 1197  * @fn      zcl_SendConfigReportCmd
// 1198  *
// 1199  * @brief   Send a Configure Reporting command
// 1200  *
// 1201  * @param   dstAddr - destination address
// 1202  * @param   clusterID - cluster ID
// 1203  * @param   cfgReportCmd - configure reporting command to be sent
// 1204  * @param   direction - direction of the command
// 1205  * @param   seqNum - transaction sequence number
// 1206  *
// 1207  * @return  ZSuccess if OK
// 1208  */
// 1209 ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
// 1210                           uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
// 1211                           uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1212 {
// 1213   uint8 *buf;
// 1214   uint16 dataLen = 0;
// 1215   ZStatus_t status;
// 1216   uint8 i;
// 1217 
// 1218   // Find out the data length
// 1219   for ( i = 0; i < cfgReportCmd->numAttr; i++ )
// 1220   {
// 1221     zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
// 1222 
// 1223     dataLen += 1 + 2; // Direction + Attribute ID
// 1224 
// 1225     if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
// 1226     {
// 1227       dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
// 1228 
// 1229       // Find out the size of the Reportable Change field (for Analog data types)
// 1230       if ( zclAnalogDataType( reportRec->dataType ) )
// 1231       {
// 1232         dataLen += zclGetDataTypeLength( reportRec->dataType );
// 1233       }
// 1234     }
// 1235     else
// 1236     {
// 1237       dataLen += 2; // Timeout Period
// 1238     }
// 1239   }
// 1240 
// 1241   buf = zcl_mem_alloc( dataLen );
// 1242   if ( buf != NULL )
// 1243   {
// 1244     // Load the buffer - serially
// 1245     uint8 *pBuf = buf;
// 1246 
// 1247     for ( i = 0; i < cfgReportCmd->numAttr; i++ )
// 1248     {
// 1249       zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
// 1250 
// 1251       *pBuf++ = reportRec->direction;
// 1252       *pBuf++ = LO_UINT16( reportRec->attrID );
// 1253       *pBuf++ = HI_UINT16( reportRec->attrID );
// 1254 
// 1255       if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
// 1256       {
// 1257         *pBuf++ = reportRec->dataType;
// 1258         *pBuf++ = LO_UINT16( reportRec->minReportInt );
// 1259         *pBuf++ = HI_UINT16( reportRec->minReportInt );
// 1260         *pBuf++ = LO_UINT16( reportRec->maxReportInt );
// 1261         *pBuf++ = HI_UINT16( reportRec->maxReportInt );
// 1262 
// 1263         if ( zclAnalogDataType( reportRec->dataType ) )
// 1264         {
// 1265           pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
// 1266         }
// 1267       }
// 1268       else
// 1269       {
// 1270         *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
// 1271         *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
// 1272       }
// 1273     } // for loop
// 1274 
// 1275     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
// 1276                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
// 1277     zcl_mem_free( buf );
// 1278   }
// 1279   else
// 1280   {
// 1281     status = ZMemError;
// 1282   }
// 1283 
// 1284   return ( status );
// 1285 }
// 1286 
// 1287 /*********************************************************************
// 1288  * @fn      zcl_SendConfigReportRspCmd
// 1289  *
// 1290  * @brief   Send a Configure Reporting Response command
// 1291  *
// 1292  * @param   dstAddr - destination address
// 1293  * @param   clusterID - cluster ID
// 1294  * @param   cfgReportRspCmd - configure reporting response command to be sent
// 1295  * @param   direction - direction of the command
// 1296  * @param   seqNum - transaction sequence number
// 1297  *
// 1298  * @return  ZSuccess if OK
// 1299  */
// 1300 ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
// 1301                     uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
// 1302                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1303 {
// 1304   uint16 dataLen;
// 1305   uint8 *buf;
// 1306   ZStatus_t status;
// 1307 
// 1308   // Atrribute list (Status, Direction and Attribute ID)
// 1309   dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
// 1310 
// 1311   buf = zcl_mem_alloc( dataLen );
// 1312   if ( buf != NULL )
// 1313   {
// 1314     // Load the buffer - serially
// 1315     uint8 *pBuf = buf;
// 1316     uint8 i;
// 1317 
// 1318     for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
// 1319     {
// 1320       *pBuf++ = cfgReportRspCmd->attrList[i].status;
// 1321       *pBuf++ = cfgReportRspCmd->attrList[i].direction;
// 1322       *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
// 1323       *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
// 1324     }
// 1325 
// 1326     // If there's only a single status record and its status field is set to
// 1327     // SUCCESS then omit the attribute ID field.
// 1328     if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
// 1329     {
// 1330       dataLen = 1;
// 1331     }
// 1332 
// 1333     status = zcl_SendCommand( srcEP, dstAddr, clusterID,
// 1334                               ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
// 1335                               disableDefaultRsp, 0, seqNum, dataLen, buf );
// 1336     zcl_mem_free( buf );
// 1337   }
// 1338   else
// 1339   {
// 1340     status = ZMemError;
// 1341   }
// 1342 
// 1343   return ( status );
// 1344 }
// 1345 
// 1346 /*********************************************************************
// 1347  * @fn      zcl_SendReadReportCfgCmd
// 1348  *
// 1349  * @brief   Send a Read Reporting Configuration command
// 1350  *
// 1351  * @param   dstAddr - destination address
// 1352  * @param   clusterID - cluster ID
// 1353  * @param   readReportCfgCmd - read reporting configuration command to be sent
// 1354  * @param   direction - direction of the command
// 1355  * @param   seqNum - transaction sequence number
// 1356  *
// 1357  * @return  ZSuccess if OK
// 1358  */
// 1359 ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
// 1360                   uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
// 1361                   uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1362 {
// 1363   uint16 dataLen;
// 1364   uint8 *buf;
// 1365   ZStatus_t status;
// 1366 
// 1367   dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
// 1368 
// 1369   buf = zcl_mem_alloc( dataLen );
// 1370   if ( buf != NULL )
// 1371   {
// 1372     // Load the buffer - serially
// 1373     uint8 *pBuf = buf;
// 1374     uint8 i;
// 1375 
// 1376     for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
// 1377     {
// 1378       *pBuf++ = readReportCfgCmd->attrList[i].direction;
// 1379       *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
// 1380       *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
// 1381     }
// 1382 
// 1383     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
// 1384                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
// 1385     zcl_mem_free( buf );
// 1386   }
// 1387   else
// 1388   {
// 1389     status = ZMemError;
// 1390   }
// 1391 
// 1392   return ( status );
// 1393 }
// 1394 
// 1395 /*********************************************************************
// 1396  * @fn      zcl_SendReadReportCfgRspCmd
// 1397  *
// 1398  * @brief   Send a Read Reporting Configuration Response command
// 1399  *
// 1400  * @param   dstAddr - destination address
// 1401  * @param   clusterID - cluster ID
// 1402  * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
// 1403  * @param   direction - direction of the command
// 1404  * @param   seqNum - transaction sequence number
// 1405  *
// 1406  * @return  ZSuccess if OK
// 1407  */
// 1408 ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
// 1409              uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
// 1410              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1411 {
// 1412   uint8 *buf;
// 1413   uint16 dataLen = 0;
// 1414   ZStatus_t status;
// 1415   uint8 i;
// 1416 
// 1417   // Find out the data length
// 1418   for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
// 1419   {
// 1420     zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
// 1421 
// 1422     dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
// 1423 
// 1424     if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
// 1425     {
// 1426       if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
// 1427       {
// 1428         dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
// 1429 
// 1430         // Find out the size of the Reportable Change field (for Analog data types)
// 1431         if ( zclAnalogDataType( reportRspRec->dataType ) )
// 1432         {
// 1433           dataLen += zclGetDataTypeLength( reportRspRec->dataType );
// 1434         }
// 1435       }
// 1436       else
// 1437       {
// 1438         dataLen += 2; // Timeout Period
// 1439       }
// 1440     }
// 1441   }
// 1442 
// 1443   buf = zcl_mem_alloc( dataLen );
// 1444   if ( buf != NULL )
// 1445   {
// 1446     // Load the buffer - serially
// 1447     uint8 *pBuf = buf;
// 1448 
// 1449     for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
// 1450     {
// 1451       zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
// 1452 
// 1453       *pBuf++ = reportRspRec->status;
// 1454       *pBuf++ = reportRspRec->direction;
// 1455       *pBuf++ = LO_UINT16( reportRspRec->attrID );
// 1456       *pBuf++ = HI_UINT16( reportRspRec->attrID );
// 1457 
// 1458       if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
// 1459       {
// 1460         if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
// 1461         {
// 1462           *pBuf++ = reportRspRec->dataType;
// 1463           *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
// 1464           *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
// 1465           *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
// 1466           *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
// 1467 
// 1468           if ( zclAnalogDataType( reportRspRec->dataType ) )
// 1469           {
// 1470             pBuf = zclSerializeData( reportRspRec->dataType,
// 1471                                      reportRspRec->reportableChange, pBuf );
// 1472           }
// 1473         }
// 1474         else
// 1475         {
// 1476           *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
// 1477           *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
// 1478         }
// 1479       }
// 1480     }
// 1481 
// 1482     status = zcl_SendCommand( srcEP, dstAddr, clusterID,
// 1483                               ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
// 1484                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
// 1485     zcl_mem_free( buf );
// 1486   }
// 1487   else
// 1488   {
// 1489     status = ZMemError;
// 1490   }
// 1491 
// 1492   return ( status );
// 1493 }
// 1494 
// 1495 /*********************************************************************
// 1496  * @fn      zcl_SendReportCmd
// 1497  *
// 1498  * @brief   Send a Report command
// 1499  *
// 1500  * @param   dstAddr - destination address
// 1501  * @param   clusterID - cluster ID
// 1502  * @param   reportCmd - report command to be sent
// 1503  * @param   direction - direction of the command
// 1504  * @param   seqNum - transaction sequence number
// 1505  *
// 1506  * @return  ZSuccess if OK
// 1507  */
// 1508 ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
// 1509                              uint16 clusterID, zclReportCmd_t *reportCmd,
// 1510                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1511 {
// 1512   uint16 dataLen = 0;
// 1513   uint8 *buf;
// 1514   ZStatus_t status;
// 1515   uint8 i;
// 1516 
// 1517   // calculate the size of the command
// 1518   for ( i = 0; i < reportCmd->numAttr; i++ )
// 1519   {
// 1520     zclReport_t *reportRec = &(reportCmd->attrList[i]);
// 1521 
// 1522     dataLen += 2 + 1; // Attribute ID + data type
// 1523 
// 1524     // Attribute Data
// 1525     dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
// 1526   }
// 1527 
// 1528   buf = zcl_mem_alloc( dataLen );
// 1529   if ( buf != NULL )
// 1530   {
// 1531     // Load the buffer - serially
// 1532     uint8 *pBuf = buf;
// 1533 
// 1534     for ( i = 0; i < reportCmd->numAttr; i++ )
// 1535     {
// 1536       zclReport_t *reportRec = &(reportCmd->attrList[i]);
// 1537 
// 1538       *pBuf++ = LO_UINT16( reportRec->attrID );
// 1539       *pBuf++ = HI_UINT16( reportRec->attrID );
// 1540       *pBuf++ = reportRec->dataType;
// 1541 
// 1542       pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
// 1543     }
// 1544 
// 1545     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
// 1546                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
// 1547     zcl_mem_free( buf );
// 1548   }
// 1549   else
// 1550   {
// 1551     status = ZMemError;
// 1552   }
// 1553 
// 1554   return ( status );
// 1555 }
// 1556 #endif // ZCL_REPORT
// 1557 
// 1558 /*********************************************************************
// 1559  * @fn      zcl_SendDefaultRspCmd
// 1560  *
// 1561  * @brief   Send a Default Response command
// 1562  *
// 1563  *          Note: The manufacturer code field should be set if this
// 1564  *          command is being sent in response to a manufacturer specific
// 1565  *          command.
// 1566  *
// 1567  * @param   dstAddr - destination address
// 1568  * @param   clusterID - cluster ID
// 1569  * @param   defaultRspCmd - default response command to be sent
// 1570  * @param   direction - direction of the command
// 1571  * @param   manuCode - manufacturer code for proprietary extensions to a profile
// 1572  * @param   seqNum - transaction sequence number
// 1573  *
// 1574  * @return  ZSuccess if OK
// 1575  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1576 ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
zcl_SendDefaultRspCmd:
          CFI Block cfiBlock73 Using cfiCommon0
          CFI Function zcl_SendDefaultRspCmd
// 1577                                  zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
// 1578                                  uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
// 1579 {
        FUNCALL zcl_SendDefaultRspCmd, zcl_SendCommand
        LOCFRAME CSTACK, 20, STACK
        SUB.W   #0x2, SP
          CFI CFA SP+6
// 1580   uint8 buf[2]; // Command ID and Status;
// 1581 
// 1582   // Load the buffer - serially
// 1583   buf[0] = defaultRspCmd->commandID;
        MOV.B   @R15, 0(SP)
// 1584   buf[1] = defaultRspCmd->statusCode;
        MOV.B   0x1(R15), 0x1(SP)
// 1585 
// 1586   return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
// 1587                             direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
        MOV.W   SP, R15
        ADD.W   #0x0, R15
        PUSH.W  R15
          CFI CFA SP+8
        PUSH.W  #0x2
          CFI CFA SP+10
        PUSH.B  0x12(SP)
          CFI CFA SP+12
        PUSH.W  0x12(SP)
          CFI CFA SP+14
        PUSH.B  0x12(SP)
          CFI CFA SP+16
        PUSH.B  0x12(SP)
          CFI CFA SP+18
        PUSH.B  #0x0
          CFI CFA SP+20
        MOV.B   #0xb, R15
        CALLA   #zcl_SendCommand
        ADD.W   #0x10, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock73
// 1588 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine15:
          CFI Block cfiCond74 Using cfiCommon0
          CFI Function zclProcessInWriteUndividedCmd
          CFI Conditional ??CrossCallReturnLabel_21
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+40
          CFI Block cfiCond75 Using cfiCommon0
          CFI (cfiCond75) Function zclProcessInReadCmd
          CFI (cfiCond75) Conditional ??CrossCallReturnLabel_22
          CFI (cfiCond75) R4L Frame(CFA, -20)
          CFI (cfiCond75) R5L Frame(CFA, -18)
          CFI (cfiCond75) R6L Frame(CFA, -16)
          CFI (cfiCond75) R7L Frame(CFA, -14)
          CFI (cfiCond75) R8L Frame(CFA, -12)
          CFI (cfiCond75) R9L Frame(CFA, -10)
          CFI (cfiCond75) R10L Frame(CFA, -8)
          CFI (cfiCond75) R11L Frame(CFA, -6)
          CFI (cfiCond75) CFA SP+36
          CFI Block cfiPicker76 Using cfiCommon1
          CFI (cfiPicker76) NoFunction
          CFI (cfiPicker76) Picker
        BIT.W   #0x8, 0x2(R8)
          CFI EndBlock cfiCond74
          CFI EndBlock cfiCond75
          CFI EndBlock cfiPicker76
        REQUIRE ??Subroutine15_0
        // Fall through to label ??Subroutine15_0
// 1589 
// 1590 #ifdef ZCL_DISCOVER
// 1591 /*********************************************************************
// 1592  * @fn      zcl_SendDiscoverCmdsCmd
// 1593  *
// 1594  * @brief   Send a Discover Commands command
// 1595  *
// 1596  * @param   dstAddr - destination address
// 1597  * @param   clusterID - cluster ID
// 1598  * @param   cmdType - requesting command ID
// 1599  * @param   pDiscoverCmd - discover command to be sent
// 1600  * @param   direction - direction of the command
// 1601  * @param   seqNum - transaction sequence number
// 1602  *
// 1603  * @return  ZSuccess if OK
// 1604  */
// 1605 ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
// 1606                                   uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
// 1607                                   uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1608 {
// 1609   uint8 payload[2]; // size of startCmdID and maxCmdID
// 1610   ZStatus_t status;
// 1611 
// 1612   payload[0] = pDiscoverCmd->startCmdID;
// 1613   payload[1] = pDiscoverCmd->maxCmdID;
// 1614 
// 1615   // Send message for either commands received or generated
// 1616   if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
// 1617   {
// 1618     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
// 1619                                 direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
// 1620   }
// 1621   else  // generated
// 1622   {
// 1623     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
// 1624                                 direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
// 1625   }
// 1626 
// 1627   return ( status );
// 1628 }
// 1629 
// 1630 /*********************************************************************
// 1631  * @fn      zcl_SendDiscoverCmdsRspCmd
// 1632  *
// 1633  * @brief   Send a Discover Commands Response command
// 1634  *
// 1635  * @param   dstAddr - destination address
// 1636  * @param   clusterID - cluster ID
// 1637  * @param   pDiscoverRspCmd - response command to be sent
// 1638  * @param   direction - direction of the command
// 1639  * @param   seqNum - transaction sequence number
// 1640  *
// 1641  * @return  ZSuccess if OK
// 1642  */
// 1643 ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
// 1644                                       uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
// 1645                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1646 {
// 1647   uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
// 1648   uint8 *pCmdBuf;
// 1649   uint8 i;
// 1650   ZStatus_t status = ZSuccess;
// 1651 
// 1652   // allocate memory
// 1653   pCmdBuf = zcl_mem_alloc( payloadSize );
// 1654   if ( pCmdBuf != NULL )
// 1655   {
// 1656     uint8 *pBuf = pCmdBuf;
// 1657 
// 1658     // Load the buffer - serially
// 1659     *pBuf++ = pDiscoverRspCmd->discComplete;
// 1660     for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
// 1661     {
// 1662       *pBuf++ = pDiscoverRspCmd->pCmdID[i];
// 1663     }
// 1664 
// 1665     // Send response message for either commands received or generated
// 1666     if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
// 1667     {
// 1668       status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
// 1669                                 direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
// 1670     }
// 1671     else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
// 1672     {
// 1673       status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
// 1674                                 direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
// 1675     }
// 1676 
// 1677     zcl_mem_free( pCmdBuf );
// 1678   }
// 1679   else
// 1680   {
// 1681     status = ZMemError;
// 1682   }
// 1683 
// 1684   return ( status );
// 1685 }
// 1686 
// 1687 /*********************************************************************
// 1688  * @fn      zcl_SendDiscoverAttrsCmd
// 1689  *
// 1690  * @brief   Send a Discover Attributes command
// 1691  *
// 1692  * @param   dstAddr - destination address
// 1693  * @param   clusterID - cluster ID
// 1694  * @param   pDiscoverCmd - discover command to be sent
// 1695  * @param   direction - direction of the command
// 1696  * @param   seqNum - transaction sequence number
// 1697  *
// 1698  * @return  ZSuccess if OK
// 1699  */
// 1700 ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
// 1701                             uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
// 1702                             uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1703 {
// 1704   uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
// 1705   uint8 *buf;
// 1706   ZStatus_t status;
// 1707 
// 1708   buf = zcl_mem_alloc( dataLen );
// 1709   if ( buf != NULL )
// 1710   {
// 1711     // Load the buffer - serially
// 1712     uint8 *pBuf = buf;
// 1713     *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
// 1714     *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
// 1715     *pBuf++ = pDiscoverCmd->maxAttrIDs;
// 1716 
// 1717     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
// 1718                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
// 1719     zcl_mem_free( buf );
// 1720   }
// 1721   else
// 1722   {
// 1723     status = ZMemError;
// 1724   }
// 1725 
// 1726   return ( status );
// 1727 }
// 1728 
// 1729 /*********************************************************************
// 1730  * @fn      zcl_SendDiscoverAttrsRspCmd
// 1731  *
// 1732  * @brief   Send a Discover Attributes Response command
// 1733  *
// 1734  * @param   dstAddr - destination address
// 1735  * @param   clusterID - cluster ID
// 1736  * @param   reportRspCmd - report response command to be sent
// 1737  * @param   direction - direction of the command
// 1738  * @param   seqNum - transaction sequence number
// 1739  *
// 1740  * @return  ZSuccess if OK
// 1741  */
// 1742 ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
// 1743                           uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
// 1744                           uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1745 {
// 1746   uint16 dataLen = 1; // Discovery complete
// 1747   uint8 *buf;
// 1748   ZStatus_t status;
// 1749 
// 1750   // calculate the size of the command
// 1751   dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
// 1752 
// 1753   buf = zcl_mem_alloc( dataLen );
// 1754   if ( buf != NULL )
// 1755   {
// 1756     // Load the buffer - serially
// 1757     uint8 i;
// 1758     uint8 *pBuf = buf;
// 1759 
// 1760     *pBuf++ = pDiscoverRspCmd->discComplete;
// 1761 
// 1762     for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
// 1763     {
// 1764       *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
// 1765       *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
// 1766       *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
// 1767     }
// 1768 
// 1769     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
// 1770                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
// 1771     zcl_mem_free( buf );
// 1772   }
// 1773   else
// 1774   {
// 1775     status = ZMemError;
// 1776   }
// 1777 
// 1778   return ( status );
// 1779 }
// 1780 
// 1781 /*********************************************************************
// 1782  * @fn      zcl_SendDiscoverAttrsExt
// 1783  *
// 1784  * @brief   Send a Discover Attributes Extended command
// 1785  *
// 1786  * @param   dstAddr - destination address
// 1787  * @param   clusterID - cluster ID
// 1788  * @param   pDiscoverAttrsExt:
// 1789  *            - startAttrID: the first attribute to be selected
// 1790  *            - maxAttrIDs: maximum number of returned attributes
// 1791  * @param   direction - direction of the command
// 1792  * @param   seqNum - transaction sequence number
// 1793  *
// 1794  * @return  ZSuccess if OK
// 1795  */
// 1796 ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
// 1797                             uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
// 1798                             uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1799 {
// 1800   uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
// 1801   ZStatus_t status;
// 1802 
// 1803   // Load the buffer - serially
// 1804   buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
// 1805   buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
// 1806   buf[2] = pDiscoverAttrsExt->maxAttrIDs;
// 1807 
// 1808   status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
// 1809                             direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
// 1810 
// 1811   return ( status );
// 1812 }
// 1813 
// 1814 /*********************************************************************
// 1815  * @fn      zcl_SendDiscoverAttrsExtRsp
// 1816  *
// 1817  * @brief   Send a Discover Attributes Extended Response command
// 1818  *
// 1819  * @param   dstAddr - destination address
// 1820  * @param   clusterID - cluster ID
// 1821  * @param   pDiscoverRspCmd:
// 1822  *            - discComplete: indicates whether all requested attributes returned
// 1823  *            - attrID: attribute ID
// 1824  *            - attrDataType: data type of the given attribute
// 1825  *            - attrAccessControl: access control of the given attribute
// 1826  * @param   direction - direction of the command
// 1827  * @param   seqNum - transaction sequence number
// 1828  *
// 1829  * @return  ZSuccess if OK
// 1830  */
// 1831 ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
// 1832                                       uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
// 1833                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1834 {
// 1835   uint8 *buf;
// 1836   uint8 i;
// 1837   uint16 dataLen = 1; // Discovery complete
// 1838   ZStatus_t status;
// 1839 
// 1840   // calculate the size of the command
// 1841   dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
// 1842 
// 1843   buf = zcl_mem_alloc( dataLen );
// 1844   if ( buf != NULL )
// 1845   {
// 1846     // Load the buffer - serially
// 1847     uint8 *pBuf = buf;
// 1848     *pBuf++ = pDiscoverRspCmd->discComplete;
// 1849     for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
// 1850     {
// 1851       *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
// 1852       *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
// 1853       *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
// 1854       *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
// 1855     }
// 1856 
// 1857     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
// 1858                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
// 1859     zcl_mem_free( buf );
// 1860   }
// 1861   else
// 1862   {
// 1863     status = ZMemError;
// 1864   }
// 1865 
// 1866   return ( status );
// 1867 }
// 1868 #endif // ZCL_DISCOVER
// 1869 
// 1870 /*********************************************************************
// 1871  * @fn      zcl_ProcessMessageMSG
// 1872  *
// 1873  * @brief   Data message processor callback.  This function processes
// 1874  *          any incoming data - probably from other devices.  So, based
// 1875  *          on cluster ID, perform the intended action.
// 1876  *
// 1877  * @param   pkt - incoming message
// 1878  *
// 1879  * @return  none
// 1880  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
??Subroutine15_0:
          CFI Block cfiCond77 Using cfiCommon0
          CFI Function zclProcessInWriteCmd
          CFI Conditional ??CrossCallReturnLabel_18
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+36
          CFI Block cfiCond78 Using cfiCommon0
          CFI (cfiCond78) Function zcl_ProcessMessageMSG
          CFI (cfiCond78) Conditional ??CrossCallReturnLabel_19
          CFI (cfiCond78) R8L Frame(CFA, -12)
          CFI (cfiCond78) R9L Frame(CFA, -10)
          CFI (cfiCond78) R10L Frame(CFA, -8)
          CFI (cfiCond78) R11L Frame(CFA, -6)
          CFI (cfiCond78) CFA SP+44
          CFI Block cfiCond79 Using cfiCommon0
          CFI (cfiCond79) Function zcl_ProcessMessageMSG
          CFI (cfiCond79) Conditional ??CrossCallReturnLabel_20
          CFI (cfiCond79) R8L Frame(CFA, -12)
          CFI (cfiCond79) R9L Frame(CFA, -10)
          CFI (cfiCond79) R10L Frame(CFA, -8)
          CFI (cfiCond79) R11L Frame(CFA, -6)
          CFI (cfiCond79) CFA SP+44
          CFI Block cfiCond80 Using cfiCommon0
          CFI (cfiCond80) Function zclProcessInWriteUndividedCmd
          CFI (cfiCond80) Conditional ??CrossCallReturnLabel_21
          CFI (cfiCond80) R4L Frame(CFA, -20)
          CFI (cfiCond80) R5L Frame(CFA, -18)
          CFI (cfiCond80) R6L Frame(CFA, -16)
          CFI (cfiCond80) R7L Frame(CFA, -14)
          CFI (cfiCond80) R8L Frame(CFA, -12)
          CFI (cfiCond80) R9L Frame(CFA, -10)
          CFI (cfiCond80) R10L Frame(CFA, -8)
          CFI (cfiCond80) R11L Frame(CFA, -6)
          CFI (cfiCond80) CFA SP+40
          CFI Block cfiCond81 Using cfiCommon0
          CFI (cfiCond81) Function zclProcessInReadCmd
          CFI (cfiCond81) Conditional ??CrossCallReturnLabel_22
          CFI (cfiCond81) R4L Frame(CFA, -20)
          CFI (cfiCond81) R5L Frame(CFA, -18)
          CFI (cfiCond81) R6L Frame(CFA, -16)
          CFI (cfiCond81) R7L Frame(CFA, -14)
          CFI (cfiCond81) R8L Frame(CFA, -12)
          CFI (cfiCond81) R9L Frame(CFA, -10)
          CFI (cfiCond81) R10L Frame(CFA, -8)
          CFI (cfiCond81) R11L Frame(CFA, -6)
          CFI (cfiCond81) CFA SP+36
          CFI Block cfiPicker82 Using cfiCommon1
          CFI (cfiPicker82) NoFunction
          CFI (cfiPicker82) Picker
        SUBC.B  R14, R14
        ADD.B   #0x1, R14
        XOR.B   #0x1, R14
        AND.B   #0x1, R14
        RETA
          CFI EndBlock cfiCond77
          CFI EndBlock cfiCond78
          CFI EndBlock cfiCond79
          CFI EndBlock cfiCond80
          CFI EndBlock cfiCond81
          CFI EndBlock cfiPicker82

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1881 void zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
zcl_ProcessMessageMSG:
          CFI Block cfiBlock83 Using cfiCommon0
          CFI Function zcl_ProcessMessageMSG
// 1882 {
        FUNCALL zcl_ProcessMessageMSG, zclParseHdr
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zcl_ProcessMessageMSG, afFindEndPointDesc
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zcl_ProcessMessageMSG, zcl_DeviceOperational
        LOCFRAME CSTACK, 36, STACK
        FUNCALL zcl_ProcessMessageMSG, zclGetClusterOption
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zcl_ProcessMessageMSG, zclSetSecurityOption
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zcl_ProcessMessageMSG, zcl_SendDefaultRspCmd
        LOCFRAME CSTACK, 42, STACK
        FUNCALL zcl_ProcessMessageMSG, zclSetSecurityOption
        LOCFRAME CSTACK, 42, STACK
        FUNCALL zcl_ProcessMessageMSG
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zcl_ProcessMessageMSG
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zcl_ProcessMessageMSG, osal_mem_free
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zcl_ProcessMessageMSG
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zcl_ProcessMessageMSG, zcl_SendDefaultRspCmd
        LOCFRAME CSTACK, 42, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x16, SP
          CFI CFA SP+34
        MOV.W   R12, R8
// 1883   endPointDesc_t *epDesc;
// 1884   zclIncoming_t inMsg;
// 1885   zclLibPlugin_t *pInPlugin;
// 1886   zclDefaultRspCmd_t defautlRspCmd;
// 1887   uint8 options;
// 1888   uint8 securityEnable;
// 1889   uint8 interPanMsg;
// 1890   ZStatus_t status = ZFailure;
// 1891 
// 1892   if ( pkt->cmd.DataLength == 0 )
        CMP.W   #0x0, 0x22(R12)
        JEQ     ??zcl_ProcessMessageMSG_2
// 1893   {
// 1894     return;   // Error, ignore the message
// 1895   }
// 1896 
// 1897   // Initialize
// 1898   rawAFMsg = (afIncomingMSGPacket_t *)pkt;
        MOV.W   R12, &rawAFMsg
// 1899   inMsg.msg = pkt;
        MOV.W   R12, 0x2(SP)
// 1900   inMsg.attrCmd = NULL;
        MOV.W   #0x0, 0xe(SP)
// 1901   inMsg.pData = NULL;
        MOV.W   #0x0, 0xa(SP)
// 1902   inMsg.pDataLen = 0;
        MOV.W   #0x0, 0xc(SP)
// 1903 
// 1904   inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
        MOV.W   SP, R10
        ADD.W   #0x2, R10
        MOV.W   0x24(R12), R13
        MOV.W   R10, R12
        ADD.W   #0x2, R12
        CALLA   #zclParseHdr
        MOV.W   R12, 0xa(SP)
// 1905   inMsg.pDataLen = pkt->cmd.DataLength;
// 1906   inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
        MOV.W   0x22(R8), R15
        SUB.W   R12, R15
        ADD.W   0x24(R8), R15
        MOV.W   R15, 0xc(SP)
// 1907 
// 1908   // Find the wanted endpoint
// 1909   epDesc = afFindEndPointDesc( pkt->endPoint );
        MOV.W   R8, R11
        ADD.W   #0x14, R11
        MOV.B   @R11, R12
        CALLA   #afFindEndPointDesc
// 1910   if ( epDesc == NULL )
        CMP.W   #0x0, R12
        JEQ     ??zcl_ProcessMessageMSG_3
// 1911   {
// 1912     rawAFMsg = NULL;
// 1913     return;   // Error, ignore the message
// 1914   }
// 1915 
// 1916   if ( ( epDesc->simpleDesc == NULL ) ||
// 1917        ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
// 1918                                 inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
        MOV.W   0x4(R12), R15
        CMP.W   #0x0, R15
        JEQ     ??zcl_ProcessMessageMSG_3
        MOV.W   R8, R9
        ADD.W   #0x4, R9
        PUSH.W  0x2(R15)
          CFI CFA SP+36
        MOV.B   0xb(SP), R15
        MOV.B   0x6(SP), R14
        AND.B   #0x3, R14
        MOV.W   @R9, R13
        MOV.B   @R11, R12
        CALLA   #zcl_DeviceOperational
        ADD.W   #0x2, SP
          CFI CFA SP+34
        CMP.B   #0x0, R12
        JEQ     ??zcl_ProcessMessageMSG_3
// 1919   {
// 1920     rawAFMsg = NULL;
// 1921     return; // Error, ignore the message
// 1922   }
// 1923 
// 1924 #if defined ( INTER_PAN )
// 1925   if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
// 1926   {
// 1927     // No foundation command is supported thru Inter-PAN communication.
// 1928     // But the Light Link cluster uses a different Frame Control format
// 1929     // for it's Inter-PAN messages, where the messages could be confused
// 1930     // with the foundation commands.
// 1931     if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
// 1932     {
// 1933       rawAFMsg = NULL;
// 1934       return;
// 1935     }
// 1936 
// 1937     interPanMsg = TRUE;
// 1938     options = AF_TX_OPTIONS_NONE;
// 1939   }
// 1940   else
// 1941 #endif
// 1942   {
// 1943     interPanMsg = FALSE;
// 1944     options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
        MOV.W   @R9, R13
        MOV.B   @R11, R12
        CALLA   #zclGetClusterOption
        MOV.W   @R9, R15
        MOV.W   &plugins, R14
        JMP     ??zcl_ProcessMessageMSG_4
??zcl_ProcessMessageMSG_0:
        MOV.W   @R14, R14
??zcl_ProcessMessageMSG_4:
        CMP.W   #0x0, R14
        JEQ     ??zcl_ProcessMessageMSG_5
        CMP.W   0x2(R14), R15
        JNC     ??zcl_ProcessMessageMSG_0
        CMP.W   R15, 0x4(R14)
        JNC     ??zcl_ProcessMessageMSG_0
        BIT.B   #0x7, 0x4(SP)
        JNE     ??zcl_ProcessMessageMSG_6
        CMP.B   #0xb, 0x9(SP)
        JEQ     ??zcl_ProcessMessageMSG_7
// 1945   }
// 1946 
// 1947   // Find the appropriate plugin
// 1948   pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
// 1949 
// 1950   // Local and remote Security options must match except for Default Response command
// 1951   if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
// 1952   {
// 1953     securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
??zcl_ProcessMessageMSG_6:
        BIT.B   #0x40, R12
        JNC     ??zcl_ProcessMessageMSG_7
        CMP.B   #0x0, 0x19(R8)
        JNE     ??zcl_ProcessMessageMSG_7
// 1954 
// 1955     // Make sure that Clusters specifically defined to use security are received secure,
// 1956     // any other cluster that wants to use APS security will be allowed
// 1957     if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
// 1958     {
// 1959       if ( UNICAST_MSG( inMsg.msg ) )
        MOV.W   0x2(SP), R15
        CMP.B   #0x0, 0x15(R15)
        JNE     ??zcl_ProcessMessageMSG_3
        CMP.W   #0x0, 0x2(R15)
        JNE     ??zcl_ProcessMessageMSG_3
// 1960       {
// 1961         // Send a Default Response command back with no Application Link Key security
// 1962         zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
        MOV.B   #0x0, R14
        MOV.W   @R9, R13
        MOV.B   @R11, R12
        CALLA   #zclSetSecurityOption
// 1963 
// 1964         defautlRspCmd.statusCode = status;
        MOV.B   #0x1, 0x1(SP)
// 1965         defautlRspCmd.commandID = inMsg.hdr.commandID;
        MOV.B   0x9(SP), 0(SP)
// 1966         zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
// 1967                                inMsg.msg->clusterId, &defautlRspCmd,
// 1968                                !inMsg.hdr.fc.direction, true,
// 1969                                inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
        PUSH.B  0xa(SP)
          CFI CFA SP+36
        PUSH.W  0xa(SP)
          CFI CFA SP+38
        PUSH.B  #0x1
          CFI CFA SP+40
        BIT.W   #0x8, 0xa(SP)
        CALLA   #??Subroutine15_0
??CrossCallReturnLabel_19:
        PUSH.B  R14
          CFI CFA SP+42
        MOV.W   SP, R15
        ADD.W   #0x8, R15
        MOV.W   0xa(SP), R14
        MOV.W   0x4(R14), R14
        MOV.W   0xa(SP), R13
        ADD.W   #0x6, R13
        MOV.W   0xa(SP), R10
        MOV.B   0x14(R10), R12
        CALLA   #zcl_SendDefaultRspCmd
// 1970 
// 1971         zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
        MOV.B   #0x1, R14
        MOV.W   @R9, R13
        MOV.B   @R11, R12
        CALLA   #zclSetSecurityOption
        JMP     ??zcl_ProcessMessageMSG_8
          CFI CFA SP+34
// 1972       }
// 1973 
// 1974       rawAFMsg = NULL;
// 1975       return;   // Error, ignore the message
// 1976     }
// 1977   }
??zcl_ProcessMessageMSG_5:
        MOV.W   #0x0, R14
// 1978 
// 1979   // Is this a foundation type message
// 1980   if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
??zcl_ProcessMessageMSG_7:
        BIT.B   #0x3, 0x4(SP)
        JNE     ??zcl_ProcessMessageMSG_9
// 1981   {
// 1982     if ( inMsg.hdr.fc.manuSpecific )
        BIT.W   #0x4, 0x4(SP)
        JNC     ??zcl_ProcessMessageMSG_10
// 1983     {
// 1984       // We don't support any manufacturer specific command
// 1985       status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
        MOV.B   #0x84, R12
        JMP     ??zcl_ProcessMessageMSG_11
// 1986     }
// 1987     else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
// 1988               ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
??zcl_ProcessMessageMSG_10:
        MOV.B   0x9(SP), R15
        CMP.B   #0x17, R15
        JC      ??zcl_ProcessMessageMSG_12
        RLAM.W  #0x3, R15
        MOV.W   zclCmdTable(R15), R14
        BIS.W   zclCmdTable + 2(R15), R14
        CMP.W   #0x0, R14
        JEQ     ??zcl_ProcessMessageMSG_12
// 1989     {
// 1990       zclParseCmd_t parseCmd;
// 1991 
// 1992       parseCmd.endpoint = pkt->endPoint;
        MOV.B   @R11, 0x10(SP)
// 1993       parseCmd.dataLen = inMsg.pDataLen;
        MOV.W   0xc(SP), 0x12(SP)
// 1994       parseCmd.pData = inMsg.pData;
        MOV.W   0xa(SP), 0x14(SP)
// 1995 
// 1996       // Parse the command, remember that the return value is a pointer to allocated memory
// 1997       inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
        MOV.W   SP, R12
        ADD.W   #0x10, R12
        MOV.B   0x9(SP), R15
        RLAM.W  #0x3, R15
        MOV.W   zclCmdTable(R15), R14
        MOV.W   zclCmdTable + 2(R15), R15
        CALLA   #?IndCallR15
        MOV.W   R12, 0xe(SP)
// 1998       if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
        CMP.W   #0x0, R12
        JEQ     ??zcl_ProcessMessageMSG_13
        MOV.B   0x9(SP), R15
        RLAM.W  #0x3, R15
        MOV.W   zclCmdTable + 4(R15), R14
        MOV.W   zclCmdTable + 6(R15), R15
        MOV.W   R14, R11
        BIS.W   R15, R11
        CMP.W   #0x0, R11
        JEQ     ??zcl_ProcessMessageMSG_14
// 1999       {
// 2000         // Process the command
// 2001         if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
        MOV.W   R10, R12
        CALLA   #?IndCallR15
// 2002         {
// 2003           // Couldn't find attribute in the table.
// 2004         }
// 2005       }
// 2006 
// 2007       // Free the buffer
// 2008       if ( inMsg.attrCmd )
        CMP.W   #0x0, 0xe(SP)
        JEQ     ??zcl_ProcessMessageMSG_13
// 2009       {
// 2010         zcl_mem_free( inMsg.attrCmd );
??zcl_ProcessMessageMSG_14:
        MOV.W   0xe(SP), R12
        CALLA   #osal_mem_free
// 2011       }
// 2012 
// 2013       if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
??zcl_ProcessMessageMSG_13:
        MOV.B   0x9(SP), R14
        CMP.B   #0x0, R14
        JEQ     ??zcl_ProcessMessageMSG_3
        CMP.B   #0x2, R14
        JEQ     ??zcl_ProcessMessageMSG_3
        CMP.B   #0x3, R14
        JEQ     ??zcl_ProcessMessageMSG_3
        CMP.B   #0x6, R14
        JEQ     ??zcl_ProcessMessageMSG_3
        CMP.B   #0x8, R14
        JEQ     ??zcl_ProcessMessageMSG_3
        CMP.B   #0xc, R14
        JEQ     ??zcl_ProcessMessageMSG_3
        CMP.B   #0x11, R14
        JEQ     ??zcl_ProcessMessageMSG_3
        CMP.B   #0x13, R14
        JEQ     ??zcl_ProcessMessageMSG_3
        CMP.B   #0x15, R14
        JEQ     ??zcl_ProcessMessageMSG_3
        CMP.B   #0xb, R14
        JEQ     ??zcl_ProcessMessageMSG_3
// 2014       {
// 2015         rawAFMsg = NULL;
// 2016         return; // We're done
// 2017       }
// 2018 
// 2019       status = ZSuccess;
        MOV.B   #0x0, R12
        JMP     ??zcl_ProcessMessageMSG_11
// 2020     }
// 2021     else
// 2022     {
// 2023       // Unsupported message
// 2024       status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
??zcl_ProcessMessageMSG_12:
        MOV.B   #0x82, R12
        JMP     ??zcl_ProcessMessageMSG_11
// 2025     }
// 2026   }
// 2027   else  // Not a foundation type message, so it must be specific to the cluster ID.
// 2028   {
// 2029     if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
??zcl_ProcessMessageMSG_9:
        CMP.W   #0x0, R14
        JEQ     ??zcl_ProcessMessageMSG_15
        MOV.W   R14, R15
        MOV.W   0x6(R15), R14
        MOV.W   0x8(R15), R15
        MOV.W   R14, R11
        BIS.W   R15, R11
        CMP.W   #0x0, R11
        JEQ     ??zcl_ProcessMessageMSG_15
// 2030     {
// 2031       // The return value of the plugin function will be
// 2032       //  ZSuccess - Supported and need default response
// 2033       //  ZFailure - Unsupported
// 2034       //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
// 2035       //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
// 2036       //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
// 2037       //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
// 2038       status = pInPlugin->pfnIncomingHdlr( &inMsg );
        MOV.W   R10, R12
        CALLA   #?IndCallR15
// 2039       if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
        CMP.B   #0xff, R12
        JEQ     ??zcl_ProcessMessageMSG_3
// 2040       {
// 2041         rawAFMsg = NULL;
// 2042         return; // We're done
// 2043       }
// 2044     }
// 2045 
// 2046     if ( status == ZFailure )
        CMP.B   #0x1, R12
        JNE     ??zcl_ProcessMessageMSG_11
// 2047     {
// 2048       // Unsupported message
// 2049       if ( inMsg.hdr.fc.manuSpecific )
??zcl_ProcessMessageMSG_15:
        BIT.W   #0x4, 0x4(SP)
        SUBC.B  R12, R12
        RLA.B   R12
        ADD.B   #0x83, R12
// 2050       {
// 2051         status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
// 2052       }
// 2053       else
// 2054       {
// 2055         status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
// 2056       }
// 2057     }
// 2058   }
// 2059 
// 2060   if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
??zcl_ProcessMessageMSG_11:
        MOV.W   0x2(SP), R15
        CMP.B   #0x0, 0x15(R15)
        JNE     ??zcl_ProcessMessageMSG_3
        CMP.W   #0x0, 0x2(R15)
        JNE     ??zcl_ProcessMessageMSG_3
        BIT.W   #0x10, 0x4(SP)
        JC      ??zcl_ProcessMessageMSG_3
// 2061   {
// 2062     // Send a Default Response command back
// 2063     defautlRspCmd.statusCode = status;
        MOV.B   R12, 0x1(SP)
// 2064     defautlRspCmd.commandID = inMsg.hdr.commandID;
        MOV.B   0x9(SP), 0(SP)
// 2065     zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
// 2066                            inMsg.msg->clusterId, &defautlRspCmd,
// 2067                            !inMsg.hdr.fc.direction, true,
// 2068                            inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
        PUSH.B  0xa(SP)
          CFI CFA SP+36
        PUSH.W  0xa(SP)
          CFI CFA SP+38
        PUSH.B  #0x1
          CFI CFA SP+40
        BIT.W   #0x8, 0xa(SP)
        CALLA   #??Subroutine15_0
// 2069   }
??CrossCallReturnLabel_20:
        PUSH.B  R14
          CFI CFA SP+42
        MOV.W   SP, R15
        ADD.W   #0x8, R15
        MOV.W   0xa(SP), R11
        CALLA   #?Subroutine16
??CrossCallReturnLabel_9:
        CALLA   #zcl_SendDefaultRspCmd
??zcl_ProcessMessageMSG_8:
        ADD.W   #0x8, SP
          CFI CFA SP+34
// 2070 
// 2071   rawAFMsg = NULL;
??zcl_ProcessMessageMSG_3:
        MOV.W   #0x0, &rawAFMsg
// 2072 }
??zcl_ProcessMessageMSG_2:
        ADD.W   #0x16, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock83

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine16:
          CFI Block cfiCond84 Using cfiCommon0
          CFI Function zclProcessInWriteUndividedCmd
          CFI Conditional ??CrossCallReturnLabel_8
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+42
          CFI Block cfiCond85 Using cfiCommon0
          CFI (cfiCond85) Function zcl_ProcessMessageMSG
          CFI (cfiCond85) Conditional ??CrossCallReturnLabel_9
          CFI (cfiCond85) R8L Frame(CFA, -12)
          CFI (cfiCond85) R9L Frame(CFA, -10)
          CFI (cfiCond85) R10L Frame(CFA, -8)
          CFI (cfiCond85) R11L Frame(CFA, -6)
          CFI (cfiCond85) CFA SP+46
          CFI Block cfiPicker86 Using cfiCommon1
          CFI (cfiPicker86) NoFunction
          CFI (cfiPicker86) Picker
        MOV.W   0x4(R11), R14
        MOV.W   R11, R13
        ADD.W   #0x6, R13
        MOV.B   0x14(R11), R12
        RETA
          CFI EndBlock cfiCond84
          CFI EndBlock cfiCond85
          CFI EndBlock cfiPicker86
// 2073 
// 2074 /*********************************************************************
// 2075  * PRIVATE FUNCTIONS
// 2076  *********************************************************************/
// 2077 
// 2078 /*********************************************************************
// 2079  * @fn      zclParseHdr
// 2080  *
// 2081  * @brief   Parse header of the ZCL format
// 2082  *
// 2083  * @param   hdr - place to put the frame control information
// 2084  * @param   pData - incoming buffer to parse
// 2085  *
// 2086  * @return  pointer past the header
// 2087  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 2088 uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
zclParseHdr:
          CFI Block cfiBlock87 Using cfiCommon0
          CFI Function zclParseHdr
// 2089 {
        FUNCALL zclParseHdr, osal_memset
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.W   R12, R10
        MOV.W   R13, R11
// 2090   // Clear the header
// 2091   zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
        MOV.W   #0x6, R14
        MOV.B   #0x0, R13
        CALLA   #osal_memset
// 2092 
// 2093   // Parse the Frame Control
// 2094   hdr->fc.type = zcl_FCType( *pData );
        MOV.B   @R11, R15
        AND.W   #0x3, R15
        MOV.W   @R10, R14
        AND.W   #0xfffc, R14
        BIS.W   R15, R14
        MOV.W   R14, 0(R10)
// 2095   hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
        BIT.B   #0x4, 0(R11)
        SUBC.B  R14, R14
        ADD.B   #0x1, R14
        BIT.W   #0x1, R14
        JC      ??zclParseHdr_0
        BIC.W   #0x4, 0(R10)
        JMP     ??zclParseHdr_1
??zclParseHdr_0:
        BIS.W   #0x4, 0(R10)
// 2096   if ( zcl_FCDirection( *pData ) )
??zclParseHdr_1:
        BIT.B   #0x8, 0(R11)
        JNC     ??zclParseHdr_2
// 2097   {
// 2098     hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
        BIS.W   #0x8, 0(R10)
        JMP     ??zclParseHdr_3
// 2099   }
// 2100   else
// 2101   {
// 2102     hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
??zclParseHdr_2:
        BIC.W   #0x8, 0(R10)
// 2103   }
// 2104 
// 2105   hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
??zclParseHdr_3:
        MOV.W   R11, R15
        ADD.W   #0x1, R11
        BIT.B   #0x10, 0(R15)
        SUBC.B  R14, R14
        ADD.B   #0x1, R14
        BIT.W   #0x1, R14
        JC      ??zclParseHdr_4
        BIC.W   #0x10, 0(R10)
        JMP     ??zclParseHdr_5
??zclParseHdr_4:
        BIS.W   #0x10, 0(R10)
// 2106   pData++;  // move past the frame control field
// 2107 
// 2108   // parse the manfacturer code
// 2109   if ( hdr->fc.manuSpecific )
??zclParseHdr_5:
        BIT.W   #0x4, 0(R10)
        JNC     ??zclParseHdr_6
// 2110   {
// 2111     hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
        MOV.B   @R11, R14
        MOV.B   0x1(R11), R15
        RPT     #0x8
        RLAX.W  R15
        ADD.W   R15, R14
        MOV.W   R14, 0x2(R10)
// 2112     pData += 2;
        ADD.W   #0x2, R11
// 2113   }
// 2114 
// 2115   // parse the Transaction Sequence Number
// 2116   hdr->transSeqNum = *pData++;
??zclParseHdr_6:
        MOV.B   @R11+, 0x4(R10)
// 2117 
// 2118   // parse the Cluster's command ID
// 2119   hdr->commandID = *pData++;
        MOV.B   @R11+, 0x5(R10)
// 2120 
// 2121   // Should point to the frame payload
// 2122   return ( pData );
        MOV.W   R11, R12
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock87
// 2123 }
// 2124 
// 2125 /*********************************************************************
// 2126  * @fn      zclBuildHdr
// 2127  *
// 2128  * @brief   Build header of the ZCL format
// 2129  *
// 2130  * @param   hdr - outgoing header information
// 2131  * @param   pData - outgoing header space
// 2132  *
// 2133  * @return  pointer past the header
// 2134  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 2135 static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
zclBuildHdr:
          CFI Block cfiBlock88 Using cfiCommon0
          CFI Function zclBuildHdr
// 2136 {
// 2137   // Build the Frame Control byte
// 2138   *pData = hdr->fc.type;
        MOV.B   @R12, R14
        AND.B   #0x3, R14
        MOV.B   R14, 0(R13)
// 2139   *pData |= hdr->fc.manuSpecific << 2;
        MOV.B   @R12, R14
        AND.B   #0x4, R14
        BIS.B   R14, 0(R13)
// 2140   *pData |= hdr->fc.direction << 3;
        MOV.B   @R12, R14
        AND.B   #0x8, R14
        BIS.B   R14, 0(R13)
// 2141   *pData |= hdr->fc.disableDefaultRsp << 4;
        MOV.B   @R12, R14
        AND.B   #0x10, R14
        BIS.B   R14, 0(R13)
// 2142   pData++;  // move past the frame control field
        ADD.W   #0x1, R13
// 2143 
// 2144   // Add the manfacturer code
// 2145   if ( hdr->fc.manuSpecific )
        BIT.W   #0x4, 0(R12)
        JNC     ??zclBuildHdr_0
// 2146   {
// 2147     *pData++ = LO_UINT16( hdr->manuCode );
        MOV.B   0x2(R12), 0(R13)
        ADD.W   #0x1, R13
// 2148     *pData++ = HI_UINT16( hdr->manuCode );
        MOV.B   0x3(R12), 0(R13)
        ADD.W   #0x1, R13
// 2149   }
// 2150 
// 2151   // Add the Transaction Sequence Number
// 2152   *pData++ = hdr->transSeqNum;
??zclBuildHdr_0:
        MOV.B   0x4(R12), 0(R13)
        ADD.W   #0x1, R13
// 2153 
// 2154   // Add the Cluster's command ID
// 2155   *pData++ = hdr->commandID;
        MOV.B   0x5(R12), 0(R13)
        ADD.W   #0x1, R13
// 2156 
// 2157   // Should point to the frame payload
// 2158   return ( pData );
        MOV.W   R13, R12
        RETA
          CFI EndBlock cfiBlock88
// 2159 }
// 2160 
// 2161 /*********************************************************************
// 2162  * @fn      zclCalcHdrSize
// 2163  *
// 2164  * @brief   Calculate the number of bytes needed for an outgoing
// 2165  *          ZCL header.
// 2166  *
// 2167  * @param   hdr - outgoing header information
// 2168  *
// 2169  * @return  returns the number of bytes needed
// 2170  */
// 2171 static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
// 2172 {
// 2173   uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
// 2174 
// 2175   // Add the manfacturer code
// 2176   if ( hdr->fc.manuSpecific )
// 2177   {
// 2178     needed += 2;
// 2179   }
// 2180 
// 2181   return ( needed );
// 2182 }
// 2183 
// 2184 /*********************************************************************
// 2185  * @fn      zclFindPlugin
// 2186  *
// 2187  * @brief   Find the right plugin for a cluster ID
// 2188  *
// 2189  * @param   clusterID - cluster ID to look for
// 2190  * @param   profileID - profile ID
// 2191  *
// 2192  * @return  pointer to plugin, NULL if not found
// 2193  */
// 2194 static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
// 2195 {
// 2196   zclLibPlugin_t *pLoop = plugins;
// 2197 
// 2198   (void)profileID;  // Intentionally unreferenced parameter
// 2199 
// 2200   while ( pLoop != NULL )
// 2201   {
// 2202     if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
// 2203     {
// 2204       return ( pLoop );
// 2205     }
// 2206 
// 2207     pLoop = pLoop->next;
// 2208   }
// 2209 
// 2210   return ( (zclLibPlugin_t *)NULL );
// 2211 }
// 2212 
// 2213 #ifdef ZCL_DISCOVER
// 2214 /*********************************************************************
// 2215  * @fn      zclFindCmdRecsList
// 2216  *
// 2217  * @brief   Find the right command record list for an endpoint
// 2218  *
// 2219  * @param   endpoint - endpoint to look for
// 2220  *
// 2221  * @return  pointer to record list, NULL if not found
// 2222  */
// 2223 static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
// 2224 {
// 2225   zclCmdRecsList_t *pLoop = gpCmdList;
// 2226 
// 2227   while ( pLoop != NULL )
// 2228   {
// 2229     if ( pLoop->endpoint == endpoint )
// 2230     {
// 2231       return ( pLoop );
// 2232     }
// 2233 
// 2234     pLoop = pLoop->pNext;
// 2235   }
// 2236 
// 2237   return ( NULL );
// 2238 }
// 2239 
// 2240 /*********************************************************************
// 2241  * @fn      zclFindCmdRec
// 2242  *
// 2243  * @brief   Find the command record that matchs the parameters
// 2244  *
// 2245  * @param   endpoint - Application's endpoint
// 2246  * @param   clusterID - cluster ID
// 2247  * @param   attrId - attribute looking for
// 2248  * @param   pAttr - attribute record to be returned
// 2249  *
// 2250  * @return  TRUE if record found. FALSE, otherwise.
// 2251  */
// 2252 uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
// 2253 {
// 2254   uint8 i;
// 2255   zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
// 2256 
// 2257   if ( pRec != NULL )
// 2258   {
// 2259     for ( i = 0; i < pRec->numCommands; i++ )
// 2260     {
// 2261       if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
// 2262       {
// 2263         *pCmd = pRec->pCmdRecs[i];
// 2264 
// 2265         return ( TRUE ); // EMBEDDED RETURN
// 2266       }
// 2267     }
// 2268   }
// 2269 
// 2270   return ( FALSE );
// 2271 }
// 2272 #endif // ZCL_DISCOVER
// 2273 
// 2274 /*********************************************************************
// 2275  * @fn      zclFindAttrRecsList
// 2276  *
// 2277  * @brief   Find the right attribute record list for an endpoint
// 2278  *
// 2279  * @param   clusterID - endpointto look for
// 2280  *
// 2281  * @return  pointer to record list, NULL if not found
// 2282  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 2283 static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
zclFindAttrRecsList:
          CFI Block cfiBlock89 Using cfiCommon0
          CFI Function zclFindAttrRecsList
// 2284 {
// 2285   zclAttrRecsList *pLoop = attrList;
        MOV.W   &attrList, R15
        JMP     ??zclFindAttrRecsList_1
// 2286 
// 2287   while ( pLoop != NULL )
// 2288   {
// 2289     if ( pLoop->endpoint == endpoint )
// 2290     {
// 2291       return ( pLoop );
// 2292     }
// 2293 
// 2294     pLoop = pLoop->next;
??zclFindAttrRecsList_0:
        MOV.W   @R15, R15
??zclFindAttrRecsList_1:
        CMP.W   #0x0, R15
        JEQ     ??zclFindAttrRecsList_2
        CMP.B   R12, 0x2(R15)
        JNE     ??zclFindAttrRecsList_0
        MOV.W   R15, R12
        RETA
// 2295   }
// 2296 
// 2297   return ( NULL );
??zclFindAttrRecsList_2:
        MOV.W   #0x0, R12
        RETA
          CFI EndBlock cfiBlock89
// 2298 }
// 2299 
// 2300 /*********************************************************************
// 2301  * @fn      zclFindAttrRec
// 2302  *
// 2303  * @brief   Find the attribute record that matchs the parameters
// 2304  *
// 2305  * @param   endpoint - Application's endpoint
// 2306  * @param   clusterID - cluster ID
// 2307  * @param   attrId - attribute looking for
// 2308  * @param   pAttr - attribute record to be returned
// 2309  *
// 2310  * @return  TRUE if record found. FALSE, otherwise.
// 2311  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 2312 uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
zclFindAttrRec:
          CFI Block cfiBlock90 Using cfiCommon0
          CFI Function zclFindAttrRec
// 2313 {
        FUNCALL zclFindAttrRec, zclFindAttrRecsList
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R13, R10
        MOV.W   R14, R11
        MOV.W   R15, R8
// 2314   uint8 x;
// 2315   zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
        CALLA   #zclFindAttrRecsList
// 2316 
// 2317   if ( pRec != NULL )
        CMP.W   #0x0, R12
        JEQ     ??zclFindAttrRec_1
// 2318   {
// 2319     for ( x = 0; x < pRec->numAttributes; x++ )
        MOV.B   #0x0, R14
        JMP     ??zclFindAttrRec_2
??zclFindAttrRec_0:
        ADD.B   #0x1, R14
??zclFindAttrRec_2:
        CMP.B   0xc(R12), R14
        JC      ??zclFindAttrRec_1
// 2320     {
// 2321       if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
        MOV.W   0xe(R12), R15
        MOV.B   R14, R13
        RLAM.W  #0x3, R13
        ADD.W   R13, R15
        CMP.W   R10, 0(R15)
        JNE     ??zclFindAttrRec_0
        CMP.W   R11, 0x2(R15)
        JNE     ??zclFindAttrRec_0
// 2322       {
// 2323         *pAttr = pRec->attrs[x];
        MOV.W   @R15+, 0(R8)
        MOV.W   @R15+, 0x2(R8)
        MOV.W   @R15+, 0x4(R8)
        MOV.W   @R15+, 0x6(R8)
// 2324 
// 2325         return ( TRUE ); // EMBEDDED RETURN
        MOV.B   #0x1, R12
        JMP     ??zclFindAttrRec_3
// 2326       }
// 2327     }
// 2328   }
// 2329 
// 2330   return ( FALSE );
??zclFindAttrRec_1:
        MOV.B   #0x0, R12
??zclFindAttrRec_3:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock90
// 2331 }

        RSEG CODE:CODE:NOROOT(1)
zclGetAuthorizeCB:
          CFI Block cfiBlock91 Using cfiCommon0
          CFI Function zclGetAuthorizeCB
        FUNCALL zclGetAuthorizeCB, zclFindAttrRecsList
        LOCFRAME CSTACK, 4, STACK
        CALLA   #zclFindAttrRecsList
        CMP.W   #0x0, R12
        JEQ     ??zclGetAuthorizeCB_0
        MOV.W   R12, R13
        MOV.W   0x8(R13), R12
        MOV.W   0xa(R13), R13
        RETA
          CFI EndBlock cfiBlock91
??zclGetAuthorizeCB_0:
        REQUIRE ?Subroutine2
        // Fall through to label ?Subroutine2
// 2332 
// 2333 #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
// 2334 /*********************************************************************
// 2335  * @fn      zclGetReadWriteCB
// 2336  *
// 2337  * @brief   Get the Read/Write callback function pointer for a given endpoint.
// 2338  *
// 2339  * @param   endpoint - Application's endpoint
// 2340  *
// 2341  * @return  Read/Write CB, NULL if not found
// 2342  */

        RSEG CODE:CODE:NOROOT(1)
?Subroutine2:
          CFI Block cfiBlock92 Using cfiCommon0
          CFI NoFunction
        MOV.W   #0x0, R12
        MOV.W   #0x0, R13
        RETA
          CFI EndBlock cfiBlock92

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 2343 static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
zclGetReadWriteCB:
          CFI Block cfiBlock93 Using cfiCommon0
          CFI Function zclGetReadWriteCB
// 2344 {
// 2345   zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
        FUNCALL zclGetReadWriteCB, zclFindAttrRecsList
        LOCFRAME CSTACK, 4, STACK
        CALLA   #zclFindAttrRecsList
// 2346 
// 2347   if ( pRec != NULL )
        CMP.W   #0x0, R12
        JEQ     ??zclGetReadWriteCB_0
// 2348   {
// 2349     return ( pRec->pfnReadWriteCB );
        MOV.W   R12, R13
        MOV.W   0x4(R13), R12
        MOV.W   0x6(R13), R13
        RETA
// 2350   }
// 2351 
// 2352   return ( NULL );
??zclGetReadWriteCB_0:
        JMP     ?Subroutine2
        NOP
          CFI EndBlock cfiBlock93
// 2353 }
// 2354 
// 2355 /*********************************************************************
// 2356  * @fn      zclGetAuthorizeCB
// 2357  *
// 2358  * @brief   Get the Read/Write Authorization callback function pointer
// 2359  *          for a given endpoint.
// 2360  *
// 2361  * @param   endpoint - Application's endpoint
// 2362  *
// 2363  * @return  Authorization CB, NULL if not found
// 2364  */
// 2365 static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
// 2366 {
// 2367   zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
// 2368 
// 2369   if ( pRec != NULL )
// 2370   {
// 2371     return ( pRec->pfnAuthorizeCB );
// 2372   }
// 2373 
// 2374   return ( NULL );
// 2375 }
// 2376 #endif // ZCL_READ || ZCL_WRITE
// 2377 
// 2378 /*********************************************************************
// 2379  * @fn      zclFindClusterOption
// 2380  *
// 2381  * @brief   Find the option record that matchs the cluster id
// 2382  *
// 2383  * @param   endpoint - Application's endpoint
// 2384  * @param   clusterID - cluster ID looking for
// 2385  *
// 2386  * @return  pointer to clutser option, NULL if not found
// 2387  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 2388 static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
zclFindClusterOption:
          CFI Block cfiBlock94 Using cfiCommon0
          CFI Function zclFindClusterOption
// 2389 {
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
// 2390   zclClusterOptionList *pLoop;
// 2391 
// 2392   pLoop = clusterOptionList;
        MOV.W   &clusterOptionList, R10
        JMP     ??zclFindClusterOption_2
// 2393   while ( pLoop != NULL )
// 2394   {
// 2395     if ( pLoop->endpoint == endpoint )
// 2396     {
// 2397       uint8 x;
// 2398       for ( x = 0; x < pLoop->numOptions; x++ )
// 2399       {
// 2400         if ( pLoop->options[x].clusterID == clusterID )
// 2401         {
// 2402           return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
// 2403         }
// 2404       }
// 2405     }
// 2406 
// 2407     pLoop = pLoop->next;
??zclFindClusterOption_0:
        MOV.W   @R10, R10
??zclFindClusterOption_2:
        CMP.W   #0x0, R10
        JEQ     ??zclFindClusterOption_3
        CMP.B   R12, 0x2(R10)
        JNE     ??zclFindClusterOption_0
        MOV.B   #0x0, R14
        JMP     ??zclFindClusterOption_4
??zclFindClusterOption_1:
        ADD.B   #0x1, R14
??zclFindClusterOption_4:
        CMP.B   0x3(R10), R14
        JC      ??zclFindClusterOption_0
        MOV.W   0x4(R10), R15
        MOV.B   R14, R11
        RLAM.W  #0x2, R11
        ADD.W   R11, R15
        CMP.W   R13, 0(R15)
        JNE     ??zclFindClusterOption_1
        MOV.W   R15, R12
        JMP     ??zclFindClusterOption_5
// 2408   }
// 2409 
// 2410   return ( NULL );
??zclFindClusterOption_3:
        MOV.W   #0x0, R12
??zclFindClusterOption_5:
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock94
// 2411 }
// 2412 
// 2413 /*********************************************************************
// 2414  * @fn      zclGetClusterOption
// 2415  *
// 2416  * @brief   Get the option record that matchs the cluster id
// 2417  *
// 2418  * @param   endpoint - Application's endpoint
// 2419  * @param   clusterID - cluster ID looking for
// 2420  *
// 2421  * @return  clutser option, AF_TX_OPTIONS_NONE if not found
// 2422  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 2423 static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
zclGetClusterOption:
          CFI Block cfiBlock95 Using cfiCommon0
          CFI Function zclGetClusterOption
// 2424 {
// 2425   uint8 option;
// 2426   zclOptionRec_t *pOption;
// 2427 
// 2428   pOption = zclFindClusterOption( endpoint, clusterID );
        FUNCALL zclGetClusterOption, zclFindClusterOption
        LOCFRAME CSTACK, 4, STACK
        CALLA   #zclFindClusterOption
// 2429   if ( pOption != NULL )
        CMP.W   #0x0, R12
        JEQ     ??zclGetClusterOption_0
// 2430   {
// 2431     option = pOption->option;
// 2432     if ( !ZG_SECURE_ENABLED )
// 2433     {
// 2434       option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
// 2435     }
// 2436 
// 2437     return ( option ); // EMBEDDED RETURN
        MOV.B   0x2(R12), R12
        AND.B   #0xbf, R12
        RETA
// 2438   }
// 2439 
// 2440   return ( AF_TX_OPTIONS_NONE );
??zclGetClusterOption_0:
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock95
// 2441 }
// 2442 
// 2443 /*********************************************************************
// 2444  * @fn      zclSetSecurityOption
// 2445  *
// 2446  * @brief   Set the security option for the cluster id
// 2447  *
// 2448  * @param   endpoint - Application's endpoint
// 2449  * @param   clusterID - cluster ID looking for
// 2450  * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
// 2451  *
// 2452  * @return  none
// 2453  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 2454 static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
zclSetSecurityOption:
          CFI Block cfiBlock96 Using cfiCommon0
          CFI Function zclSetSecurityOption
// 2455 {
        FUNCALL zclSetSecurityOption, zclFindClusterOption
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.B   R14, R10
// 2456   zclOptionRec_t *pOption;
// 2457 
// 2458   pOption = zclFindClusterOption( endpoint, clusterID );
        CALLA   #zclFindClusterOption
// 2459   if ( pOption != NULL )
        CMP.W   #0x0, R12
        JEQ     ??zclSetSecurityOption_0
// 2460   {
// 2461     if ( enable )
        CMP.B   #0x0, R10
        JEQ     ??zclSetSecurityOption_1
// 2462     {
// 2463       pOption->option |= AF_EN_SECURITY;
        BIS.B   #0x40, 0x2(R12)
        JMP     ??zclSetSecurityOption_0
// 2464     }
// 2465     else
// 2466     {
// 2467       pOption->option &= (AF_EN_SECURITY ^ 0xFF);
??zclSetSecurityOption_1:
        BIC.B   #0x40, 0x2(R12)
// 2468     }
// 2469   }
// 2470 }
??zclSetSecurityOption_0:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock96
// 2471 
// 2472 #ifdef ZCL_DISCOVER
// 2473 /*********************************************************************
// 2474  * @fn      zclFindNextCmdRec
// 2475  *
// 2476  * @brief   Find the command (or next) record that matchs the parameters
// 2477  *
// 2478  * @param   endpoint - Application's endpoint
// 2479  * @param   clusterID - cluster ID
// 2480  * @param   commandID - command ID from requesting command
// 2481  * @param   direction- direction of received command
// 2482  * @param   pCmdID - command looking for
// 2483  * @param   pCmd - command information within command record list
// 2484  *
// 2485  * @return  pointer to command record, NULL no more records of this cluster
// 2486  */
// 2487 static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
// 2488                                 uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
// 2489 {
// 2490   zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
// 2491   uint8 i;
// 2492 
// 2493   if ( pRec != NULL )
// 2494   {
// 2495     for ( i = 0; i < pRec->numCommands; i++ )
// 2496     {
// 2497       if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
// 2498           ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
// 2499       {
// 2500         if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
// 2501         {
// 2502           if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
// 2503           {
// 2504             *pCmd = pRec->pCmdRecs[i];
// 2505 
// 2506             // Update command ID
// 2507             *pCmdID = pCmd->cmdID;
// 2508 
// 2509             return ( TRUE ); // EMBEDDED RETURN
// 2510           }
// 2511           else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
// 2512           {
// 2513             *pCmd = pRec->pCmdRecs[i];
// 2514 
// 2515             // Update command ID
// 2516             *pCmdID = pCmd->cmdID;
// 2517 
// 2518             return ( TRUE ); // EMBEDDED RETURN
// 2519           }
// 2520         }
// 2521         else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
// 2522         {
// 2523           if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
// 2524           {
// 2525             *pCmd = pRec->pCmdRecs[i];
// 2526 
// 2527             // Update command ID
// 2528             *pCmdID = pCmd->cmdID;
// 2529 
// 2530             return ( TRUE ); // EMBEDDED RETURN
// 2531           }
// 2532           else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
// 2533           {
// 2534             *pCmd = pRec->pCmdRecs[i];
// 2535 
// 2536             // Update command ID
// 2537             *pCmdID = pCmd->cmdID;
// 2538 
// 2539             return ( TRUE ); // EMBEDDED RETURN
// 2540           }
// 2541         }
// 2542         else
// 2543         {
// 2544           return ( FALSE ); // Incorrect Command ID
// 2545         }
// 2546       }
// 2547     }
// 2548   }
// 2549 
// 2550   return ( FALSE );
// 2551 }
// 2552 
// 2553 /*********************************************************************
// 2554  * @fn      zclFindNextAttrRec
// 2555  *
// 2556  * @brief   Find the attribute (or next) record that matchs the parameters
// 2557  *
// 2558  * @param   endpoint - Application's endpoint
// 2559  * @param   clusterID - cluster ID
// 2560  * @param   attr - attribute looking for
// 2561  *
// 2562  * @return  pointer to attribute record, NULL if not found
// 2563  */
// 2564 static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
// 2565                                  uint16 *attrId, zclAttrRec_t *pAttr )
// 2566 {
// 2567   zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
// 2568   uint8 attrDir;
// 2569 
// 2570   if ( pRec != NULL )
// 2571   {
// 2572     for ( uint16 x = 0; x < pRec->numAttributes; x++ )
// 2573     {
// 2574       if ( ( pRec->attrs[x].clusterID == clusterID ) &&
// 2575            ( pRec->attrs[x].attr.attrId >= *attrId ) )
// 2576       {
// 2577         // also make sure direction is right
// 2578         attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
// 2579         if ( attrDir == direction )
// 2580         {
// 2581           // return attribute and found attribute ID
// 2582           *pAttr = pRec->attrs[x];
// 2583           *attrId = pAttr->attr.attrId;
// 2584 
// 2585           return ( TRUE ); // EMBEDDED RETURN
// 2586         }
// 2587       }
// 2588     }
// 2589   }
// 2590 
// 2591   return ( FALSE );
// 2592 }
// 2593 #endif // ZCL_DISCOVER
// 2594 
// 2595 /*********************************************************************
// 2596  * @fn      zclSerializeData
// 2597  *
// 2598  * @brief   Builds a buffer from the attribute data to sent out over
// 2599  *          the air.
// 2600  *          NOTE - Not compatible with application's attributes callbacks.
// 2601  *
// 2602  * @param   dataType - data types defined in zcl.h
// 2603  * @param   attrData - pointer to the attribute data
// 2604  * @param   buf - where to put the serialized data
// 2605  *
// 2606  * @return  pointer to end of destination buffer
// 2607  */

        RSEG CODE:CODE:NOROOT(1)
// 2608 uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
zclSerializeData:
          CFI Block cfiBlock97 Using cfiCommon0
          CFI Function zclSerializeData
// 2609 {
        FUNCALL zclSerializeData, osal_buffer_uint32
        LOCFRAME CSTACK, 4, STACK
        FUNCALL zclSerializeData, osal_memcpy
        LOCFRAME CSTACK, 4, STACK
        FUNCALL zclSerializeData, osal_memcpy
        LOCFRAME CSTACK, 4, STACK
        FUNCALL zclSerializeData, osal_memcpy
        LOCFRAME CSTACK, 4, STACK
        FUNCALL zclSerializeData, osal_memcpy
        LOCFRAME CSTACK, 4, STACK
        FUNCALL zclSerializeData, osal_memcpy
        LOCFRAME CSTACK, 4, STACK
        FUNCALL zclSerializeData, osal_memcpy
        LOCFRAME CSTACK, 4, STACK
        MOV.B   R12, R15
        MOV.W   R14, R12
// 2610   uint8 *pStr;
// 2611   uint16 len;
// 2612 
// 2613   if ( attrData == NULL )
        CMP.W   #0x0, R13
        JEQ     ??zclSerializeData_0
// 2614   {
// 2615     return ( buf );
// 2616   }
// 2617 
// 2618   switch ( dataType )
        SUB.B   #0x8, R15
        JEQ     ??zclSerializeData_1
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_2
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_3
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_4
        SUB.B   #0x5, R15
        JEQ     ??zclSerializeData_1
        SUB.B   #0x8, R15
        JEQ     ??zclSerializeData_1
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_2
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_3
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_4
        SUB.B   #0x5, R15
        JEQ     ??zclSerializeData_1
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_2
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_3
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_4
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_5
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_6
        SUB.B   #0x3, R15
        JEQ     ??zclSerializeData_1
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_2
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_3
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_4
        SUB.B   #0x5, R15
        JEQ     ??zclSerializeData_1
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_2
        SUB.B   #0x7, R15
        JEQ     ??zclSerializeData_2
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_4
        SUB.B   #0x8, R15
        JEQ     ??zclSerializeData_7
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_7
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_8
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_8
        SUB.B   #0x9c, R15
        JEQ     ??zclSerializeData_4
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_4
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_4
        SUB.B   #0x6, R15
        JEQ     ??zclSerializeData_2
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_2
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_4
        SUB.B   #0x6, R15
        JEQ     ??zclSerializeData_9
        SUB.B   #0x1, R15
        JEQ     ??zclSerializeData_10
        RETA
// 2619   {
// 2620     case ZCL_DATATYPE_DATA8:
// 2621     case ZCL_DATATYPE_BOOLEAN:
// 2622     case ZCL_DATATYPE_BITMAP8:
// 2623     case ZCL_DATATYPE_INT8:
// 2624     case ZCL_DATATYPE_UINT8:
// 2625     case ZCL_DATATYPE_ENUM8:
// 2626       *buf++ = *((uint8 *)attrData);
??zclSerializeData_1:
        MOV.B   @R13, 0(R14)
        ADD.W   #0x1, R12
// 2627        break;
        RETA
// 2628 
// 2629     case ZCL_DATATYPE_DATA16:
// 2630     case ZCL_DATATYPE_BITMAP16:
// 2631     case ZCL_DATATYPE_UINT16:
// 2632     case ZCL_DATATYPE_INT16:
// 2633     case ZCL_DATATYPE_ENUM16:
// 2634     case ZCL_DATATYPE_SEMI_PREC:
// 2635     case ZCL_DATATYPE_CLUSTER_ID:
// 2636     case ZCL_DATATYPE_ATTR_ID:
// 2637       *buf++ = LO_UINT16( *((uint16*)attrData) );
??zclSerializeData_2:
        BRA     #?Subroutine21
// 2638       *buf++ = HI_UINT16( *((uint16*)attrData) );
// 2639       break;
// 2640 
// 2641     case ZCL_DATATYPE_DATA24:
// 2642     case ZCL_DATATYPE_BITMAP24:
// 2643     case ZCL_DATATYPE_UINT24:
// 2644     case ZCL_DATATYPE_INT24:
// 2645       *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
??zclSerializeData_3:
        CALLA   #?Subroutine21
// 2646       *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
// 2647       *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
??CrossCallReturnLabel_17:
        MOV.W   @R13+, R14
        MOV.W   @R13+, R15
        MOV.B   R15, 0(R12)
        ADD.W   #0x1, R12
// 2648       break;
        RETA
// 2649 
// 2650     case ZCL_DATATYPE_DATA32:
// 2651     case ZCL_DATATYPE_BITMAP32:
// 2652     case ZCL_DATATYPE_UINT32:
// 2653     case ZCL_DATATYPE_INT32:
// 2654     case ZCL_DATATYPE_SINGLE_PREC:
// 2655     case ZCL_DATATYPE_TOD:
// 2656     case ZCL_DATATYPE_DATE:
// 2657     case ZCL_DATATYPE_UTC:
// 2658     case ZCL_DATATYPE_BAC_OID:
// 2659       buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
??zclSerializeData_4:
        MOV.W   @R13+, R14
        MOV.W   @R13+, R15
        BRA     #osal_buffer_uint32
// 2660       break;
// 2661 
// 2662     case ZCL_DATATYPE_UINT40:
// 2663       pStr = (uint8*)attrData;
// 2664       buf = zcl_memcpy( buf, pStr, 5 );
??zclSerializeData_5:
        MOV.W   #0x5, R14
        BRA     #osal_memcpy
// 2665       break;
// 2666 
// 2667     case ZCL_DATATYPE_UINT48:
// 2668       pStr = (uint8*)attrData;
// 2669       buf = zcl_memcpy( buf, pStr, 6 );
??zclSerializeData_6:
        MOV.W   #0x6, R14
        BRA     #osal_memcpy
// 2670       break;
// 2671 
// 2672     case ZCL_DATATYPE_IEEE_ADDR:
// 2673       pStr = (uint8*)attrData;
// 2674       buf = zcl_memcpy( buf, pStr, 8 );
??zclSerializeData_9:
        MOV.W   #0x8, R14
        BRA     #osal_memcpy
// 2675       break;
// 2676 
// 2677     case ZCL_DATATYPE_CHAR_STR:
// 2678     case ZCL_DATATYPE_OCTET_STR:
// 2679       pStr = (uint8*)attrData;
// 2680       len = *pStr;
// 2681       buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
??zclSerializeData_7:
        MOV.B   @R13, R14
        ADD.W   #0x1, R14
        BRA     #osal_memcpy
// 2682       break;
// 2683 
// 2684     case ZCL_DATATYPE_LONG_CHAR_STR:
// 2685     case ZCL_DATATYPE_LONG_OCTET_STR:
// 2686       pStr = (uint8*)attrData;
// 2687       len = BUILD_UINT16( pStr[0], pStr[1] );
// 2688       buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
??zclSerializeData_8:
        MOV.B   @R13, R14
        MOV.B   0x1(R13), R15
        RPT     #0x8
        RLAX.W  R15
        ADD.W   R15, R14
        ADD.W   #0x2, R14
        BRA     #osal_memcpy
// 2689       break;
// 2690 
// 2691     case ZCL_DATATYPE_128_BIT_SEC_KEY:
// 2692       pStr = (uint8*)attrData;
// 2693       buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
??zclSerializeData_10:
        MOV.W   #0x10, R14
        CALLA   #osal_memcpy
// 2694       break;
// 2695 
// 2696     case ZCL_DATATYPE_NO_DATA:
// 2697     case ZCL_DATATYPE_UNKNOWN:
// 2698       // Fall through
// 2699 
// 2700     default:
// 2701       break;
// 2702   }
// 2703 
// 2704   return ( buf );
??zclSerializeData_0:
        RETA
          CFI EndBlock cfiBlock97
// 2705 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine21:
          CFI Block cfiCond98 Using cfiCommon0
          CFI Function zclSerializeData
          CFI Conditional ??CrossCallReturnLabel_17
          CFI CFA SP+8
          CFI Block cfiBlock99 Using cfiCommon0
          CFI (cfiBlock99) NoFunction
          CFI Block cfiPicker100 Using cfiCommon1
          CFI (cfiPicker100) NoFunction
          CFI (cfiPicker100) Picker
        MOV.B   @R13, 0(R14)
        ADD.W   #0x1, R12
        MOV.B   0x1(R13), 0(R12)
        ADD.W   #0x1, R12
        RETA
          CFI EndBlock cfiCond98
          CFI EndBlock cfiBlock99
          CFI EndBlock cfiPicker100
// 2706 
// 2707 #ifdef ZCL_REPORT
// 2708 /*********************************************************************
// 2709  * @fn      zclAnalogDataType
// 2710  *
// 2711  * @brief   Checks to see if Data Type is Analog
// 2712  *
// 2713  * @param   dataType - data type
// 2714  *
// 2715  * @return  TRUE if data type is analog
// 2716  */
// 2717 uint8 zclAnalogDataType( uint8 dataType )
// 2718 {
// 2719   uint8 analog;
// 2720 
// 2721   switch ( dataType )
// 2722   {
// 2723     case ZCL_DATATYPE_UINT8:
// 2724     case ZCL_DATATYPE_UINT16:
// 2725     case ZCL_DATATYPE_UINT24:
// 2726     case ZCL_DATATYPE_UINT32:
// 2727     case ZCL_DATATYPE_UINT40:
// 2728     case ZCL_DATATYPE_UINT48:
// 2729     case ZCL_DATATYPE_UINT56:
// 2730     case ZCL_DATATYPE_UINT64:
// 2731     case ZCL_DATATYPE_INT8:
// 2732     case ZCL_DATATYPE_INT16:
// 2733     case ZCL_DATATYPE_INT24:
// 2734     case ZCL_DATATYPE_INT32:
// 2735     case ZCL_DATATYPE_INT40:
// 2736     case ZCL_DATATYPE_INT48:
// 2737     case ZCL_DATATYPE_INT56:
// 2738     case ZCL_DATATYPE_INT64:
// 2739     case ZCL_DATATYPE_SEMI_PREC:
// 2740     case ZCL_DATATYPE_SINGLE_PREC:
// 2741     case ZCL_DATATYPE_DOUBLE_PREC:
// 2742     case ZCL_DATATYPE_TOD:
// 2743     case ZCL_DATATYPE_DATE:
// 2744     case ZCL_DATATYPE_UTC:
// 2745       analog = TRUE;
// 2746       break;
// 2747 
// 2748     default:
// 2749       analog = FALSE;
// 2750       break;
// 2751   }
// 2752 
// 2753   return ( analog );
// 2754 }
// 2755 
// 2756 /*********************************************************************
// 2757  * @fn      zclIsLittleEndianMachine
// 2758  *
// 2759  * @brief   Verifies endianness in system.
// 2760  *
// 2761  * @param   none
// 2762  *
// 2763  * @return  MSB-00 or LSB-01 depending on endianness in the system
// 2764  */
// 2765 static int zclIsLittleEndianMachine(void)
// 2766 {
// 2767   uint16 test = 0x0001;
// 2768 
// 2769   return (*((uint8 *)(&test)));
// 2770 }
// 2771 
// 2772 /*********************************************************************
// 2773  * @fn      zcl_BuildAnalogData
// 2774  *
// 2775  * @brief   Build an analog arribute out of sequential bytes.
// 2776  *
// 2777  * @param   dataType - type of data
// 2778  * @param   pData - pointer to data
// 2779  * @param   pBuf - where to put the data
// 2780  *
// 2781  * @return  none
// 2782  */
// 2783 static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
// 2784 {
// 2785   int current_byte_index;
// 2786   int remaining_bytes;
// 2787   int step;
// 2788 
// 2789   remaining_bytes = zclGetAttrDataLength(dataType, pData);
// 2790 
// 2791   // decide if move forward or backwards to copy data
// 2792   if ( zclIsLittleEndianMachine() )
// 2793   {
// 2794     step = 1;
// 2795     current_byte_index = 0;
// 2796   }
// 2797   else
// 2798   {
// 2799     step = -1;
// 2800     current_byte_index = remaining_bytes - 1;
// 2801   }
// 2802 
// 2803   while ( remaining_bytes-- )
// 2804   {
// 2805     pData[current_byte_index] = *(pBuf++);
// 2806     current_byte_index += step;
// 2807   }
// 2808 }
// 2809 #endif // ZCL_REPORT
// 2810 
// 2811 /*********************************************************************
// 2812  * @fn      zclGetDataTypeLength
// 2813  *
// 2814  * @brief   Return the length of the datatype in octet.
// 2815  *
// 2816  *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
// 2817  *                ZCL_DATATYPE_CHAR_STR data types.
// 2818  *
// 2819  * @param   dataType - data type
// 2820  *
// 2821  * @return  length of data
// 2822  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 2823 uint8 zclGetDataTypeLength( uint8 dataType )
zclGetDataTypeLength:
          CFI Block cfiBlock101 Using cfiCommon0
          CFI Function zclGetDataTypeLength
// 2824 {
// 2825   uint8 len;
// 2826 
// 2827   switch ( dataType )
        SUB.B   #0x8, R12
        JEQ     ??zclGetDataTypeLength_0
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_1
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_2
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_3
        SUB.B   #0x5, R12
        JEQ     ??zclGetDataTypeLength_0
        SUB.B   #0x8, R12
        JEQ     ??zclGetDataTypeLength_0
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_1
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_2
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_3
        SUB.B   #0x5, R12
        JEQ     ??zclGetDataTypeLength_0
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_1
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_2
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_3
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_4
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_5
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_6
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_7
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_0
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_1
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_2
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_3
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_4
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_5
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_6
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_7
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_0
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_1
        SUB.B   #0x7, R12
        JEQ     ??zclGetDataTypeLength_1
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_3
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_7
        SUB.B   #0xa6, R12
        JEQ     ??zclGetDataTypeLength_3
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_3
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_3
        SUB.B   #0x6, R12
        JEQ     ??zclGetDataTypeLength_1
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_1
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_3
        SUB.B   #0x6, R12
        JEQ     ??zclGetDataTypeLength_7
        SUB.B   #0x1, R12
        JEQ     ??zclGetDataTypeLength_8
        JMP     ??zclGetDataTypeLength_9
// 2828   {
// 2829     case ZCL_DATATYPE_DATA8:
// 2830     case ZCL_DATATYPE_BOOLEAN:
// 2831     case ZCL_DATATYPE_BITMAP8:
// 2832     case ZCL_DATATYPE_INT8:
// 2833     case ZCL_DATATYPE_UINT8:
// 2834     case ZCL_DATATYPE_ENUM8:
// 2835       len = 1;
??zclGetDataTypeLength_0:
        MOV.B   #0x1, R12
// 2836       break;
        RETA
// 2837 
// 2838     case ZCL_DATATYPE_DATA16:
// 2839     case ZCL_DATATYPE_BITMAP16:
// 2840     case ZCL_DATATYPE_UINT16:
// 2841     case ZCL_DATATYPE_INT16:
// 2842     case ZCL_DATATYPE_ENUM16:
// 2843     case ZCL_DATATYPE_SEMI_PREC:
// 2844     case ZCL_DATATYPE_CLUSTER_ID:
// 2845     case ZCL_DATATYPE_ATTR_ID:
// 2846       len = 2;
??zclGetDataTypeLength_1:
        MOV.B   #0x2, R12
// 2847       break;
        RETA
// 2848 
// 2849     case ZCL_DATATYPE_DATA24:
// 2850     case ZCL_DATATYPE_BITMAP24:
// 2851     case ZCL_DATATYPE_UINT24:
// 2852     case ZCL_DATATYPE_INT24:
// 2853       len = 3;
??zclGetDataTypeLength_2:
        MOV.B   #0x3, R12
// 2854       break;
        RETA
// 2855 
// 2856     case ZCL_DATATYPE_DATA32:
// 2857     case ZCL_DATATYPE_BITMAP32:
// 2858     case ZCL_DATATYPE_UINT32:
// 2859     case ZCL_DATATYPE_INT32:
// 2860     case ZCL_DATATYPE_SINGLE_PREC:
// 2861     case ZCL_DATATYPE_TOD:
// 2862     case ZCL_DATATYPE_DATE:
// 2863     case ZCL_DATATYPE_UTC:
// 2864     case ZCL_DATATYPE_BAC_OID:
// 2865       len = 4;
??zclGetDataTypeLength_3:
        MOV.B   #0x4, R12
// 2866       break;
        RETA
// 2867 
// 2868    case ZCL_DATATYPE_UINT40:
// 2869    case ZCL_DATATYPE_INT40:
// 2870        len = 5;
??zclGetDataTypeLength_4:
        MOV.B   #0x5, R12
// 2871        break;
        RETA
// 2872 
// 2873    case ZCL_DATATYPE_UINT48:
// 2874    case ZCL_DATATYPE_INT48:
// 2875        len = 6;
??zclGetDataTypeLength_5:
        MOV.B   #0x6, R12
// 2876        break;
        RETA
// 2877 
// 2878    case ZCL_DATATYPE_UINT56:
// 2879    case ZCL_DATATYPE_INT56:
// 2880        len = 7;
??zclGetDataTypeLength_6:
        MOV.B   #0x7, R12
// 2881        break;
        RETA
// 2882 
// 2883    case ZCL_DATATYPE_DOUBLE_PREC:
// 2884    case ZCL_DATATYPE_IEEE_ADDR:
// 2885    case ZCL_DATATYPE_UINT64:
// 2886    case ZCL_DATATYPE_INT64:
// 2887      len = 8;
??zclGetDataTypeLength_7:
        MOV.B   #0x8, R12
// 2888      break;
        RETA
// 2889 
// 2890     case ZCL_DATATYPE_128_BIT_SEC_KEY:
// 2891      len = SEC_KEY_LEN;
??zclGetDataTypeLength_8:
        MOV.B   #0x10, R12
// 2892      break;
        RETA
// 2893 
// 2894     case ZCL_DATATYPE_NO_DATA:
// 2895     case ZCL_DATATYPE_UNKNOWN:
// 2896       // Fall through
// 2897 
// 2898     default:
// 2899       len = 0;
??zclGetDataTypeLength_9:
        MOV.B   #0x0, R12
// 2900       break;
// 2901   }
// 2902 
// 2903   return ( len );
        RETA
          CFI EndBlock cfiBlock101
// 2904 }
// 2905 
// 2906 /*********************************************************************
// 2907  * @fn      zclGetAttrDataLength
// 2908  *
// 2909  * @brief   Return the length of the attribute.
// 2910  *
// 2911  * @param   dataType - data type
// 2912  * @param   pData - pointer to data
// 2913  *
// 2914  * @return  returns atrribute length
// 2915  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 2916 uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
zclGetAttrDataLength:
          CFI Block cfiBlock102 Using cfiCommon0
          CFI Function zclGetAttrDataLength
// 2917 {
// 2918   uint16 dataLen = 0;
// 2919 
// 2920   if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
        FUNCALL zclGetAttrDataLength, zclGetDataTypeLength
        LOCFRAME CSTACK, 4, STACK
        CMP.B   #0x44, R12
        JEQ     ??zclGetAttrDataLength_0
        CMP.B   #0x43, R12
        JNE     ??zclGetAttrDataLength_1
// 2921   {
// 2922     dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
??zclGetAttrDataLength_0:
        MOV.B   @R13, R12
        MOV.B   0x1(R13), R15
        RPT     #0x8
        RLAX.W  R15
        ADD.W   R15, R12
        ADD.W   #0x2, R12
        RETA
// 2923   }
// 2924   else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
??zclGetAttrDataLength_1:
        CMP.B   #0x42, R12
        JEQ     ??zclGetAttrDataLength_2
        CMP.B   #0x41, R12
        JNE     ??zclGetAttrDataLength_3
// 2925   {
// 2926     dataLen = *pData + 1; // string length + 1 for length field
??zclGetAttrDataLength_2:
        MOV.B   @R13, R12
        ADD.W   #0x1, R12
        RETA
// 2927   }
// 2928   else
// 2929   {
// 2930     dataLen = zclGetDataTypeLength( dataType );
??zclGetAttrDataLength_3:
        CALLA   #zclGetDataTypeLength
        MOV.B   R12, R12
// 2931   }
// 2932 
// 2933   return ( dataLen );
        RETA
          CFI EndBlock cfiBlock102
// 2934 }
// 2935 
// 2936 #ifdef ZCL_READ
// 2937 /*********************************************************************
// 2938  * @fn      zclReadAttrData
// 2939  *
// 2940  * @brief   Read the attribute's current value into pAttrData.
// 2941  *          NOTE - Not compatible with application's attributes callbacks.
// 2942  *
// 2943  * @param   pAttrData - where to put attribute data
// 2944  * @param   pAttr - pointer to attribute
// 2945  * @param   pDataLen - where to put attribute data length
// 2946  *
// 2947  * @return Success
// 2948  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 2949 ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
zclReadAttrData:
          CFI Block cfiBlock103 Using cfiCommon0
          CFI Function zclReadAttrData
// 2950 {
        FUNCALL zclReadAttrData, zclGetAttrDataLength
        LOCFRAME CSTACK, 12, STACK
        FUNCALL zclReadAttrData, osal_memcpy
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R12, R10
        MOV.W   R13, R11
        MOV.W   R14, R8
// 2951   uint16 dataLen;
// 2952 
// 2953   if ( pAttr->attr.dataPtr == NULL )
        MOV.W   0x6(R11), R13
        CMP.W   #0x0, R13
        JNE     ??zclReadAttrData_0
// 2954   {
// 2955     return ( ZCL_STATUS_FAILURE );
        MOV.B   #0x1, R12
        JMP     ??zclReadAttrData_1
// 2956   }
// 2957 
// 2958   dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
??zclReadAttrData_0:
        MOV.B   0x4(R11), R12
        CALLA   #zclGetAttrDataLength
        MOV.W   R12, R9
// 2959   zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
        MOV.W   R12, R14
        MOV.W   0x6(R11), R13
        MOV.W   R10, R12
        CALLA   #osal_memcpy
// 2960 
// 2961   if ( pDataLen != NULL )
        CMP.W   #0x0, R8
        JEQ     ??zclReadAttrData_2
// 2962   {
// 2963     *pDataLen = dataLen;
        MOV.W   R9, 0(R8)
// 2964   }
// 2965 
// 2966   return ( ZCL_STATUS_SUCCESS );
??zclReadAttrData_2:
        MOV.B   #0x0, R12
??zclReadAttrData_1:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock103
// 2967 }
// 2968 
// 2969 /*********************************************************************
// 2970  * @fn      zcl_ReadAttrData
// 2971  *
// 2972  * @brief   Read the attribute's current value into pAttrData.
// 2973  *          Use application's callback function if assigned to this attribute.
// 2974  *
// 2975  * @param   endpoint - application's endpoint
// 2976  * @param   clusterId - cluster that attribute belongs to
// 2977  * @param   attrId - attribute id
// 2978  * @param   pAttrData - where to put attribute data
// 2979  * @param   pDataLen - where to put attribute data length
// 2980  *
// 2981  * @return  Successful if data was read
// 2982  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 2983 ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId,
zcl_ReadAttrData:
          CFI Block cfiBlock104 Using cfiCommon0
          CFI Function zcl_ReadAttrData
// 2984                                          uint8 *pAttrData, uint16 *pDataLen )
// 2985 {
        FUNCALL zcl_ReadAttrData, zclFindAttrRec
        LOCFRAME CSTACK, 20, STACK
        FUNCALL zcl_ReadAttrData, zclReadAttrData
        LOCFRAME CSTACK, 20, STACK
        FUNCALL zcl_ReadAttrData, zclReadAttrDataUsingCB
        LOCFRAME CSTACK, 22, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x8, SP
          CFI CFA SP+20
        MOV.B   R12, R10
        MOV.W   R13, R11
        MOV.W   R14, R8
        MOV.W   R15, R9
// 2986   zclAttrRec_t attrRec;
// 2987 
// 2988   if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE )
        MOV.W   SP, R15
        ADD.W   #0x0, R15
        CALLA   #??Subroutine9_0
??CrossCallReturnLabel_43:
        JNE     ??zcl_ReadAttrData_0
// 2989   {
// 2990     return ( ZCL_STATUS_FAILURE );
        MOV.B   #0x1, R12
        JMP     ??zcl_ReadAttrData_1
// 2991   }
??zcl_ReadAttrData_0:
        MOV.W   0x14(SP), R14
// 2992 
// 2993   if ( attrRec.attr.dataPtr != NULL )
        CMP.W   #0x0, 0x6(SP)
        JEQ     ??zcl_ReadAttrData_2
// 2994   {
// 2995     return zclReadAttrData( pAttrData, &attrRec, pDataLen );
        MOV.W   SP, R13
        ADD.W   #0x0, R13
        MOV.W   R9, R12
        CALLA   #zclReadAttrData
        JMP     ??zcl_ReadAttrData_1
// 2996   }
// 2997   else
// 2998   {
// 2999     return zclReadAttrDataUsingCB( endpoint, clusterId, attrId, pAttrData, pDataLen );
??zcl_ReadAttrData_2:
        PUSH.W  R14
          CFI CFA SP+22
        MOV.W   R9, R15
        MOV.W   R8, R14
        MOV.W   R11, R13
        MOV.B   R10, R12
        CALLA   #zclReadAttrDataUsingCB
        ADD.W   #0x2, SP
          CFI CFA SP+20
??zcl_ReadAttrData_1:
        ADD.W   #0x8, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock104
// 3000   }
// 3001 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine18:
          CFI Block cfiCond105 Using cfiCommon0
          CFI Function zclProcessInReadCmd
          CFI Conditional ??CrossCallReturnLabel_26
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+32
          CFI Block cfiCond106 Using cfiCommon0
          CFI (cfiCond106) Function zclAuthorizeWrite
          CFI (cfiCond106) Conditional ??CrossCallReturnLabel_27
          CFI (cfiCond106) R8L Frame(CFA, -12)
          CFI (cfiCond106) R9L Frame(CFA, -10)
          CFI (cfiCond106) R10L Frame(CFA, -8)
          CFI (cfiCond106) R11L Frame(CFA, -6)
          CFI (cfiCond106) CFA SP+16
          CFI Block cfiPicker107 Using cfiCommon1
          CFI (cfiPicker107) NoFunction
          CFI (cfiPicker107) Picker
        CALLA   #zclGetAuthorizeCB
          CFI EndBlock cfiCond105
          CFI EndBlock cfiCond106
          CFI EndBlock cfiPicker107
        REQUIRE ??Subroutine18_0
        // Fall through to label ??Subroutine18_0
// 3002 
// 3003 /*********************************************************************
// 3004  * @fn      zclGetAttrDataLengthUsingCB
// 3005  *
// 3006  * @brief   Use application's callback to get the length of the attribute's
// 3007  *          current value stored in the database.
// 3008  *
// 3009  * @param   endpoint - application's endpoint
// 3010  * @param   clusterId - cluster that attribute belongs to
// 3011  * @param   attrId - attribute id
// 3012  *
// 3013  * @return  returns attribute length
// 3014  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
??Subroutine18_0:
          CFI Block cfiCond108 Using cfiCommon0
          CFI Function zclWriteAttrDataUsingCB
          CFI Conditional ??CrossCallReturnLabel_28
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
          CFI Block cfiCond109 Using cfiCommon0
          CFI (cfiCond109) Function zclGetAttrDataLengthUsingCB
          CFI (cfiCond109) Conditional ??CrossCallReturnLabel_29
          CFI (cfiCond109) R8L Frame(CFA, -12)
          CFI (cfiCond109) R9L Frame(CFA, -10)
          CFI (cfiCond109) R10L Frame(CFA, -8)
          CFI (cfiCond109) R11L Frame(CFA, -6)
          CFI (cfiCond109) CFA SP+18
          CFI Block cfiCond110 Using cfiCommon0
          CFI (cfiCond110) Function zclProcessInReadCmd
          CFI (cfiCond110) Conditional ??CrossCallReturnLabel_26
          CFI (cfiCond110) R4L Frame(CFA, -20)
          CFI (cfiCond110) R5L Frame(CFA, -18)
          CFI (cfiCond110) R6L Frame(CFA, -16)
          CFI (cfiCond110) R7L Frame(CFA, -14)
          CFI (cfiCond110) R8L Frame(CFA, -12)
          CFI (cfiCond110) R9L Frame(CFA, -10)
          CFI (cfiCond110) R10L Frame(CFA, -8)
          CFI (cfiCond110) R11L Frame(CFA, -6)
          CFI (cfiCond110) CFA SP+32
          CFI Block cfiCond111 Using cfiCommon0
          CFI (cfiCond111) Function zclAuthorizeWrite
          CFI (cfiCond111) Conditional ??CrossCallReturnLabel_27
          CFI (cfiCond111) R8L Frame(CFA, -12)
          CFI (cfiCond111) R9L Frame(CFA, -10)
          CFI (cfiCond111) R10L Frame(CFA, -8)
          CFI (cfiCond111) R11L Frame(CFA, -6)
          CFI (cfiCond111) CFA SP+16
          CFI Block cfiPicker112 Using cfiCommon1
          CFI (cfiPicker112) NoFunction
          CFI (cfiPicker112) Picker
        MOV.W   R12, R10
        MOV.W   R13, R11
        MOV.W   R12, R15
        BIS.W   R13, R15
        CMP.W   #0x0, R15
        RETA
          CFI EndBlock cfiCond108
          CFI EndBlock cfiCond109
          CFI EndBlock cfiCond110
          CFI EndBlock cfiCond111
          CFI EndBlock cfiPicker112

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 3015 static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
zclGetAttrDataLengthUsingCB:
          CFI Block cfiBlock113 Using cfiCommon0
          CFI Function zclGetAttrDataLengthUsingCB
// 3016 {
        FUNCALL zclGetAttrDataLengthUsingCB, zclGetReadWriteCB
        LOCFRAME CSTACK, 14, STACK
        FUNCALL zclGetAttrDataLengthUsingCB
        LOCFRAME CSTACK, 16, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x2, SP
          CFI CFA SP+14
        MOV.W   R13, R8
        MOV.W   R14, R9
// 3017   uint16 dataLen = 0;
        MOV.W   #0x0, 0(SP)
// 3018   zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
        CALLA   #zclGetReadWriteCB
        CALLA   #??Subroutine18_0
// 3019 
// 3020   if ( pfnReadWriteCB != NULL )
??CrossCallReturnLabel_29:
        JEQ     ??zclGetAttrDataLengthUsingCB_0
// 3021   {
// 3022     // Only get the attribute length
// 3023     (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
        MOV.W   SP, R15
        ADD.W   #0x0, R15
        PUSH.W  R15
          CFI CFA SP+16
        MOV.W   #0x0, R15
        MOV.B   #0x0, R14
        MOV.W   R9, R13
        MOV.W   R8, R12
        CALLA   #?IndCallR11
        ADD.W   #0x2, SP
          CFI CFA SP+14
// 3024   }
// 3025 
// 3026   return ( dataLen );
??zclGetAttrDataLengthUsingCB_0:
        MOV.W   @SP, R12
        ADD.W   #0x2, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock113
// 3027 }
// 3028 
// 3029 /*********************************************************************
// 3030  * @fn      zclReadAttrDataUsingCB
// 3031  *
// 3032  * @brief   Use application's callback to read the attribute's current
// 3033  *          value stored in the database.
// 3034  *
// 3035  * @param   endpoint - application's endpoint
// 3036  * @param   clusterId - cluster that attribute belongs to
// 3037  * @param   attrId - attribute id
// 3038  * @param   pAttrData - where to put attribute data
// 3039  * @param   pDataLen - where to put attribute data length
// 3040  *
// 3041  * @return  Successful if data was read
// 3042  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 3043 static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
zclReadAttrDataUsingCB:
          CFI Block cfiBlock114 Using cfiCommon0
          CFI Function zclReadAttrDataUsingCB
// 3044                                          uint8 *pAttrData, uint16 *pDataLen )
// 3045 {
        FUNCALL zclReadAttrDataUsingCB, zclGetReadWriteCB
        LOCFRAME CSTACK, 16, STACK
        FUNCALL zclReadAttrDataUsingCB
        LOCFRAME CSTACK, 18, STACK
        PUSHM.W #0x6, R11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
        MOV.W   R13, R8
        MOV.W   R14, R9
        MOV.W   R15, R6
// 3046   zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
        CALLA   #zclGetReadWriteCB
        MOV.W   R12, R10
        MOV.W   R13, R11
        MOV.W   0x10(SP), R15
// 3047 
// 3048   if ( pDataLen != NULL )
        CMP.W   #0x0, R15
        JEQ     ??zclReadAttrDataUsingCB_0
// 3049   {
// 3050     *pDataLen = 0; // Always initialize it to 0
        MOV.W   #0x0, 0(R15)
// 3051   }
// 3052 
// 3053   if ( pfnReadWriteCB != NULL )
??zclReadAttrDataUsingCB_0:
        MOV.W   R12, R14
        BIS.W   R13, R14
        CMP.W   #0x0, R14
        JEQ     ??zclReadAttrDataUsingCB_1
// 3054   {
// 3055     // Read the attribute value and its length
// 3056     return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
        PUSH.W  R15
          CFI CFA SP+18
        MOV.W   R6, R15
        MOV.B   #0x1, R14
        MOV.W   R9, R13
        MOV.W   R8, R12
        CALLA   #?IndCallR11
        ADD.W   #0x2, SP
          CFI CFA SP+16
        JMP     ??zclReadAttrDataUsingCB_2
// 3057   }
// 3058 
// 3059   return ( ZCL_STATUS_SOFTWARE_FAILURE );
??zclReadAttrDataUsingCB_1:
        MOV.B   #0xc1, R12
??zclReadAttrDataUsingCB_2:
        POPM.W  #0x6, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock114
// 3060 }
// 3061 
// 3062 /*********************************************************************
// 3063  * @fn      zclAuthorizeRead
// 3064  *
// 3065  * @brief   Use application's callback to authorize a Read operation
// 3066  *          on a given attribute.
// 3067  *
// 3068  * @param   endpoint - application's endpoint
// 3069  * @param   srcAddr - source Address
// 3070  * @param   pAttr - pointer to attribute
// 3071  *
// 3072  * @return  ZCL_STATUS_SUCCESS: Operation authorized
// 3073  *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
// 3074  */
// 3075 static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
// 3076 {
// 3077   if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
// 3078   {
// 3079     zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
// 3080 
// 3081     if ( pfnAuthorizeCB != NULL )
// 3082     {
// 3083       return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
// 3084     }
// 3085   }
// 3086 
// 3087   return ( ZCL_STATUS_SUCCESS );
// 3088 }
// 3089 #endif // ZCL_READ
// 3090 
// 3091 #ifdef ZCL_WRITE
// 3092 /*********************************************************************
// 3093  * @fn      zclWriteAttrData
// 3094  *
// 3095  * @brief   Write the received data.
// 3096  *
// 3097  * @param   endpoint - application's endpoint
// 3098  * @param   pAttr - where to write data to
// 3099  * @param   pWriteRec - data to be written
// 3100  *
// 3101  * @return  Successful if data was written
// 3102  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 3103 static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
zclWriteAttrData:
          CFI Block cfiBlock115 Using cfiCommon0
          CFI Function zclWriteAttrData
// 3104                                    zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
// 3105 {
        FUNCALL zclWriteAttrData, zclAuthorizeWrite
        LOCFRAME CSTACK, 12, STACK
        FUNCALL zclWriteAttrData
        LOCFRAME CSTACK, 12, STACK
        FUNCALL zclWriteAttrData, zclGetAttrDataLength
        LOCFRAME CSTACK, 12, STACK
        FUNCALL zclWriteAttrData, osal_memcpy
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R14, R10
        MOV.W   R15, R11
// 3106   uint8 status;
// 3107 
// 3108   if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
        BIT.B   #0x2, 0x5(R14)
        JNC     ??zclWriteAttrData_0
// 3109   {
// 3110     status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
        CALLA   #zclAuthorizeWrite
        MOV.B   R12, R8
// 3111     if ( status == ZCL_STATUS_SUCCESS )
        CMP.B   #0x0, R12
        JNE     ??zclWriteAttrData_1
// 3112     {
// 3113       if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
        MOV.W   &zcl_ValidateAttrDataCB, R15
        BIS.W   &zcl_ValidateAttrDataCB + 2, R15
        CMP.W   #0x0, R15
        JEQ     ??zclWriteAttrData_2
        MOV.W   R11, R13
        MOV.W   R10, R12
        CALLA   &zcl_ValidateAttrDataCB
        CMP.B   #0x0, R12
        JEQ     ??zclWriteAttrData_3
// 3114       {
// 3115         // Write the attribute value
// 3116         uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
??zclWriteAttrData_2:
        MOV.W   0x4(R11), R13
        MOV.B   0x4(R10), R12
        CALLA   #zclGetAttrDataLength
        MOV.W   R12, R14
// 3117         zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
        MOV.W   0x4(R11), R13
        MOV.W   0x6(R10), R12
        CALLA   #osal_memcpy
// 3118 
// 3119         status = ZCL_STATUS_SUCCESS;
        JMP     ??zclWriteAttrData_1
// 3120       }
// 3121       else
// 3122       {
// 3123         status = ZCL_STATUS_INVALID_VALUE;
??zclWriteAttrData_3:
        MOV.B   #0x87, R8
        JMP     ??zclWriteAttrData_1
// 3124       }
// 3125     }
// 3126   }
// 3127   else
// 3128   {
// 3129     status = ZCL_STATUS_READ_ONLY;
??zclWriteAttrData_0:
        MOV.B   #0x88, R8
// 3130   }
// 3131 
// 3132   return ( status );
??zclWriteAttrData_1:
        MOV.B   R8, R12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock115
// 3133 }
// 3134 
// 3135 /*********************************************************************
// 3136  * @fn      zclWriteAttrDataUsingCB
// 3137  *
// 3138  * @brief   Use application's callback to write the attribute's current
// 3139  *          value stored in the database.
// 3140  *
// 3141  * @param   endpoint - application's endpoint
// 3142  * @param   pAttr - where to write data to
// 3143  * @param   pAttrData - data to be written
// 3144  *
// 3145  * @return  Successful if data was written
// 3146  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 3147 static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
zclWriteAttrDataUsingCB:
          CFI Block cfiBlock116 Using cfiCommon0
          CFI Function zclWriteAttrDataUsingCB
// 3148                                           zclAttrRec_t *pAttr, uint8 *pAttrData )
// 3149 {
        FUNCALL zclWriteAttrDataUsingCB, zclAuthorizeWrite
        LOCFRAME CSTACK, 12, STACK
        FUNCALL zclWriteAttrDataUsingCB, zclGetReadWriteCB
        LOCFRAME CSTACK, 12, STACK
        FUNCALL zclWriteAttrDataUsingCB
        LOCFRAME CSTACK, 14, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.B   R12, R10
        MOV.W   R14, R8
        MOV.W   R15, R9
// 3150   uint8 status;
// 3151 
// 3152   if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
        BIT.B   #0x2, 0x5(R14)
        JNC     ??zclWriteAttrDataUsingCB_0
// 3153   {
// 3154     status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
        CALLA   #zclAuthorizeWrite
// 3155     if ( status == ZCL_STATUS_SUCCESS )
        CMP.B   #0x0, R12
        JNE     ??zclWriteAttrDataUsingCB_1
// 3156     {
// 3157       zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
        MOV.B   R10, R12
        CALLA   #zclGetReadWriteCB
        CALLA   #??Subroutine18_0
// 3158       if ( pfnReadWriteCB != NULL )
??CrossCallReturnLabel_28:
        JEQ     ??zclWriteAttrDataUsingCB_2
// 3159       {
// 3160         // Write the attribute value
// 3161         status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
// 3162                                     ZCL_OPER_WRITE, pAttrData, NULL );
        PUSH.W  #0x0
          CFI CFA SP+14
        MOV.W   R9, R15
        MOV.B   #0x2, R14
        MOV.W   0x2(R8), R13
        MOV.W   @R8, R12
        CALLA   #?IndCallR11
        ADD.W   #0x2, SP
          CFI CFA SP+12
        JMP     ??zclWriteAttrDataUsingCB_1
// 3163       }
// 3164       else
// 3165       {
// 3166         status = ZCL_STATUS_SOFTWARE_FAILURE;
??zclWriteAttrDataUsingCB_2:
        MOV.B   #0xc1, R12
        JMP     ??zclWriteAttrDataUsingCB_1
// 3167       }
// 3168     }
// 3169   }
// 3170   else
// 3171   {
// 3172     status = ZCL_STATUS_READ_ONLY;
??zclWriteAttrDataUsingCB_0:
        MOV.B   #0x88, R12
// 3173   }
// 3174 
// 3175   return ( status );
??zclWriteAttrDataUsingCB_1:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock116
// 3176 }
// 3177 
// 3178 /*********************************************************************
// 3179  * @fn      zclAuthorizeWrite
// 3180  *
// 3181  * @brief   Use application's callback to authorize a Write operation
// 3182  *          on a given attribute.
// 3183  *
// 3184  * @param   endpoint - application's endpoint
// 3185  * @param   srcAddr - source Address
// 3186  * @param   pAttr - pointer to attribute
// 3187  *
// 3188  * @return  ZCL_STATUS_SUCCESS: Operation authorized
// 3189  *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
// 3190  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 3191 static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
zclAuthorizeWrite:
          CFI Block cfiBlock117 Using cfiCommon0
          CFI Function zclAuthorizeWrite
// 3192 {
        FUNCALL zclAuthorizeWrite, zclGetAuthorizeCB
        LOCFRAME CSTACK, 12, STACK
        FUNCALL zclAuthorizeWrite
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R13, R8
        MOV.W   R14, R9
// 3193   if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
        BIT.B   #0x20, 0x5(R14)
        JNC     ??zclAuthorizeWrite_0
// 3194   {
// 3195     zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
        CALLA   #?Subroutine18
// 3196 
// 3197     if ( pfnAuthorizeCB != NULL )
??CrossCallReturnLabel_27:
        JEQ     ??zclAuthorizeWrite_0
// 3198     {
// 3199       return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
        MOV.B   #0x2, R14
        MOV.W   R9, R13
        MOV.W   R8, R12
        CALLA   #?IndCallR11
        JMP     ??zclAuthorizeWrite_1
// 3200     }
// 3201   }
// 3202 
// 3203   return ( ZCL_STATUS_SUCCESS );
??zclAuthorizeWrite_0:
        MOV.B   #0x0, R12
??zclAuthorizeWrite_1:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock117
// 3204 }
// 3205 #endif // ZCL_WRITE
// 3206 
// 3207 #ifdef ZCL_READ
// 3208 /*********************************************************************
// 3209  * @fn      zclParseInReadCmd
// 3210  *
// 3211  * @brief   Parse the "Profile" Read Commands
// 3212  *
// 3213  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3214  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3215  *
// 3216  * @param   pCmd - pointer to incoming data to parse
// 3217  *
// 3218  * @return  pointer to the parsed command structure
// 3219  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 3220 void *zclParseInReadCmd( zclParseCmd_t *pCmd )
zclParseInReadCmd:
          CFI Block cfiBlock118 Using cfiCommon0
          CFI Function zclParseInReadCmd
// 3221 {
        FUNCALL zclParseInReadCmd, osal_mem_alloc
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.W   R12, R11
// 3222   zclReadCmd_t *readCmd;
// 3223   uint8 *pBuf = pCmd->pData;
        MOV.W   0x4(R12), R10
// 3224 
// 3225   readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
        CALLA   #?Subroutine5
// 3226   if ( readCmd != NULL )
??CrossCallReturnLabel_46:
        JEQ     ??zclParseInReadCmd_1
// 3227   {
// 3228     uint8 i;
// 3229     readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
        MOV.W   0x2(R11), R14
        RRUM.W  #0x1, R14
        MOV.B   R14, 0(R12)
// 3230     for ( i = 0; i < readCmd->numAttr; i++ )
        MOV.B   #0x0, R14
        JMP     ??zclParseInReadCmd_2
// 3231     {
// 3232       readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
??zclParseInReadCmd_0:
        MOV.B   @R10, R13
        MOV.B   0x1(R10), R15
        RPT     #0x8
        RLAX.W  R15
        ADD.W   R15, R13
        MOV.B   R14, R15
        RLA.W   R15
        MOV.W   R12, R11
        ADD.W   R15, R11
        MOV.W   R13, 0x2(R11)
// 3233       pBuf += 2;
        ADD.W   #0x2, R10
// 3234     }
        ADD.B   #0x1, R14
??zclParseInReadCmd_2:
        CMP.B   @R12, R14
        JNC     ??zclParseInReadCmd_0
// 3235   }
// 3236 
// 3237   return ( (void *)readCmd );
??zclParseInReadCmd_1:
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock118
// 3238 }

        RSEG CODE:CODE:NOROOT(1)
zclParseInWriteCmd:
          CFI Block cfiBlock119 Using cfiCommon0
          CFI Function zclParseInWriteCmd
        FUNCALL zclParseInWriteCmd, zclGetAttrDataLength
        LOCFRAME CSTACK, 20, STACK
        FUNCALL zclParseInWriteCmd, osal_mem_alloc
        LOCFRAME CSTACK, 20, STACK
        FUNCALL zclParseInWriteCmd, zclGetAttrDataLength
        LOCFRAME CSTACK, 20, STACK
        FUNCALL zclParseInWriteCmd, osal_memcpy
        LOCFRAME CSTACK, 20, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        MOV.W   R12, R7
        MOV.W   0x4(R12), R9
        MOV.B   #0x0, R11
        MOV.W   #0x0, R8
        JMP     ??zclParseInWriteCmd_4
??zclParseInWriteCmd_0:
        ADD.B   #0x1, R11
        ADD.W   #0x2, R9
        CALLA   #?Subroutine11
??zclParseInWriteCmd_4:
        MOV.W   0x4(R7), R15
        ADD.W   0x2(R7), R15
        CMP.W   R15, R9
        JNC     ??zclParseInWriteCmd_0
        CALLA   #?Subroutine4
??CrossCallReturnLabel_33:
        JEQ     ??zclParseInWriteCmd_5
        CALLA   #?Subroutine19
??CrossCallReturnLabel_11:
        JMP     ??zclParseInWriteCmd_6
??zclParseInWriteCmd_1:
        CALLA   #?Subroutine13
??CrossCallReturnLabel_6:
        MOV.W   R9, R13
        MOV.B   0x2(R7), R12
        CALLA   #?Subroutine10
??CrossCallReturnLabel_3:
        ADD.B   #0x1, R6
??zclParseInWriteCmd_6:
        CMP.B   R11, R6
        JNC     ??zclParseInWriteCmd_1
          CFI EndBlock cfiBlock119
??zclParseInWriteCmd_5:
        REQUIRE ?Subroutine1
        // Fall through to label ?Subroutine1
// 3239 
// 3240 /*********************************************************************
// 3241  * @fn      zclParseInReadRspCmd
// 3242  *
// 3243  * @brief   Parse the "Profile" Read Response Commands
// 3244  *
// 3245  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3246  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3247  *
// 3248  * @param   pCmd - pointer to incoming data to parse
// 3249  *
// 3250  * @return  pointer to the parsed command structure
// 3251  */

        RSEG CODE:CODE:NOROOT(1)
?Subroutine1:
          CFI Block cfiBlock120 Using cfiCommon0
          CFI NoFunction
          CFI CFA SP+20
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
        MOV.W   R8, R12
        POPM.W  #0x8, R11
          CFI CFA SP+4
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI R10L SameValue
          CFI R11L SameValue
        RETA
          CFI EndBlock cfiBlock120

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 3252 static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
zclParseInReadRspCmd:
          CFI Block cfiBlock121 Using cfiCommon0
          CFI Function zclParseInReadRspCmd
// 3253 {
        FUNCALL zclParseInReadRspCmd, zclGetAttrDataLength
        LOCFRAME CSTACK, 20, STACK
        FUNCALL zclParseInReadRspCmd, osal_mem_alloc
        LOCFRAME CSTACK, 20, STACK
        FUNCALL zclParseInReadRspCmd, zclGetAttrDataLength
        LOCFRAME CSTACK, 20, STACK
        FUNCALL zclParseInReadRspCmd, osal_memcpy
        LOCFRAME CSTACK, 20, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        MOV.W   R12, R7
// 3254   zclReadRspCmd_t *readRspCmd;
// 3255   uint8 *pBuf = pCmd->pData;
        MOV.W   0x4(R12), R9
// 3256   uint8 *dataPtr;
// 3257   uint8 numAttr = 0;
        MOV.B   #0x0, R11
// 3258   uint8 hdrLen;
// 3259   uint16 dataLen = 0;
        MOV.W   #0x0, R8
        JMP     ??zclParseInReadRspCmd_4
// 3260   uint16 attrDataLen;
// 3261 
// 3262   // find out the number of attributes and the length of attribute data
// 3263   while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
// 3264   {
// 3265     uint8 status;
// 3266 
// 3267     numAttr++;
??zclParseInReadRspCmd_0:
        ADD.B   #0x1, R11
// 3268     pBuf += 2; // move pass attribute id
        ADD.W   #0x2, R9
// 3269 
// 3270     status = *pBuf++;
        MOV.B   @R9+, R14
// 3271     if ( status == ZCL_STATUS_SUCCESS )
        CMP.B   #0x0, R14
        JNE     ??zclParseInReadRspCmd_4
// 3272     {
// 3273       uint8 dataType = *pBuf++;
        CALLA   #?Subroutine11
// 3274 
// 3275       attrDataLen = zclGetAttrDataLength( dataType, pBuf );
// 3276       pBuf += attrDataLen; // move pass attribute data
// 3277 
// 3278       // add padding if needed
// 3279       if ( PADDING_NEEDED( attrDataLen ) )
// 3280       {
// 3281         attrDataLen++;
// 3282       }
// 3283 
// 3284       dataLen += attrDataLen;
// 3285     }
// 3286   }
??zclParseInReadRspCmd_4:
        MOV.W   0x4(R7), R15
        ADD.W   0x2(R7), R15
        CMP.W   R15, R9
        JNC     ??zclParseInReadRspCmd_0
// 3287 
// 3288   // calculate the length of the response header
// 3289   hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
        CALLA   #?Subroutine4
// 3290 
// 3291   readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
// 3292   if ( readRspCmd != NULL )
??CrossCallReturnLabel_34:
        JEQ     ??zclParseInReadRspCmd_5
// 3293   {
// 3294     uint8 i;
// 3295     pBuf = pCmd->pData;
        CALLA   #?Subroutine19
// 3296     dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
// 3297 
// 3298     readRspCmd->numAttr = numAttr;
// 3299     for ( i = 0; i < numAttr; i++ )
??CrossCallReturnLabel_12:
        JMP     ??zclParseInReadRspCmd_6
// 3300     {
// 3301       zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
??zclParseInReadRspCmd_1:
        CALLA   #?Subroutine13
// 3302 
// 3303       statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3304       pBuf += 2;
// 3305 
// 3306       statusRec->status = *pBuf++;
// 3307       if ( statusRec->status == ZCL_STATUS_SUCCESS )
??CrossCallReturnLabel_7:
        CMP.B   #0x0, 0x2(R7)
        JNE     ??zclParseInReadRspCmd_7
// 3308       {
// 3309         statusRec->dataType = *pBuf++;
        MOV.B   @R9+, 0x3(R7)
// 3310 
// 3311         attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
        MOV.W   R9, R13
        MOV.B   0x3(R7), R12
        CALLA   #?Subroutine10
// 3312         zcl_memcpy( dataPtr, pBuf, attrDataLen);
// 3313         statusRec->data = dataPtr;
// 3314 
// 3315         pBuf += attrDataLen; // move pass attribute data
// 3316 
// 3317         // advance attribute data pointer
// 3318         if ( PADDING_NEEDED( attrDataLen ) )
// 3319         {
// 3320           attrDataLen++;
// 3321         }
// 3322 
// 3323         dataPtr += attrDataLen;
// 3324       }
// 3325     }
??zclParseInReadRspCmd_7:
        ADD.B   #0x1, R6
??zclParseInReadRspCmd_6:
        CMP.B   R11, R6
        JNC     ??zclParseInReadRspCmd_1
// 3326   }
// 3327 
// 3328   return ( (void *)readRspCmd );
??zclParseInReadRspCmd_5:
        JMP     ?Subroutine1
        NOP
          CFI EndBlock cfiBlock121
// 3329 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine19:
          CFI Block cfiCond122 Using cfiCommon0
          CFI Function zclParseInWriteCmd
          CFI Conditional ??CrossCallReturnLabel_11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+24
          CFI Block cfiCond123 Using cfiCommon0
          CFI (cfiCond123) Function zclParseInReadRspCmd
          CFI (cfiCond123) Conditional ??CrossCallReturnLabel_12
          CFI (cfiCond123) R4L Frame(CFA, -20)
          CFI (cfiCond123) R5L Frame(CFA, -18)
          CFI (cfiCond123) R6L Frame(CFA, -16)
          CFI (cfiCond123) R7L Frame(CFA, -14)
          CFI (cfiCond123) R8L Frame(CFA, -12)
          CFI (cfiCond123) R9L Frame(CFA, -10)
          CFI (cfiCond123) R10L Frame(CFA, -8)
          CFI (cfiCond123) R11L Frame(CFA, -6)
          CFI (cfiCond123) CFA SP+24
          CFI Block cfiPicker124 Using cfiCommon1
          CFI (cfiPicker124) NoFunction
          CFI (cfiPicker124) Picker
// 3330 #endif // ZCL_READ
// 3331 
// 3332 #ifdef ZCL_WRITE
// 3333 /*********************************************************************
// 3334  * @fn      zclParseInWriteCmd
// 3335  *
// 3336  * @brief   Parse the "Profile" Write, Write Undivided and Write No
// 3337  *          Response Commands
// 3338  *
// 3339  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3340  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3341  *
// 3342  * @param   pCmd - pointer to incoming data to parse
// 3343  *
// 3344  * @return  pointer to the parsed command structure
// 3345  */
// 3346 void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
// 3347 {
// 3348   zclWriteCmd_t *writeCmd;
// 3349   uint8 *pBuf = pCmd->pData;
// 3350   uint16 attrDataLen;
// 3351   uint8 *dataPtr;
// 3352   uint8 numAttr = 0;
// 3353   uint8 hdrLen;
// 3354   uint16 dataLen = 0;
// 3355 
// 3356   // find out the number of attributes and the length of attribute data
// 3357   while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
// 3358   {
// 3359     uint8 dataType;
// 3360 
// 3361     numAttr++;
// 3362     pBuf += 2; // move pass attribute id
// 3363 
// 3364     dataType = *pBuf++;
// 3365 
// 3366     attrDataLen = zclGetAttrDataLength( dataType, pBuf );
// 3367     pBuf += attrDataLen; // move pass attribute data
// 3368 
// 3369     // add padding if needed
// 3370     if ( PADDING_NEEDED( attrDataLen ) )
// 3371     {
// 3372       attrDataLen++;
// 3373     }
// 3374 
// 3375     dataLen += attrDataLen;
// 3376   }
// 3377 
// 3378   // calculate the length of the response header
// 3379   hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
// 3380 
// 3381   writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
// 3382   if ( writeCmd != NULL )
// 3383   {
// 3384     uint8 i;
// 3385     pBuf = pCmd->pData;
        MOV.W   0x4(R7), R9
// 3386     dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
        MOV.B   R10, R15
        MOV.W   R12, R10
        ADD.W   R15, R10
// 3387 
// 3388     writeCmd->numAttr = numAttr;
        MOV.B   R11, 0(R12)
// 3389     for ( i = 0; i < numAttr; i++ )
        MOV.B   #0x0, R6
        RETA
          CFI EndBlock cfiCond122
          CFI EndBlock cfiCond123
          CFI EndBlock cfiPicker124

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine13:
          CFI Block cfiCond125 Using cfiCommon0
          CFI Function zclParseInWriteCmd
          CFI Conditional ??CrossCallReturnLabel_6
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+24
          CFI Block cfiCond126 Using cfiCommon0
          CFI (cfiCond126) Function zclParseInReadRspCmd
          CFI (cfiCond126) Conditional ??CrossCallReturnLabel_7
          CFI (cfiCond126) R4L Frame(CFA, -20)
          CFI (cfiCond126) R5L Frame(CFA, -18)
          CFI (cfiCond126) R6L Frame(CFA, -16)
          CFI (cfiCond126) R7L Frame(CFA, -14)
          CFI (cfiCond126) R8L Frame(CFA, -12)
          CFI (cfiCond126) R9L Frame(CFA, -10)
          CFI (cfiCond126) R10L Frame(CFA, -8)
          CFI (cfiCond126) R11L Frame(CFA, -6)
          CFI (cfiCond126) CFA SP+24
          CFI Block cfiPicker127 Using cfiCommon1
          CFI (cfiPicker127) NoFunction
          CFI (cfiPicker127) Picker
// 3390     {
// 3391       zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
        MOV.W   R6, R15
        RPT     #0x5
        ADDX.W  R6, R15
        MOV.W   R8, R7
        ADD.W   R15, R7
        ADD.W   #0x2, R7
// 3392 
// 3393       statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV.B   @R9, R14
        MOV.B   0x1(R9), R15
        RPT     #0x8
        RLAX.W  R15
        ADD.W   R15, R14
        MOV.W   R14, 0(R7)
// 3394       pBuf += 2;
        ADD.W   #0x2, R9
// 3395       statusRec->dataType = *pBuf++;
        MOV.B   @R9+, 0x2(R7)
        RETA
          CFI EndBlock cfiCond125
          CFI EndBlock cfiCond126
          CFI EndBlock cfiPicker127

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine11:
          CFI Block cfiCond128 Using cfiCommon0
          CFI Function zclParseInWriteCmd
          CFI Conditional ??zclParseInWriteCmd_4
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+24
          CFI Block cfiCond129 Using cfiCommon0
          CFI (cfiCond129) Function zclParseInReadRspCmd
          CFI (cfiCond129) Conditional ??zclParseInReadRspCmd_4
          CFI (cfiCond129) R4L Frame(CFA, -20)
          CFI (cfiCond129) R5L Frame(CFA, -18)
          CFI (cfiCond129) R6L Frame(CFA, -16)
          CFI (cfiCond129) R7L Frame(CFA, -14)
          CFI (cfiCond129) R8L Frame(CFA, -12)
          CFI (cfiCond129) R9L Frame(CFA, -10)
          CFI (cfiCond129) R10L Frame(CFA, -8)
          CFI (cfiCond129) R11L Frame(CFA, -6)
          CFI (cfiCond129) CFA SP+24
          CFI Block cfiPicker130 Using cfiCommon1
          CFI (cfiPicker130) NoFunction
          CFI (cfiPicker130) Picker
        MOV.B   @R9+, R12
        MOV.W   R9, R13
        CALLA   #zclGetAttrDataLength
        MOV.W   R12, R4
        ADD.W   R12, R9
        BIT.W   #0x1, R12
        JNC     ??zclParseInWriteCmd_3
        ADD.W   #0x1, R4
??zclParseInWriteCmd_3:
        ADD.W   R4, R8
        RETA
          CFI EndBlock cfiCond128
          CFI EndBlock cfiCond129
          CFI EndBlock cfiPicker130

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine10:
          CFI Block cfiCond131 Using cfiCommon0
          CFI Function zclParseInWriteCmd
          CFI Conditional ??CrossCallReturnLabel_3
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+24
          CFI Block cfiCond132 Using cfiCommon0
          CFI (cfiCond132) Function zclParseInReadRspCmd
          CFI (cfiCond132) Conditional ??zclParseInReadRspCmd_7
          CFI (cfiCond132) R4L Frame(CFA, -20)
          CFI (cfiCond132) R5L Frame(CFA, -18)
          CFI (cfiCond132) R6L Frame(CFA, -16)
          CFI (cfiCond132) R7L Frame(CFA, -14)
          CFI (cfiCond132) R8L Frame(CFA, -12)
          CFI (cfiCond132) R9L Frame(CFA, -10)
          CFI (cfiCond132) R10L Frame(CFA, -8)
          CFI (cfiCond132) R11L Frame(CFA, -6)
          CFI (cfiCond132) CFA SP+24
          CFI Block cfiPicker133 Using cfiCommon1
          CFI (cfiPicker133) NoFunction
          CFI (cfiPicker133) Picker
// 3396 
// 3397       attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
        CALLA   #zclGetAttrDataLength
        MOV.W   R12, R4
// 3398       zcl_memcpy( dataPtr, pBuf, attrDataLen);
        MOV.W   R12, R14
        MOV.W   R9, R13
        MOV.W   R10, R12
        CALLA   #osal_memcpy
// 3399       statusRec->attrData = dataPtr;
        MOV.W   R10, 0x4(R7)
// 3400 
// 3401       pBuf += attrDataLen; // move pass attribute data
        ADD.W   R4, R9
// 3402 
// 3403       // advance attribute data pointer
// 3404       if ( PADDING_NEEDED( attrDataLen ) )
        BIT.W   #0x1, R4
        JNC     ??zclParseInWriteCmd_2
// 3405       {
// 3406         attrDataLen++;
        ADD.W   #0x1, R4
// 3407       }
// 3408 
// 3409       dataPtr += attrDataLen;
??zclParseInWriteCmd_2:
        ADD.W   R4, R10
        RETA
          CFI EndBlock cfiCond131
          CFI EndBlock cfiCond132
          CFI EndBlock cfiPicker133
// 3410     }
// 3411   }
// 3412 
// 3413   return ( (void *)writeCmd );
// 3414 }
// 3415 
// 3416 /*********************************************************************
// 3417  * @fn      zclParseInWriteRspCmd
// 3418  *
// 3419  * @brief   Parse the "Profile" Write Response Commands
// 3420  *
// 3421  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3422  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3423  *
// 3424  * @param   pCmd - pointer to incoming data to parse
// 3425  *
// 3426  * @return  pointer to the parsed command structure
// 3427  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 3428 static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
zclParseInWriteRspCmd:
          CFI Block cfiBlock134 Using cfiCommon0
          CFI Function zclParseInWriteRspCmd
// 3429 {
        FUNCALL zclParseInWriteRspCmd, osal_mem_alloc
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R12, R11
// 3430   zclWriteRspCmd_t *writeRspCmd;
// 3431   uint8 *pBuf = pCmd->pData;
        MOV.W   0x4(R12), R8
// 3432   uint8 i = 0;
        MOV.B   #0x0, R10
// 3433 
// 3434   writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
        CALLA   #?Subroutine5
// 3435   if ( writeRspCmd != NULL )
??CrossCallReturnLabel_45:
        JEQ     ??zclParseInWriteRspCmd_1
// 3436   {
// 3437     if ( pCmd->dataLen == 1 )
        CMP.W   #0x1, 0x2(R11)
        JNE     ??zclParseInWriteRspCmd_2
// 3438     {
// 3439       // special case when all writes were successfull
// 3440       writeRspCmd->attrList[i++].status = *pBuf;
        MOV.B   @R8, 0x2(R12)
        MOV.B   #0x1, R10
        JMP     ??zclParseInWriteRspCmd_3
// 3441     }
// 3442     else
// 3443     {
// 3444       while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
// 3445       {
// 3446         writeRspCmd->attrList[i].status = *pBuf++;
??zclParseInWriteRspCmd_0:
        MOV.B   R10, R15
        RLAM.W  #0x2, R15
        MOV.W   R12, R13
        ADD.W   R15, R13
        MOV.B   @R8+, 0x2(R13)
// 3447         writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV.B   @R8, R14
        MOV.B   0x1(R8), R15
        RPT     #0x8
        RLAX.W  R15
        ADD.W   R15, R14
        MOV.W   R14, 0x4(R13)
        ADD.B   #0x1, R10
// 3448         pBuf += 2;
        ADD.W   #0x2, R8
// 3449       }
??zclParseInWriteRspCmd_2:
        MOV.W   0x4(R11), R15
        ADD.W   0x2(R11), R15
        CMP.W   R15, R8
        JNC     ??zclParseInWriteRspCmd_0
// 3450     }
// 3451 
// 3452     writeRspCmd->numAttr = i;
??zclParseInWriteRspCmd_3:
        MOV.B   R10, 0(R12)
// 3453   }
// 3454 
// 3455   return ( (void *)writeRspCmd );
??zclParseInWriteRspCmd_1:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock134
// 3456 }
// 3457 #endif // ZCL_WRITE
// 3458 
// 3459 #ifdef ZCL_REPORT
// 3460 /*********************************************************************
// 3461  * @fn      zclParseInConfigReportCmd
// 3462  *
// 3463  * @brief   Parse the "Profile" Configure Reporting Command
// 3464  *
// 3465  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3466  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3467  *
// 3468  * @param   pCmd - pointer to incoming data to parse
// 3469  *
// 3470  * @return  pointer to the parsed command structure
// 3471  */
// 3472 void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
// 3473 {
// 3474   zclCfgReportCmd_t *cfgReportCmd;
// 3475   uint8 *pBuf = pCmd->pData;
// 3476   uint8 *dataPtr;
// 3477   uint8 numAttr = 0;
// 3478   uint8 dataType;
// 3479   uint8 hdrLen;
// 3480   uint16 dataLen = 0;
// 3481   uint8 reportChangeLen; // length of Reportable Change field
// 3482 
// 3483   // Calculate the length of the Request command
// 3484   while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
// 3485   {
// 3486     uint8 direction;
// 3487 
// 3488     numAttr++;
// 3489     direction = *pBuf++;
// 3490     pBuf += 2; // move pass the attribute ID
// 3491 
// 3492     // Is there a Reportable Change field?
// 3493     if ( direction == ZCL_SEND_ATTR_REPORTS )
// 3494     {
// 3495       dataType = *pBuf++;
// 3496       pBuf += 4; // move pass the Min and Max Reporting Intervals
// 3497 
// 3498       // For attributes of 'discrete' data types this field is omitted
// 3499       if ( zclAnalogDataType( dataType ) )
// 3500       {
// 3501         reportChangeLen = zclGetDataTypeLength( dataType );
// 3502         pBuf += reportChangeLen;
// 3503 
// 3504         // add padding if needed
// 3505         if ( PADDING_NEEDED( reportChangeLen ) )
// 3506         {
// 3507           reportChangeLen++;
// 3508         }
// 3509 
// 3510         dataLen += reportChangeLen;
// 3511       }
// 3512       else
// 3513       {
// 3514         pBuf++; // move past reportable change field
// 3515       }
// 3516     }
// 3517     else
// 3518     {
// 3519       pBuf += 2; // move pass the Timeout Period
// 3520     }
// 3521   } // while loop
// 3522 
// 3523   hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
// 3524 
// 3525   cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
// 3526   if ( cfgReportCmd != NULL )
// 3527   {
// 3528     uint8 i;
// 3529     pBuf = pCmd->pData;
// 3530     dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
// 3531 
// 3532     cfgReportCmd->numAttr = numAttr;
// 3533     for ( i = 0; i < numAttr; i++ )
// 3534     {
// 3535       zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
// 3536 
// 3537       zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
// 3538 
// 3539       reportRec->direction = *pBuf++;
// 3540       reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3541       pBuf += 2;
// 3542       if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
// 3543       {
// 3544         // Attribute to be reported
// 3545         reportRec->dataType = *pBuf++;
// 3546         reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3547         pBuf += 2;
// 3548         reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3549         pBuf += 2;
// 3550 
// 3551         // For attributes of 'discrete' data types this field is omitted
// 3552         if ( zclAnalogDataType( reportRec->dataType ) )
// 3553         {
// 3554           zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
// 3555           reportRec->reportableChange = dataPtr;
// 3556 
// 3557           reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
// 3558           pBuf += reportChangeLen;
// 3559 
// 3560           // advance attribute data pointer
// 3561           if ( PADDING_NEEDED( reportChangeLen ) )
// 3562           {
// 3563             reportChangeLen++;
// 3564           }
// 3565 
// 3566           dataPtr += reportChangeLen;
// 3567         }
// 3568       }
// 3569       else
// 3570       {
// 3571         // Attribute reports to be received
// 3572         reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3573         pBuf += 2;
// 3574       }
// 3575     } // while loop
// 3576   }
// 3577 
// 3578   return ( (void *)cfgReportCmd );
// 3579 }
// 3580 
// 3581 /*********************************************************************
// 3582  * @fn      zclParseInConfigReportRspCmd
// 3583  *
// 3584  * @brief   Parse the "Profile" Configure Reporting Response Command
// 3585  *
// 3586  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3587  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3588  *
// 3589  * @param   pCmd - pointer to incoming data to parse
// 3590  *
// 3591  * @return  pointer to the parsed command structure
// 3592  */
// 3593 static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
// 3594 {
// 3595   zclCfgReportRspCmd_t *cfgReportRspCmd;
// 3596   uint8 *pBuf = pCmd->pData;
// 3597   uint8 numAttr;
// 3598 
// 3599   numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
// 3600 
// 3601   cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
// 3602                                             + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
// 3603   if ( cfgReportRspCmd != NULL )
// 3604   {
// 3605     uint8 i;
// 3606     cfgReportRspCmd->numAttr = numAttr;
// 3607     for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
// 3608     {
// 3609       cfgReportRspCmd->attrList[i].status = *pBuf++;
// 3610       cfgReportRspCmd->attrList[i].direction = *pBuf++;
// 3611       cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3612       pBuf += 2;
// 3613     }
// 3614   }
// 3615 
// 3616   return ( (void *)cfgReportRspCmd );
// 3617 }
// 3618 
// 3619 /*********************************************************************
// 3620  * @fn      zclParseInReadReportCfgCmd
// 3621  *
// 3622  * @brief   Parse the "Profile" Read Reporting Configuration Command
// 3623  *
// 3624  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3625  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3626  *
// 3627  * @param   pCmd - pointer to incoming data to parse
// 3628  *
// 3629  * @return  pointer to the parsed command structure
// 3630  */
// 3631 void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
// 3632 {
// 3633   zclReadReportCfgCmd_t *readReportCfgCmd;
// 3634   uint8 *pBuf = pCmd->pData;
// 3635   uint8 numAttr;
// 3636 
// 3637   numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
// 3638 
// 3639   readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
// 3640                                                   + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
// 3641   if ( readReportCfgCmd != NULL )
// 3642   {
// 3643     uint8 i;
// 3644     readReportCfgCmd->numAttr = numAttr;
// 3645     for ( i = 0; i < readReportCfgCmd->numAttr; i++)
// 3646     {
// 3647       readReportCfgCmd->attrList[i].direction = *pBuf++;;
// 3648       readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3649       pBuf += 2;
// 3650     }
// 3651   }
// 3652 
// 3653   return ( (void *)readReportCfgCmd );
// 3654 }
// 3655 
// 3656 /*********************************************************************
// 3657  * @fn      zclParseInReadReportCfgRspCmd
// 3658  *
// 3659  * @brief   Parse the "Profile" Read Reporting Configuration Response Command
// 3660  *
// 3661  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3662  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3663  *
// 3664  * @param   pCmd - pointer to incoming data to parse
// 3665  *
// 3666  * @return  pointer to the parsed command structure
// 3667  */
// 3668 static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
// 3669 {
// 3670   zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
// 3671   uint8 reportChangeLen;
// 3672   uint8 *pBuf = pCmd->pData;
// 3673   uint8 *dataPtr;
// 3674   uint8 numAttr = 0;
// 3675   uint8 hdrLen;
// 3676   uint16 dataLen = 0;
// 3677 
// 3678   // Calculate the length of the response command
// 3679   while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
// 3680   {
// 3681     uint8 status;
// 3682     uint8 direction;
// 3683 
// 3684     numAttr++;
// 3685     status = *pBuf++;
// 3686     direction = *pBuf++;
// 3687     pBuf += 2; // move pass the attribute ID
// 3688 
// 3689     if ( status == ZCL_STATUS_SUCCESS )
// 3690     {
// 3691       if ( direction == ZCL_SEND_ATTR_REPORTS )
// 3692       {
// 3693         uint8 dataType = *pBuf++;
// 3694         pBuf += 4; // move pass the Min and Max Reporting Intervals
// 3695 
// 3696         // For attributes of 'discrete' data types this field is omitted
// 3697         if ( zclAnalogDataType( dataType ) )
// 3698         {
// 3699           reportChangeLen = zclGetDataTypeLength( dataType );
// 3700           pBuf += reportChangeLen;
// 3701 
// 3702           // add padding if needed
// 3703           if ( PADDING_NEEDED( reportChangeLen ) )
// 3704           {
// 3705             reportChangeLen++;
// 3706           }
// 3707 
// 3708           dataLen += reportChangeLen;
// 3709         }
// 3710       }
// 3711       else
// 3712       {
// 3713         pBuf += 2; // move pass the Timeout field
// 3714       }
// 3715     }
// 3716   } // while loop
// 3717 
// 3718   hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
// 3719 
// 3720   readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
// 3721   if ( readReportCfgRspCmd != NULL )
// 3722   {
// 3723     uint8 i;
// 3724     pBuf = pCmd->pData;
// 3725     dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
// 3726 
// 3727     readReportCfgRspCmd->numAttr = numAttr;
// 3728     for ( i = 0; i < numAttr; i++ )
// 3729     {
// 3730       zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
// 3731 
// 3732       reportRspRec->status = *pBuf++;
// 3733       reportRspRec->direction = *pBuf++;
// 3734       reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3735       pBuf += 2;
// 3736 
// 3737       if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
// 3738       {
// 3739         if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
// 3740         {
// 3741           reportRspRec->dataType = *pBuf++;
// 3742           reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3743           pBuf += 2;
// 3744           reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3745           pBuf += 2;
// 3746 
// 3747           if ( zclAnalogDataType( reportRspRec->dataType ) )
// 3748           {
// 3749             zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
// 3750             reportRspRec->reportableChange = dataPtr;
// 3751 
// 3752             reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
// 3753             pBuf += reportChangeLen;
// 3754 
// 3755             // advance attribute data pointer
// 3756             if ( PADDING_NEEDED( reportChangeLen ) )
// 3757             {
// 3758               reportChangeLen++;
// 3759             }
// 3760 
// 3761             dataPtr += reportChangeLen;
// 3762           }
// 3763         }
// 3764         else
// 3765         {
// 3766           reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3767           pBuf += 2;
// 3768         }
// 3769       }
// 3770     }
// 3771   }
// 3772 
// 3773   return ( (void *)readReportCfgRspCmd );
// 3774 }
// 3775 
// 3776 /*********************************************************************
// 3777  * @fn      zclParseInReportCmd
// 3778  *
// 3779  * @brief   Parse the "Profile" Report Command
// 3780  *
// 3781  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3782  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3783  *
// 3784  * @param   pCmd - pointer to incoming data to parse
// 3785  *
// 3786  * @return  pointer to the parsed command structure
// 3787  */
// 3788 void *zclParseInReportCmd( zclParseCmd_t *pCmd )
// 3789 {
// 3790   zclReportCmd_t *reportCmd;
// 3791   uint8 *pBuf = pCmd->pData;
// 3792   uint16 attrDataLen;
// 3793   uint8 *dataPtr;
// 3794   uint8 numAttr = 0;
// 3795   uint8 hdrLen;
// 3796   uint16 dataLen = 0;
// 3797 
// 3798   // find out the number of attributes and the length of attribute data
// 3799   while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
// 3800   {
// 3801     uint8 dataType;
// 3802 
// 3803     numAttr++;
// 3804     pBuf += 2; // move pass attribute id
// 3805 
// 3806     dataType = *pBuf++;
// 3807 
// 3808     attrDataLen = zclGetAttrDataLength( dataType, pBuf );
// 3809     pBuf += attrDataLen; // move pass attribute data
// 3810 
// 3811     // add padding if needed
// 3812     if ( PADDING_NEEDED( attrDataLen ) )
// 3813     {
// 3814       attrDataLen++;
// 3815     }
// 3816 
// 3817     dataLen += attrDataLen;
// 3818   }
// 3819 
// 3820   hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
// 3821 
// 3822   reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
// 3823   if (reportCmd != NULL )
// 3824   {
// 3825     uint8 i;
// 3826     pBuf = pCmd->pData;
// 3827     dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
// 3828 
// 3829     reportCmd->numAttr = numAttr;
// 3830     for ( i = 0; i < numAttr; i++ )
// 3831     {
// 3832       zclReport_t *reportRec = &(reportCmd->attrList[i]);
// 3833 
// 3834       reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3835       pBuf += 2;
// 3836       reportRec->dataType = *pBuf++;
// 3837 
// 3838       attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
// 3839       zcl_memcpy( dataPtr, pBuf, attrDataLen );
// 3840       reportRec->attrData = dataPtr;
// 3841 
// 3842       pBuf += attrDataLen; // move pass attribute data
// 3843 
// 3844       // advance attribute data pointer
// 3845       if ( PADDING_NEEDED( attrDataLen ) )
// 3846       {
// 3847         attrDataLen++;
// 3848       }
// 3849 
// 3850       dataPtr += attrDataLen;
// 3851     }
// 3852   }
// 3853 
// 3854   return ( (void *)reportCmd );
// 3855 }
// 3856 #endif // ZCL_REPORT
// 3857 
// 3858 /*********************************************************************
// 3859  * @fn      zclParseInDefaultRspCmd
// 3860  *
// 3861  * @brief   Parse the "Profile" Default Response Command
// 3862  *
// 3863  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3864  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3865  *
// 3866  * @param   pCmd - pointer to incoming data to parse
// 3867  *
// 3868  * @return  pointer to the parsed command structure
// 3869  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 3870 static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
zclParseInDefaultRspCmd:
          CFI Block cfiBlock135 Using cfiCommon0
          CFI Function zclParseInDefaultRspCmd
// 3871 {
        FUNCALL zclParseInDefaultRspCmd, osal_mem_alloc
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
// 3872   zclDefaultRspCmd_t *defaultRspCmd;
// 3873   uint8 *pBuf = pCmd->pData;
        MOV.W   0x4(R12), R10
// 3874 
// 3875   defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
        MOV.W   #0x2, R12
        CALLA   #??Subroutine5_0
// 3876   if ( defaultRspCmd != NULL )
??CrossCallReturnLabel_47:
        JEQ     ??zclParseInDefaultRspCmd_0
// 3877   {
// 3878     defaultRspCmd->commandID = *pBuf++;
        MOV.B   @R10+, 0(R12)
// 3879     defaultRspCmd->statusCode = *pBuf;
        MOV.B   @R10, 0x1(R12)
// 3880   }
// 3881 
// 3882   return ( (void *)defaultRspCmd );
??zclParseInDefaultRspCmd_0:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock135
// 3883 }

        RSEG CODE:CODE:NOROOT(1)
zclProcessInWriteCmd:
          CFI Block cfiBlock136 Using cfiCommon0
          CFI Function zclProcessInWriteCmd
        FUNCALL zclProcessInWriteCmd, osal_mem_alloc
        LOCFRAME CSTACK, 28, STACK
        FUNCALL zclProcessInWriteCmd, zclFindAttrRec
        LOCFRAME CSTACK, 28, STACK
        FUNCALL zclProcessInWriteCmd, zclWriteAttrData
        LOCFRAME CSTACK, 28, STACK
        FUNCALL zclProcessInWriteCmd, zclWriteAttrDataUsingCB
        LOCFRAME CSTACK, 28, STACK
        FUNCALL zclProcessInWriteCmd, zcl_SendWriteRsp
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zclProcessInWriteCmd, osal_mem_free
        LOCFRAME CSTACK, 34, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        SUB.W   #0x8, SP
          CFI CFA SP+28
        MOV.W   R12, R11
        MOV.B   #0x0, R9
        MOV.B   #0x0, R10
        MOV.W   0xc(R12), R5
        CMP.B   #0x2, 0x7(R12)
        JNE     ??zclProcessInWriteCmd_3
        MOV.B   @R5, R12
        RLAM.W  #0x2, R12
        ADD.W   #0x2, R12
        CALLA   #??Subroutine4_0
??CrossCallReturnLabel_35:
        JNE     ??zclProcessInWriteCmd_4
        MOV.B   #0x0, R12
        JMP     ??zclProcessInWriteCmd_5
??zclProcessInWriteCmd_4:
        MOV.B   #0x1, R9
??zclProcessInWriteCmd_3:
        MOV.B   #0x0, R6
        JMP     ??zclProcessInWriteCmd_6
??zclProcessInWriteCmd_0:
        BIT.B   #0x1, R9
        JNC     ??zclProcessInWriteCmd_1
        MOV.B   #0x86, 0x2(R7)
??zclProcessInWriteCmd_2:
        MOV.W   @R4, 0x4(R7)
        ADD.B   #0x1, R10
??zclProcessInWriteCmd_1:
        ADD.B   #0x1, R6
??zclProcessInWriteCmd_6:
        CMP.B   @R5, R6
        JC      ??zclProcessInWriteCmd_7
        MOV.W   R6, R15
        RPT     #0x5
        ADDX.W  R6, R15
        MOV.W   R5, R4
        ADD.W   R15, R4
        ADD.W   #0x2, R4
        MOV.B   R10, R15
        RLAM.W  #0x2, R15
        MOV.W   R8, R7
        ADD.W   R15, R7
        MOV.W   @R11, R12
        MOV.W   SP, R15
        ADD.W   #0x0, R15
        CALLA   #?Subroutine9
??CrossCallReturnLabel_39:
        JEQ     ??zclProcessInWriteCmd_0
        CMP.B   0x4(SP), 0x2(R4)
        JNE     ??zclProcessInWriteCmd_8
        MOV.W   @R11, R12
        CMP.W   #0x0, 0x6(SP)
        JEQ     ??zclProcessInWriteCmd_9
        MOV.W   R4, R15
        CALLA   #?Subroutine12
??CrossCallReturnLabel_4:
        CALLA   #zclWriteAttrData
        JMP     ??zclProcessInWriteCmd_10
??zclProcessInWriteCmd_9:
        MOV.W   0x4(R4), R15
        CALLA   #?Subroutine12
??CrossCallReturnLabel_5:
        CALLA   #zclWriteAttrDataUsingCB
??zclProcessInWriteCmd_10:
        BIT.B   #0x1, R9
        JNC     ??zclProcessInWriteCmd_1
        CMP.B   #0x0, R12
        JEQ     ??zclProcessInWriteCmd_1
        MOV.B   R12, 0x2(R7)
        JMP     ??zclProcessInWriteCmd_2
??zclProcessInWriteCmd_8:
        BIT.B   #0x1, R9
        JNC     ??zclProcessInWriteCmd_1
        MOV.B   #0x8d, 0x2(R7)
        JMP     ??zclProcessInWriteCmd_2
??zclProcessInWriteCmd_7:
        BIT.B   #0x1, R9
        JNC     ??zclProcessInWriteCmd_11
        MOV.B   R10, 0(R8)
        CMP.B   #0x0, R10
        JNE     ??zclProcessInWriteCmd_12
        MOV.B   #0x0, 0x2(R8)
        MOV.B   #0x1, 0(R8)
??zclProcessInWriteCmd_12:
        MOV.W   @R11, R7
        PUSH.B  0x6(R11)
          CFI CFA SP+30
        PUSH.B  #0x1
          CFI CFA SP+32
        BIT.W   #0x8, 0x2(R11)
        CALLA   #??Subroutine15_0
??CrossCallReturnLabel_18:
        PUSH.B  R14
          CFI CFA SP+34
        MOV.W   R8, R15
        MOV.W   0x4(R7), R14
        MOV.W   R7, R13
        ADD.W   #0x6, R13
        MOV.B   0x14(R7), R12
        CALLA   #zcl_SendWriteRsp
        CALLA   #??Subroutine26_0
??CrossCallReturnLabel_30:
        ADD.W   #0x6, SP
          CFI CFA SP+28
??zclProcessInWriteCmd_11:
        MOV.B   #0x1, R12
          CFI EndBlock cfiBlock136
??zclProcessInWriteCmd_5:
        REQUIRE ?Subroutine0
        // Fall through to label ?Subroutine0
// 3884 
// 3885 #ifdef ZCL_DISCOVER
// 3886 /*********************************************************************
// 3887  * @fn      zclParseInDiscAttrsCmd
// 3888  *
// 3889  * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
// 3890  *
// 3891  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3892  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3893  *
// 3894  * @param   pCmd - pointer to incoming data to parse
// 3895  *
// 3896  * @return  pointer to the parsed command structure
// 3897  */
// 3898 void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
// 3899 {
// 3900   zclDiscoverAttrsCmd_t *pDiscoverCmd;
// 3901   uint8 *pBuf = pCmd->pData;
// 3902 
// 3903   pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
// 3904   if ( pDiscoverCmd != NULL )
// 3905   {
// 3906     pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3907     pBuf += 2;
// 3908     pDiscoverCmd->maxAttrIDs = *pBuf;
// 3909   }
// 3910 
// 3911   return ( (void *)pDiscoverCmd );
// 3912 }
// 3913 
// 3914 /*********************************************************************
// 3915  * @fn      zclParseInDiscAttrsRspCmd
// 3916  *
// 3917  * @brief   Parse the "Profile" Discovery Response Commands
// 3918  *
// 3919  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3920  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3921  *
// 3922  * @param   pCmd - pointer to incoming data to parse
// 3923  *
// 3924  * @return  pointer to the parsed command structure
// 3925  */
// 3926 #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
// 3927 static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
// 3928 {
// 3929   zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
// 3930   uint8 *pBuf = pCmd->pData;
// 3931   uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
// 3932 
// 3933   pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
// 3934                     ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
// 3935 
// 3936   if ( pDiscoverRspCmd != NULL )
// 3937   {
// 3938     pDiscoverRspCmd->discComplete = *pBuf++;
// 3939     pDiscoverRspCmd->numAttr = numAttr;
// 3940 
// 3941     for ( uint8 i = 0; i < numAttr; i++ )
// 3942     {
// 3943       pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3944       pBuf += 2;
// 3945       pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
// 3946     }
// 3947   }
// 3948 
// 3949   return ( (void *)pDiscoverRspCmd );
// 3950 }
// 3951 
// 3952 /*********************************************************************
// 3953  * @fn      zclParseInDiscCmdsCmd
// 3954  *
// 3955  * @brief   Parse the "Profile" Discovery Commands
// 3956  *
// 3957  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3958  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3959  *
// 3960  * @param   pCmd - pointer to incoming data to parse
// 3961  *
// 3962  * @return  pointer to the parsed command structure
// 3963  */
// 3964 void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
// 3965 {
// 3966   zclDiscoverCmdsCmd_t *pDiscoverCmd;
// 3967   uint8 *pBuf = pCmd->pData;
// 3968 
// 3969   pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
// 3970   if ( pDiscoverCmd != NULL )
// 3971   {
// 3972     pDiscoverCmd->startCmdID = *pBuf++;
// 3973     pDiscoverCmd->maxCmdID = *pBuf++;
// 3974   }
// 3975 
// 3976   return ( (void *)pDiscoverCmd );
// 3977 }
// 3978 
// 3979 /*********************************************************************
// 3980  * @fn      zclParseInDiscCmdsRspCmd
// 3981  *
// 3982  * @brief   Parse the Discover Commands Response Command
// 3983  *
// 3984  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3985  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3986  *
// 3987  * @param   pCmd - pointer to incoming data to parse
// 3988  *
// 3989  * @return  pointer to the parsed command structure
// 3990  */
// 3991 #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
// 3992 static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
// 3993 {
// 3994   zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
// 3995   uint8 *pBuf = pCmd->pData;
// 3996   uint8 i;
// 3997   uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // determine length of command ID variable array
// 3998 
// 3999   // allocate memory for size of structure plus variable array
// 4000   pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( 1 + numCmds );
// 4001   if ( pDiscoverRspCmd != NULL )
// 4002   {
// 4003     pDiscoverRspCmd->discComplete = *pBuf++;
// 4004     pDiscoverRspCmd->numCmd = numCmds;
// 4005 
// 4006     for ( i = 0; i < numCmds; i++ )
// 4007     {
// 4008       pDiscoverRspCmd->pCmdID[i] = *pBuf++;
// 4009     }
// 4010   }
// 4011 
// 4012   return ( (void *)pDiscoverRspCmd );
// 4013 }
// 4014 
// 4015 /*********************************************************************
// 4016  * @fn      zclParseInDiscAttrsExtRspCmd
// 4017  *
// 4018  * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
// 4019  *
// 4020  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 4021  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 4022  *
// 4023  * @param   pCmd - pointer to incoming data to parse
// 4024  *
// 4025  * @return  pointer to the parsed command structure
// 4026  */
// 4027 #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
// 4028 static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
// 4029 {
// 4030   zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
// 4031   uint8 i;
// 4032   uint8 *pBuf = pCmd->pData;
// 4033   uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
// 4034 
// 4035   pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
// 4036                     ( numAttrs * sizeof(zclDiscoverAttrsExtRsp_t) ) );
// 4037 
// 4038   if ( pDiscoverRspCmd != NULL )
// 4039   {
// 4040     pDiscoverRspCmd->discComplete = *pBuf++;
// 4041     pDiscoverRspCmd->numAttr = numAttrs;
// 4042 
// 4043     for ( i = 0; i < numAttrs; i++ )
// 4044     {
// 4045       pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 4046       pBuf += 2;
// 4047       pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
// 4048       pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
// 4049     }
// 4050   }
// 4051 
// 4052   return ( (void *)pDiscoverRspCmd );
// 4053 }
// 4054 #endif // ZCL_DISCOVER
// 4055 
// 4056 #ifdef ZCL_READ
// 4057 /*********************************************************************
// 4058  * @fn      zclProcessInReadCmd
// 4059  *
// 4060  * @brief   Process the "Profile" Read Command
// 4061  *
// 4062  * @param   pInMsg - incoming message to process
// 4063  *
// 4064  * @return  TRUE if command processed. FALSE, otherwise.
// 4065  */

        RSEG CODE:CODE:NOROOT(1)
?Subroutine0:
          CFI Block cfiBlock137 Using cfiCommon0
          CFI NoFunction
          CFI CFA SP+28
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
        ADD.W   #0x8, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI CFA SP+4
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI R10L SameValue
          CFI R11L SameValue
        RETA
          CFI EndBlock cfiBlock137

        RSEG CODE:CODE:NOROOT(1)
?Subroutine12:
          CFI Block cfiCond138 Using cfiCommon0
          CFI Function zclProcessInWriteCmd
          CFI Conditional ??CrossCallReturnLabel_4
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+32
          CFI Block cfiCond139 Using cfiCommon0
          CFI (cfiCond139) Function zclProcessInWriteCmd
          CFI (cfiCond139) Conditional ??CrossCallReturnLabel_5
          CFI (cfiCond139) R4L Frame(CFA, -20)
          CFI (cfiCond139) R5L Frame(CFA, -18)
          CFI (cfiCond139) R6L Frame(CFA, -16)
          CFI (cfiCond139) R7L Frame(CFA, -14)
          CFI (cfiCond139) R8L Frame(CFA, -12)
          CFI (cfiCond139) R9L Frame(CFA, -10)
          CFI (cfiCond139) R10L Frame(CFA, -8)
          CFI (cfiCond139) R11L Frame(CFA, -6)
          CFI (cfiCond139) CFA SP+32
          CFI Block cfiPicker140 Using cfiCommon1
          CFI (cfiPicker140) NoFunction
          CFI (cfiPicker140) Picker
        CALLA   #?Subroutine22
??CrossCallReturnLabel_25:
        RETA
          CFI EndBlock cfiCond138
          CFI EndBlock cfiCond139
          CFI EndBlock cfiPicker140

        RSEG CODE:CODE:NOROOT(1)
?Subroutine22:
          CFI Block cfiCond141 Using cfiCommon0
          CFI Function zclProcessInWriteUndividedCmd
          CFI Conditional ??CrossCallReturnLabel_24
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+36
          CFI Block cfiCond142 Using cfiCommon0
          CFI (cfiCond142) Function zclProcessInWriteCmd
          CFI (cfiCond142) Conditional ??CrossCallReturnLabel_25, ??CrossCallReturnLabel_4
          CFI (cfiCond142) R4L Frame(CFA, -20)
          CFI (cfiCond142) R5L Frame(CFA, -18)
          CFI (cfiCond142) R6L Frame(CFA, -16)
          CFI (cfiCond142) R7L Frame(CFA, -14)
          CFI (cfiCond142) R8L Frame(CFA, -12)
          CFI (cfiCond142) R9L Frame(CFA, -10)
          CFI (cfiCond142) R10L Frame(CFA, -8)
          CFI (cfiCond142) R11L Frame(CFA, -6)
          CFI (cfiCond142) CFA SP+36
          CFI Block cfiCond143 Using cfiCommon0
          CFI (cfiCond143) Function zclProcessInWriteCmd
          CFI (cfiCond143) Conditional ??CrossCallReturnLabel_25, ??CrossCallReturnLabel_5
          CFI (cfiCond143) R4L Frame(CFA, -20)
          CFI (cfiCond143) R5L Frame(CFA, -18)
          CFI (cfiCond143) R6L Frame(CFA, -16)
          CFI (cfiCond143) R7L Frame(CFA, -14)
          CFI (cfiCond143) R8L Frame(CFA, -12)
          CFI (cfiCond143) R9L Frame(CFA, -10)
          CFI (cfiCond143) R10L Frame(CFA, -8)
          CFI (cfiCond143) R11L Frame(CFA, -6)
          CFI (cfiCond143) CFA SP+36
          CFI Block cfiPicker144 Using cfiCommon1
          CFI (cfiPicker144) NoFunction
          CFI (cfiPicker144) Picker
        MOV.W   SP, R14
        ADD.W   #0x8, R14
          CFI EndBlock cfiCond141
          CFI EndBlock cfiCond142
          CFI EndBlock cfiCond143
          CFI EndBlock cfiPicker144
        REQUIRE ??Subroutine24_0
        // Fall through to label ??Subroutine24_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine24_0:
          CFI Block cfiCond145 Using cfiCommon0
          CFI Function zclProcessInWriteUndividedCmd
          CFI Conditional ??CrossCallReturnLabel_23
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+38
          CFI Block cfiCond146 Using cfiCommon0
          CFI (cfiCond146) Function zclProcessInWriteUndividedCmd
          CFI (cfiCond146) Conditional ??CrossCallReturnLabel_24
          CFI (cfiCond146) R4L Frame(CFA, -20)
          CFI (cfiCond146) R5L Frame(CFA, -18)
          CFI (cfiCond146) R6L Frame(CFA, -16)
          CFI (cfiCond146) R7L Frame(CFA, -14)
          CFI (cfiCond146) R8L Frame(CFA, -12)
          CFI (cfiCond146) R9L Frame(CFA, -10)
          CFI (cfiCond146) R10L Frame(CFA, -8)
          CFI (cfiCond146) R11L Frame(CFA, -6)
          CFI (cfiCond146) CFA SP+36
          CFI Block cfiCond147 Using cfiCommon0
          CFI (cfiCond147) Function zclProcessInWriteCmd
          CFI (cfiCond147) Conditional ??CrossCallReturnLabel_25, ??CrossCallReturnLabel_4
          CFI (cfiCond147) R4L Frame(CFA, -20)
          CFI (cfiCond147) R5L Frame(CFA, -18)
          CFI (cfiCond147) R6L Frame(CFA, -16)
          CFI (cfiCond147) R7L Frame(CFA, -14)
          CFI (cfiCond147) R8L Frame(CFA, -12)
          CFI (cfiCond147) R9L Frame(CFA, -10)
          CFI (cfiCond147) R10L Frame(CFA, -8)
          CFI (cfiCond147) R11L Frame(CFA, -6)
          CFI (cfiCond147) CFA SP+36
          CFI Block cfiCond148 Using cfiCommon0
          CFI (cfiCond148) Function zclProcessInWriteCmd
          CFI (cfiCond148) Conditional ??CrossCallReturnLabel_25, ??CrossCallReturnLabel_5
          CFI (cfiCond148) R4L Frame(CFA, -20)
          CFI (cfiCond148) R5L Frame(CFA, -18)
          CFI (cfiCond148) R6L Frame(CFA, -16)
          CFI (cfiCond148) R7L Frame(CFA, -14)
          CFI (cfiCond148) R8L Frame(CFA, -12)
          CFI (cfiCond148) R9L Frame(CFA, -10)
          CFI (cfiCond148) R10L Frame(CFA, -8)
          CFI (cfiCond148) R11L Frame(CFA, -6)
          CFI (cfiCond148) CFA SP+36
          CFI Block cfiPicker149 Using cfiCommon1
          CFI (cfiPicker149) NoFunction
          CFI (cfiPicker149) Picker
        MOV.W   R12, R13
        ADD.W   #0x6, R13
        MOV.B   0x14(R12), R12
        RETA
          CFI EndBlock cfiCond145
          CFI EndBlock cfiCond146
          CFI EndBlock cfiCond147
          CFI EndBlock cfiCond148
          CFI EndBlock cfiPicker149

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 4066 static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
zclProcessInReadCmd:
          CFI Block cfiBlock150 Using cfiCommon0
          CFI Function zclProcessInReadCmd
// 4067 {
        FUNCALL zclProcessInReadCmd, osal_mem_alloc
        LOCFRAME CSTACK, 28, STACK
        FUNCALL zclProcessInReadCmd, zclFindAttrRec
        LOCFRAME CSTACK, 28, STACK
        FUNCALL zclProcessInReadCmd, zclGetAuthorizeCB
        LOCFRAME CSTACK, 28, STACK
        FUNCALL zclProcessInReadCmd
        LOCFRAME CSTACK, 28, STACK
        FUNCALL zclProcessInReadCmd, zcl_SendReadRsp
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zclProcessInReadCmd, osal_mem_free
        LOCFRAME CSTACK, 34, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        SUB.W   #0x8, SP
          CFI CFA SP+28
        MOV.W   R12, R8
// 4068   zclReadCmd_t *readCmd;
// 4069   zclReadRspCmd_t *readRspCmd;
// 4070   zclAttrRec_t attrRec;
// 4071   uint16 len;
// 4072   uint8 i;
// 4073 
// 4074   readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
        MOV.W   0xc(R12), R7
// 4075 
// 4076   // calculate the length of the response status record
// 4077   len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
// 4078 
// 4079   readRspCmd = zcl_mem_alloc( len );
        MOV.B   @R7, R15
        MOV.W   #0x2, R12
        RPT     #0x6
        ADDX.W  R15, R12
        CALLA   #?Subroutine6
// 4080   if ( readRspCmd == NULL )
??CrossCallReturnLabel_1:
        JNE     ??zclProcessInReadCmd_2
// 4081   {
// 4082     return FALSE; // EMBEDDED RETURN
        MOV.B   #0x0, R12
        JMP     ??zclProcessInReadCmd_3
// 4083   }
// 4084 
// 4085   readRspCmd->numAttr = readCmd->numAttr;
??zclProcessInReadCmd_2:
        MOV.B   @R7, 0(R12)
// 4086   for ( i = 0; i < readCmd->numAttr; i++ )
        MOV.B   #0x0, R4
        JMP     ??zclProcessInReadCmd_4
// 4087   {
// 4088     zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
// 4089 
// 4090     statusRec->attrID = readCmd->attrID[i];
// 4091 
// 4092     if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 4093                          readCmd->attrID[i], &attrRec ) )
// 4094     {
// 4095       if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
// 4096       {
// 4097         statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
// 4098                                               &(pInMsg->msg->srcAddr), &attrRec );
// 4099         if ( statusRec->status == ZCL_STATUS_SUCCESS )
// 4100         {
// 4101           statusRec->data = attrRec.attr.dataPtr;
// 4102           statusRec->dataType = attrRec.attr.dataType;
// 4103         }
// 4104       }
// 4105       else
// 4106       {
// 4107         statusRec->status = ZCL_STATUS_WRITE_ONLY;
// 4108       }
// 4109     }
// 4110     else
// 4111     {
// 4112       statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
??zclProcessInReadCmd_0:
        MOV.B   #0x86, 0x2(R9)
// 4113     }
??zclProcessInReadCmd_1:
        ADD.B   #0x1, R4
??zclProcessInReadCmd_4:
        CMP.B   @R7, R4
        JC      ??zclProcessInReadCmd_5
        MOV.B   R4, R15
        MOV.W   R15, R11
        RPT     #0x5
        ADDX.W  R15, R11
        MOV.W   R6, R9
        ADD.W   R11, R9
        ADD.W   #0x2, R9
        RLA.W   R15
        MOV.W   R7, R11
        ADD.W   R15, R11
        ADD.W   #0x2, R11
        MOV.W   @R11, 0(R9)
        MOV.W   @R8, R10
        MOV.W   SP, R15
        ADD.W   #0x0, R15
        MOV.W   @R11, R14
        MOV.W   0x4(R10), R13
        MOV.B   0x14(R10), R12
        CALLA   #??Subroutine9_0
??CrossCallReturnLabel_42:
        JEQ     ??zclProcessInReadCmd_0
        BIT.B   #0x1, 0x5(SP)
        JNC     ??zclProcessInReadCmd_6
        MOV.W   @R8, R15
        MOV.W   R15, R5
        ADD.W   #0x6, R5
        BIT.B   #0x10, 0x5(SP)
        JNC     ??zclProcessInReadCmd_7
        MOV.B   0x14(R15), R12
        CALLA   #?Subroutine18
??CrossCallReturnLabel_26:
        JEQ     ??zclProcessInReadCmd_7
        MOV.B   #0x1, R14
        MOV.W   SP, R13
        ADD.W   #0x0, R13
        MOV.W   R5, R12
        CALLA   #?IndCallR11
        JMP     ??zclProcessInReadCmd_8
??zclProcessInReadCmd_7:
        MOV.B   #0x0, R12
??zclProcessInReadCmd_8:
        MOV.B   R12, 0x2(R9)
        CMP.B   #0x0, R12
        JNE     ??zclProcessInReadCmd_1
        MOV.W   0x6(SP), 0x4(R9)
        MOV.B   0x4(SP), 0x3(R9)
        JMP     ??zclProcessInReadCmd_1
??zclProcessInReadCmd_6:
        MOV.B   #0x8f, 0x2(R9)
        JMP     ??zclProcessInReadCmd_1
// 4114   }
// 4115 
// 4116   // Build and send Read Response command
// 4117   zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
// 4118                    readRspCmd, !pInMsg->hdr.fc.direction,
// 4119                    true, pInMsg->hdr.transSeqNum );
??zclProcessInReadCmd_5:
        MOV.W   @R8, R10
        PUSH.B  0x6(R8)
          CFI CFA SP+30
        PUSH.B  #0x1
          CFI CFA SP+32
        CALLA   #?Subroutine15
??CrossCallReturnLabel_22:
        PUSH.B  R14
          CFI CFA SP+34
        MOV.W   R6, R15
        MOV.W   0x4(R10), R14
        MOV.W   R10, R13
        ADD.W   #0x6, R13
        MOV.B   0x14(R10), R12
        CALLA   #zcl_SendReadRsp
// 4120   zcl_mem_free( readRspCmd );
        MOV.W   R6, R12
        CALLA   #osal_mem_free
// 4121 
// 4122   return TRUE;
        MOV.B   #0x1, R12
        ADD.W   #0x6, SP
          CFI CFA SP+28
??zclProcessInReadCmd_3:
        JMP     ?Subroutine0
        NOP
          CFI EndBlock cfiBlock150
// 4123 }
// 4124 #endif // ZCL_READ
// 4125 
// 4126 #ifdef ZCL_WRITE
// 4127 /*********************************************************************
// 4128  * @fn      processInWriteCmd
// 4129  *
// 4130  * @brief   Process the "Profile" Write and Write No Response Commands
// 4131  *
// 4132  * @param   pInMsg - incoming message to process
// 4133  *
// 4134  * @return  TRUE if command processed. FALSE, otherwise.
// 4135  */
// 4136 static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
// 4137 {
// 4138   zclWriteCmd_t *writeCmd;
// 4139   zclWriteRspCmd_t *writeRspCmd;
// 4140   uint8 sendRsp = FALSE;
// 4141   uint8 j = 0;
// 4142   uint8 i;
// 4143 
// 4144   writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
// 4145   if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
// 4146   {
// 4147     // We need to send a response back - allocate space for it
// 4148     writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
// 4149             + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
// 4150     if ( writeRspCmd == NULL )
// 4151     {
// 4152       return FALSE; // EMBEDDED RETURN
// 4153     }
// 4154 
// 4155     sendRsp = TRUE;
// 4156   }
// 4157 
// 4158   for ( i = 0; i < writeCmd->numAttr; i++ )
// 4159   {
// 4160     zclAttrRec_t attrRec;
// 4161     zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
// 4162 
// 4163     if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 4164                          statusRec->attrID, &attrRec ) )
// 4165     {
// 4166       if ( statusRec->dataType == attrRec.attr.dataType )
// 4167       {
// 4168         uint8 status;
// 4169 
// 4170         // Write the new attribute value
// 4171         if ( attrRec.attr.dataPtr != NULL )
// 4172         {
// 4173           status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 4174                                      &attrRec, statusRec );
// 4175         }
// 4176         else // Use CB
// 4177         {
// 4178           status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 4179                                             &attrRec, statusRec->attrData );
// 4180         }
// 4181 
// 4182         // If successful, a write attribute status record shall NOT be generated
// 4183         if ( sendRsp && status != ZCL_STATUS_SUCCESS )
// 4184         {
// 4185           // Attribute is read only - move on to the next write attribute record
// 4186           writeRspCmd->attrList[j].status = status;
// 4187           writeRspCmd->attrList[j++].attrID = statusRec->attrID;
// 4188         }
// 4189       }
// 4190       else
// 4191       {
// 4192         // Attribute data type is incorrect - move on to the next write attribute record
// 4193         if ( sendRsp )
// 4194         {
// 4195           writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
// 4196           writeRspCmd->attrList[j++].attrID = statusRec->attrID;
// 4197         }
// 4198       }
// 4199     }
// 4200     else
// 4201     {
// 4202       // Attribute is not supported - move on to the next write attribute record
// 4203       if ( sendRsp )
// 4204       {
// 4205         writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
// 4206         writeRspCmd->attrList[j++].attrID = statusRec->attrID;
// 4207       }
// 4208     }
// 4209   } // for loop
// 4210 
// 4211   if ( sendRsp )
// 4212   {
// 4213     writeRspCmd->numAttr = j;
// 4214     if ( writeRspCmd->numAttr == 0 )
// 4215     {
// 4216       // Since all records were written successful, include a single status record
// 4217       // in the resonse command with the status field set to SUCCESS and the
// 4218       // attribute ID field omitted.
// 4219       writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
// 4220       writeRspCmd->numAttr = 1;
// 4221     }
// 4222 
// 4223     zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 4224                       pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
// 4225                       true, pInMsg->hdr.transSeqNum );
// 4226     zcl_mem_free( writeRspCmd );
// 4227   }
// 4228 
// 4229   return TRUE;
// 4230 }
// 4231 
// 4232 /*********************************************************************
// 4233  * @fn      zclRevertWriteUndividedCmd
// 4234  *
// 4235  * @brief   Revert the "Profile" Write Undevided Command
// 4236  *
// 4237  * @param   pInMsg - incoming message to process
// 4238  * @param   curWriteRec - old data
// 4239  * @param   numAttr - number of attributes to be reverted
// 4240  *
// 4241  * @return  none
// 4242  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 4243 static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
zclRevertWriteUndividedCmd:
          CFI Block cfiBlock151 Using cfiCommon0
          CFI Function zclRevertWriteUndividedCmd
// 4244                                     zclWriteRec_t *curWriteRec, uint16 numAttr )
// 4245 {
        FUNCALL zclRevertWriteUndividedCmd, zclWriteAttrDataUsingCB
        LOCFRAME CSTACK, 24, STACK
        FUNCALL zclRevertWriteUndividedCmd, zclFindAttrRec
        LOCFRAME CSTACK, 24, STACK
        FUNCALL zclRevertWriteUndividedCmd, zclGetAttrDataLength
        LOCFRAME CSTACK, 24, STACK
        FUNCALL zclRevertWriteUndividedCmd, osal_memcpy
        LOCFRAME CSTACK, 24, STACK
        PUSHM.W #0x6, R11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
        SUB.W   #0x8, SP
          CFI CFA SP+24
        MOV.W   R12, R11
        MOV.W   R13, R8
        MOV.W   R14, R9
// 4246   uint8 i;
// 4247 
// 4248   for ( i = 0; i < numAttr; i++ )
        MOV.B   #0x0, R10
        JMP     ??zclRevertWriteUndividedCmd_2
// 4249   {
// 4250     zclAttrRec_t attrRec;
// 4251     zclWriteRec_t *statusRec = &(curWriteRec[i]);
// 4252 
// 4253     if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 4254                           statusRec->attrID, &attrRec ) )
// 4255     {
// 4256       break; // should never happen
// 4257     }
// 4258 
// 4259     if ( attrRec.attr.dataPtr != NULL )
// 4260     {
// 4261       // Just copy the old data back - no need to validate the data
// 4262       uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
// 4263       zcl_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
// 4264     }
// 4265     else // Use CB
// 4266     {
// 4267       // Write the old data back
// 4268       zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 4269                                &attrRec, statusRec->attrData );
??zclRevertWriteUndividedCmd_0:
        MOV.W   @R11, R6
        MOV.W   R13, R15
        MOV.W   SP, R14
        ADD.W   #0x0, R14
        MOV.W   R6, R13
        ADD.W   #0x6, R13
        MOV.B   0x14(R6), R12
        CALLA   #zclWriteAttrDataUsingCB
// 4270     }
??zclRevertWriteUndividedCmd_1:
        ADD.B   #0x1, R10
??zclRevertWriteUndividedCmd_2:
        CMP.W   R9, R10
        JC      ??zclRevertWriteUndividedCmd_3
        MOV.W   R10, R15
        RPT     #0x5
        ADDX.W  R10, R15
        MOV.W   R8, R6
        ADD.W   R15, R6
        MOV.W   @R11, R12
        MOV.W   SP, R15
        ADD.W   #0x0, R15
        MOV.W   @R6, R14
        CALLA   #??Subroutine28_0
??CrossCallReturnLabel_40:
        JEQ     ??zclRevertWriteUndividedCmd_3
        MOV.W   0x4(R6), R13
        MOV.W   0x6(SP), R7
        CMP.W   #0x0, R7
        JEQ     ??zclRevertWriteUndividedCmd_0
        MOV.B   0x4(SP), R12
        CALLA   #zclGetAttrDataLength
        MOV.W   R12, R14
        MOV.W   0x4(R6), R13
        MOV.W   R7, R12
        CALLA   #osal_memcpy
        JMP     ??zclRevertWriteUndividedCmd_1
// 4271   } // for loop
// 4272 }
??zclRevertWriteUndividedCmd_3:
        ADD.W   #0x8, SP
          CFI CFA SP+16
        POPM.W  #0x6, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock151
// 4273 
// 4274 /*********************************************************************
// 4275  * @fn      zclProcessInWriteUndividedCmd
// 4276  *
// 4277  * @brief   Process the "Profile" Write Undivided Command
// 4278  *
// 4279  * @param   pInMsg - incoming message to process
// 4280  *
// 4281  * @return  TRUE if command processed. FALSE, otherwise.
// 4282  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 4283 static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
zclProcessInWriteUndividedCmd:
          CFI Block cfiBlock152 Using cfiCommon0
          CFI Function zclProcessInWriteUndividedCmd
// 4284 {
        FUNCALL zclProcessInWriteUndividedCmd, osal_mem_alloc
        LOCFRAME CSTACK, 32, STACK
        FUNCALL zclProcessInWriteUndividedCmd, zclGetAttrDataLengthUsingCB
        LOCFRAME CSTACK, 32, STACK
        FUNCALL zclProcessInWriteUndividedCmd, zclFindAttrRec
        LOCFRAME CSTACK, 32, STACK
        FUNCALL zclProcessInWriteUndividedCmd, osal_mem_alloc
        LOCFRAME CSTACK, 32, STACK
        FUNCALL zclProcessInWriteUndividedCmd, osal_mem_free
        LOCFRAME CSTACK, 32, STACK
        FUNCALL zclProcessInWriteUndividedCmd, zclGetAttrDataLength
        LOCFRAME CSTACK, 32, STACK
        FUNCALL zclProcessInWriteUndividedCmd, zclFindAttrRec
        LOCFRAME CSTACK, 32, STACK
        FUNCALL zclProcessInWriteUndividedCmd, zclReadAttrData
        LOCFRAME CSTACK, 32, STACK
        FUNCALL zclProcessInWriteUndividedCmd, zclWriteAttrData
        LOCFRAME CSTACK, 32, STACK
        FUNCALL zclProcessInWriteUndividedCmd, zclReadAttrDataUsingCB
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zclProcessInWriteUndividedCmd, zclWriteAttrDataUsingCB
        LOCFRAME CSTACK, 34, STACK
        FUNCALL zclProcessInWriteUndividedCmd, zclRevertWriteUndividedCmd
        LOCFRAME CSTACK, 32, STACK
        FUNCALL zclProcessInWriteUndividedCmd, osal_mem_free
        LOCFRAME CSTACK, 32, STACK
        FUNCALL zclProcessInWriteUndividedCmd, zcl_SendWriteRsp
        LOCFRAME CSTACK, 38, STACK
        FUNCALL zclProcessInWriteUndividedCmd, osal_mem_free
        LOCFRAME CSTACK, 38, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        SUB.W   #0xc, SP
          CFI CFA SP+32
        MOV.W   R12, R8
// 4285   zclWriteCmd_t *writeCmd;
// 4286   zclWriteRspCmd_t *writeRspCmd;
// 4287   zclAttrRec_t attrRec;
// 4288   uint16 dataLen;
// 4289   uint16 curLen = 0;
        MOV.W   #0x0, R7
// 4290   uint8 j = 0;
        MOV.B   #0x0, R10
// 4291   uint8 i;
// 4292 
// 4293   writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
        MOV.W   0xc(R12), R5
// 4294 
// 4295   // Allocate space for Write Response Command
// 4296   writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
// 4297                    + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
        MOV.B   @R5, R12
        RLAM.W  #0x2, R12
        ADD.W   #0x2, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, R9
// 4298   if ( writeRspCmd == NULL )
        CMP.W   #0x0, R12
        JEQ     ??zclProcessInWriteUndividedCmd_6
// 4299   {
// 4300     return FALSE; // EMBEDDED RETURN
// 4301   }
// 4302 
// 4303   // If any attribute cannot be written, no attribute values are changed. Hence,
// 4304   // make sure all the attributes are supported and writable
// 4305   for ( i = 0; i < writeCmd->numAttr; i++ )
        MOV.B   #0x0, R11
        JMP     ??zclProcessInWriteUndividedCmd_9
// 4306   {
// 4307     zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
// 4308 
// 4309     if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 4310                           statusRec->attrID, &attrRec ) )
// 4311     {
// 4312       // Attribute is not supported - stop here
// 4313       writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
// 4314       writeRspCmd->attrList[j++].attrID = statusRec->attrID;
// 4315       break;
// 4316     }
// 4317 
// 4318     if ( statusRec->dataType != attrRec.attr.dataType )
// 4319     {
// 4320       // Attribute data type is incorrect - stope here
// 4321       writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
// 4322       writeRspCmd->attrList[j++].attrID = statusRec->attrID;
// 4323       break;
// 4324     }
// 4325 
// 4326     if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
// 4327     {
// 4328       // Attribute is not writable - stop here
// 4329       writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
// 4330       writeRspCmd->attrList[j++].attrID = statusRec->attrID;
// 4331       break;
// 4332     }
// 4333 
// 4334     if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
// 4335     {
// 4336       // Not authorized to write - stop here
// 4337       writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
// 4338       writeRspCmd->attrList[j++].attrID = statusRec->attrID;
// 4339       break;
// 4340     }
// 4341 
// 4342     // Attribute Data length
// 4343     if ( attrRec.attr.dataPtr != NULL )
// 4344     {
// 4345       dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
// 4346     }
// 4347     else // Use CB
// 4348     {
// 4349       dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 4350                                              statusRec->attrID );
??zclProcessInWriteUndividedCmd_1:
        MOV.W   @R8, R15
        MOV.W   @R6, R14
        MOV.W   0x4(R15), R13
        MOV.B   0x14(R15), R12
        CALLA   #zclGetAttrDataLengthUsingCB
??zclProcessInWriteUndividedCmd_17:
        MOV.W   R12, 0(SP)
// 4351     }
// 4352 
// 4353     // add padding if needed
// 4354     if ( PADDING_NEEDED( dataLen ) )
        CALLA   #?Subroutine7
??zclProcessInWriteUndividedCmd_9:
        CMP.B   @R5, R11
        JC      ??zclProcessInWriteUndividedCmd_0
        MOV.W   R11, R15
        RPT     #0x5
        ADDX.W  R11, R15
        MOV.W   R5, R6
        ADD.W   R15, R6
        ADD.W   #0x2, R6
        MOV.W   @R8, R4
        MOV.W   SP, R15
        ADD.W   #0x4, R15
        MOV.W   @R6, R14
        MOV.W   0x4(R4), R13
        MOV.B   0x14(R4), R12
        CALLA   #??Subroutine9_0
??CrossCallReturnLabel_41:
        JNE     ??zclProcessInWriteUndividedCmd_10
        MOV.B   #0x86, 0x2(R9)
??zclProcessInWriteUndividedCmd_4:
        MOV.W   @R6, 0x4(R9)
        MOV.B   #0x1, R10
// 4355     {
// 4356       dataLen++;
// 4357     }
// 4358 
// 4359     curLen += dataLen;
// 4360   } // for loop
// 4361 
// 4362   writeRspCmd->numAttr = j;
??zclProcessInWriteUndividedCmd_0:
        MOV.B   R10, 0(R9)
// 4363   if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
        CMP.B   #0x0, R10
        JNE     ??zclProcessInWriteUndividedCmd_11
// 4364   {
// 4365     uint8 *curDataPtr;
// 4366     zclWriteRec_t *curWriteRec;
// 4367 
// 4368     // calculate the length of the current data header
// 4369     uint8 hdrLen = j * sizeof( zclWriteRec_t );
        MOV.B   R10, R11
        RPT     #0x5
        ADDX.B  R10, R11
// 4370 
// 4371     // Allocate space to keep a copy of the current data
// 4372     curWriteRec = (zclWriteRec_t *) zcl_mem_alloc( hdrLen + curLen );
        MOV.B   R11, R12
        ADD.W   R7, R12
        CALLA   #?Subroutine6
// 4373     if ( curWriteRec == NULL )
??CrossCallReturnLabel_0:
        JNE     ??zclProcessInWriteUndividedCmd_12
// 4374     {
// 4375       zcl_mem_free(writeRspCmd );
        MOV.W   R9, R12
        CALLA   #osal_mem_free
// 4376       return FALSE; // EMBEDDED RETURN
??zclProcessInWriteUndividedCmd_6:
        MOV.B   #0x0, R12
        JMP     ??zclProcessInWriteUndividedCmd_13
// 4377     }
??zclProcessInWriteUndividedCmd_10:
        MOV.B   0x8(SP), R12
        CMP.B   R12, 0x2(R6)
        JEQ     ??zclProcessInWriteUndividedCmd_14
        MOV.B   #0x8d, 0x2(R9)
        JMP     ??zclProcessInWriteUndividedCmd_4
??zclProcessInWriteUndividedCmd_14:
        BIT.B   #0x2, 0x9(SP)
        JC      ??zclProcessInWriteUndividedCmd_15
        MOV.B   #0x88, 0x2(R9)
        JMP     ??zclProcessInWriteUndividedCmd_4
??zclProcessInWriteUndividedCmd_15:
        BIT.B   #0x20, 0x9(SP)
        JNC     ??zclProcessInWriteUndividedCmd_16
        MOV.B   #0x7e, 0x2(R9)
        JMP     ??zclProcessInWriteUndividedCmd_4
??zclProcessInWriteUndividedCmd_16:
        MOV.W   0xa(SP), R13
        CMP.W   #0x0, R13
        JEQ     ??zclProcessInWriteUndividedCmd_1
        CALLA   #zclGetAttrDataLength
        JMP     ??zclProcessInWriteUndividedCmd_17
// 4378 
// 4379     curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
??zclProcessInWriteUndividedCmd_12:
        MOV.B   R11, R11
        MOV.W   R12, R7
        ADD.W   R11, R7
// 4380 
// 4381     // Write the new data over
// 4382     for ( i = 0; i < writeCmd->numAttr; i++ )
        MOV.B   #0x0, R11
        JMP     ??zclProcessInWriteUndividedCmd_18
// 4383     {
// 4384       uint8 status;
// 4385       zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
// 4386       zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
// 4387 
// 4388       if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 4389                             statusRec->attrID, &attrRec ) )
// 4390       {
// 4391         break; // should never happen
// 4392       }
// 4393 
// 4394       // Keep a copy of the current data before before writing the new data over
// 4395       curStatusRec->attrID = statusRec->attrID;
// 4396       curStatusRec->attrData = curDataPtr;
// 4397 
// 4398       if ( attrRec.attr.dataPtr != NULL )
// 4399       {
// 4400         // Read the current value
// 4401         zclReadAttrData( curDataPtr, &attrRec, &dataLen );
// 4402 
// 4403         // Write the new attribute value
// 4404         status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 4405                                    &attrRec, statusRec );
// 4406       }
// 4407       else // Use CBs
// 4408       {
// 4409         // Read the current value
// 4410         zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 4411                                 statusRec->attrID, curDataPtr, &dataLen );
// 4412         // Write the new attribute value
// 4413         status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 4414                                           &attrRec, statusRec->attrData );
// 4415       }
// 4416 
// 4417       // If successful, a write attribute status record shall NOT be generated
// 4418       if ( status != ZCL_STATUS_SUCCESS )
// 4419       {
// 4420         writeRspCmd->attrList[j].status = status;
// 4421         writeRspCmd->attrList[j++].attrID = statusRec->attrID;
// 4422 
// 4423         // Since this write failed, we need to revert all the pervious writes
// 4424         zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
// 4425         break;
// 4426       }
// 4427 
// 4428       // add padding if needed
// 4429       if ( PADDING_NEEDED( dataLen ) )
??zclProcessInWriteUndividedCmd_3:
        CALLA   #?Subroutine7
??zclProcessInWriteUndividedCmd_18:
        CMP.B   @R5, R11
        JC      ??zclProcessInWriteUndividedCmd_19
        MOV.W   R11, R15
        RPT     #0x5
        ADDX.W  R11, R15
        MOV.W   R5, R4
        ADD.W   R15, R4
        ADD.W   #0x2, R4
        MOV.W   R6, R14
        ADD.W   R15, R14
        MOV.W   R14, 0x2(SP)
        MOV.W   @R8, R12
        MOV.W   SP, R15
        ADD.W   #0x4, R15
        CALLA   #?Subroutine9
??CrossCallReturnLabel_38:
        JEQ     ??zclProcessInWriteUndividedCmd_19
        MOV.W   0x2(SP), R15
        MOV.W   @R4, 0(R15)
        MOV.W   0x2(SP), R15
        MOV.W   R7, 0x4(R15)
        CMP.W   #0x0, 0xa(SP)
        JEQ     ??zclProcessInWriteUndividedCmd_20
        MOV.W   SP, R14
        ADD.W   #0x0, R14
        MOV.W   SP, R13
        ADD.W   #0x4, R13
        MOV.W   R7, R12
        CALLA   #zclReadAttrData
        MOV.W   @R8, R12
        MOV.W   R4, R15
        CALLA   #?Subroutine22
??CrossCallReturnLabel_24:
        CALLA   #zclWriteAttrData
        JMP     ??zclProcessInWriteUndividedCmd_21
??zclProcessInWriteUndividedCmd_20:
        MOV.W   @R8, R12
        MOV.W   SP, R15
        ADD.W   #0x0, R15
        PUSH.W  R15
          CFI CFA SP+34
        MOV.W   R7, R15
        MOV.W   @R4, R14
        MOV.W   0x4(R12), R13
        MOV.B   0x14(R12), R12
        CALLA   #zclReadAttrDataUsingCB
        MOV.W   @R8, R12
        MOV.W   0x4(R4), R15
        MOV.W   SP, R14
        ADD.W   #0x6, R14
        CALLA   #??Subroutine24_0
??CrossCallReturnLabel_23:
        CALLA   #zclWriteAttrDataUsingCB
        ADD.W   #0x2, SP
          CFI CFA SP+32
??zclProcessInWriteUndividedCmd_21:
        CMP.B   #0x0, R12
        JEQ     ??zclProcessInWriteUndividedCmd_3
        MOV.B   R10, R7
        RLAM.W  #0x2, R7
        MOV.W   R9, R15
        ADD.W   R7, R15
        MOV.B   R12, 0x2(R15)
        MOV.W   @R4, 0x4(R15)
        ADD.B   #0x1, R10
        MOV.B   R11, R14
        MOV.W   R6, R13
        MOV.W   R8, R12
        CALLA   #zclRevertWriteUndividedCmd
// 4430       {
// 4431         dataLen++;
// 4432       }
// 4433 
// 4434       curDataPtr += dataLen;
// 4435     } // for loop
// 4436 
// 4437     writeRspCmd->numAttr = j;
??zclProcessInWriteUndividedCmd_19:
        MOV.B   R10, 0(R9)
// 4438     if ( writeRspCmd->numAttr  == 0 )
        CMP.B   #0x0, R10
        JNE     ??zclProcessInWriteUndividedCmd_22
// 4439     {
// 4440       // Since all records were written successful, include a single status record
// 4441       // in the resonse command with the status field set to SUCCESS and the
// 4442       // attribute ID field omitted.
// 4443       writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
        MOV.B   #0x0, 0x2(R9)
// 4444       writeRspCmd->numAttr = 1;
        MOV.B   #0x1, 0(R9)
// 4445     }
// 4446 
// 4447     zcl_mem_free( curWriteRec );
??zclProcessInWriteUndividedCmd_22:
        MOV.W   R6, R12
        CALLA   #osal_mem_free
// 4448   }
// 4449 
// 4450   zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 4451                     pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
// 4452                     true, pInMsg->hdr.transSeqNum );
??zclProcessInWriteUndividedCmd_11:
        MOV.W   @R8, R11
        PUSH.B  0x6(R8)
          CFI CFA SP+34
        PUSH.B  #0x1
          CFI CFA SP+36
        CALLA   #?Subroutine15
??CrossCallReturnLabel_21:
        PUSH.B  R14
          CFI CFA SP+38
        MOV.W   R9, R15
        CALLA   #?Subroutine16
??CrossCallReturnLabel_8:
        CALLA   #zcl_SendWriteRsp
// 4453   zcl_mem_free( writeRspCmd );
        MOV.W   R9, R12
        CALLA   #osal_mem_free
// 4454 
// 4455   return TRUE;
        MOV.B   #0x1, R12
        ADD.W   #0x6, SP
          CFI CFA SP+32
??zclProcessInWriteUndividedCmd_13:
        ADD.W   #0xc, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock152
// 4456 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine7:
          CFI Block cfiCond153 Using cfiCommon0
          CFI Function zclProcessInWriteUndividedCmd
          CFI Conditional ??zclProcessInWriteUndividedCmd_9
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+36
          CFI Block cfiCond154 Using cfiCommon0
          CFI (cfiCond154) Function zclProcessInWriteUndividedCmd
          CFI (cfiCond154) Conditional ??zclProcessInWriteUndividedCmd_18
          CFI (cfiCond154) R4L Frame(CFA, -20)
          CFI (cfiCond154) R5L Frame(CFA, -18)
          CFI (cfiCond154) R6L Frame(CFA, -16)
          CFI (cfiCond154) R7L Frame(CFA, -14)
          CFI (cfiCond154) R8L Frame(CFA, -12)
          CFI (cfiCond154) R9L Frame(CFA, -10)
          CFI (cfiCond154) R10L Frame(CFA, -8)
          CFI (cfiCond154) R11L Frame(CFA, -6)
          CFI (cfiCond154) CFA SP+36
          CFI Block cfiPicker155 Using cfiCommon1
          CFI (cfiPicker155) NoFunction
          CFI (cfiPicker155) Picker
        BIT.W   #0x1, 0x4(SP)
        JNC     ??zclProcessInWriteUndividedCmd_7
        MOV.W   0x4(SP), R15
        ADD.W   #0x1, R15
        MOV.W   R15, 0x4(SP)
??zclProcessInWriteUndividedCmd_7:
        ADD.W   0x4(SP), R7
        ADD.B   #0x1, R11
        RETA
          CFI EndBlock cfiCond153
          CFI EndBlock cfiCond154
          CFI EndBlock cfiPicker155

        RSEG DATA16_ID:CONST:SORT:NOROOT(0)
`?<Initializer for zcl_RegisteredMsgTaskID>`:
        DC8 255

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// 4457 #endif // ZCL_WRITE
// 4458 
// 4459 #ifdef ZCL_DISCOVER
// 4460 /*********************************************************************
// 4461  * @fn      zclProcessInDiscAttrs
// 4462  *
// 4463  * @brief   Process the "Profile" Discover Attributes Commands
// 4464  *
// 4465  * @param   pInMsg - incoming message to process
// 4466  *
// 4467  * @return  TRUE if command processed. FALSE, otherwise.
// 4468  */
// 4469 static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
// 4470 {
// 4471   zclDiscoverAttrsCmd_t *pDiscoverCmd;
// 4472   zclAttrRec_t attrRec;
// 4473   uint16 attrID;
// 4474   uint8 numAttrs;
// 4475   uint8 i;
// 4476 
// 4477   pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
// 4478 
// 4479   // Find out the number of attributes supported within the specified range
// 4480   for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
// 4481   {
// 4482     // finds the next attribute on this endpoint/cluster after the range.
// 4483     // attributes must be in numerical order in the list.
// 4484     if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
// 4485     {
// 4486       break;
// 4487     }
// 4488   }
// 4489 
// 4490   numAttrs = i;  // store range of attributes in buffer
// 4491 
// 4492     // Process message for either attributes or extended attributes
// 4493   if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
// 4494   {
// 4495     zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
// 4496   }
// 4497   else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
// 4498   {
// 4499     zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
// 4500   }
// 4501 
// 4502   return TRUE;
// 4503 }
// 4504 
// 4505 /*********************************************************************
// 4506  * @fn      zclProcessInDiscAttrsCmd
// 4507  *
// 4508  * @brief   Process the Discover Attributes Command
// 4509  *
// 4510  * @param   pInMsg - incoming message to process
// 4511  *
// 4512  * @param   pDiscoverCmd - structure from requesting command
// 4513  *
// 4514  * @param   attrLenBuf - describes the amount of attributes to be processed
// 4515  *
// 4516  * @return  none
// 4517  */
// 4518 static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
// 4519 {
// 4520   zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
// 4521   uint8 discComplete = TRUE;
// 4522   zclAttrRec_t attrRec;
// 4523   uint16 attrID;
// 4524   uint8 i;
// 4525 
// 4526   // Allocate space for the response command
// 4527   pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
// 4528                                                           + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
// 4529   if ( pDiscoverRsp == NULL )
// 4530   {
// 4531     return; // EMEDDED RETURN
// 4532   }
// 4533 
// 4534   if ( numAttrs != 0 )
// 4535   {
// 4536     for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
// 4537     {
// 4538       if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
// 4539       {
// 4540         break; // should not happen, as numAttrs already calculated
// 4541       }
// 4542 
// 4543       pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
// 4544       pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
// 4545     }
// 4546 
// 4547     // Are there more attributes to be discovered?
// 4548     if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
// 4549     {
// 4550       discComplete = FALSE;
// 4551     }
// 4552   }
// 4553 
// 4554   pDiscoverRsp->discComplete = discComplete;
// 4555   pDiscoverRsp->numAttr = numAttrs;
// 4556 
// 4557   zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 4558                                pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
// 4559                                true, pInMsg->hdr.transSeqNum );
// 4560   zcl_mem_free( pDiscoverRsp );
// 4561 
// 4562   return;
// 4563 }
// 4564 
// 4565 /*********************************************************************
// 4566  * @fn      zclProcessInDiscAttrsExtCmd
// 4567  *
// 4568  * @brief   Process the Discover Attributes Extended Command
// 4569  *
// 4570  * @param   pInMsg - incoming message to process
// 4571  *
// 4572  * @param   pDiscoverCmd - structure from requesting command
// 4573  *
// 4574  * @param   attrLenBuf - describes the amount of attributes to be processed
// 4575  *
// 4576  * @return  none
// 4577  */
// 4578 static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
// 4579 {
// 4580   zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
// 4581   uint8 discComplete = TRUE;
// 4582   zclAttrRec_t attrRec;
// 4583   uint16 attrID;
// 4584   uint8 i;
// 4585 
// 4586     // Allocate space for the response command
// 4587   pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
// 4588                                                          + sizeof ( zclExtAttrInfo_t ) * numAttrs );
// 4589   if ( pDiscoverExtRsp == NULL )
// 4590   {
// 4591     return; // EMEDDED RETURN
// 4592   }
// 4593 
// 4594 
// 4595   if ( numAttrs != 0 )
// 4596   {
// 4597     for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
// 4598     {
// 4599       if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
// 4600       {
// 4601         break; // Should not happen, as numAttrs already calculated
// 4602       }
// 4603 
// 4604       pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
// 4605       pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
// 4606       pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
// 4607     }
// 4608 
// 4609     // Are there more attributes to be discovered?
// 4610     if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
// 4611     {
// 4612       discComplete = FALSE;
// 4613     }
// 4614   }
// 4615 
// 4616   pDiscoverExtRsp->discComplete = discComplete;
// 4617   pDiscoverExtRsp->numAttr = numAttrs;
// 4618 
// 4619   zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 4620                                pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
// 4621                                true, pInMsg->hdr.transSeqNum );
// 4622 
// 4623   zcl_mem_free( pDiscoverExtRsp );
// 4624 
// 4625   return;
// 4626 }
// 4627 
// 4628 /*********************************************************************
// 4629  * @fn      zclProcessInDiscCmd
// 4630  *
// 4631  * @brief   Process the "Profile" Discover Command
// 4632  *
// 4633  * @param   pInMsg - incoming message to process
// 4634  *
// 4635  * @return  TRUE if command processed. FALSE, otherwise.
// 4636  */
// 4637 static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
// 4638 {
// 4639   zclDiscoverCmdsCmd_t *pDiscoverCmd;
// 4640   zclDiscoverCmdsCmdRsp_t cmdRsp;
// 4641   ZStatus_t status;
// 4642   zclCommandRec_t cmdRec;
// 4643   uint8 cmdID;
// 4644   uint8 i;
// 4645   uint8 j;
// 4646 
// 4647   pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
// 4648 
// 4649   // Find out the number of commands supported within the specified range
// 4650   for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
// 4651   {
// 4652     if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
// 4653     {
// 4654       break;  // Command not supported
// 4655     }
// 4656   }
// 4657 
// 4658   // Allocate space for the response command
// 4659   cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
// 4660 
// 4661   if ( cmdRsp.pCmdID == NULL )
// 4662   {
// 4663     return FALSE; // EMEDDED RETURN
// 4664   }
// 4665 
// 4666   if ( i != 0 )
// 4667   {
// 4668     for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
// 4669     {
// 4670       if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
// 4671       {
// 4672         break; // Attribute not supported
// 4673       }
// 4674 
// 4675       cmdRsp.pCmdID[j] = cmdRec.cmdID;
// 4676     }
// 4677   }
// 4678 
// 4679   // Are there more commands to be discovered?
// 4680   if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
// 4681   {
// 4682     cmdRsp.discComplete = FALSE;
// 4683   }
// 4684   else
// 4685   {
// 4686     cmdRsp.discComplete = TRUE;
// 4687   }
// 4688 
// 4689   // pass the command requested
// 4690   cmdRsp.cmdType = pInMsg->hdr.commandID;
// 4691 
// 4692   // store number of commands returned
// 4693   cmdRsp.numCmd = j;
// 4694 
// 4695   status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 4696                                       pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
// 4697                                       true, pInMsg->hdr.transSeqNum );
// 4698 
// 4699   zcl_mem_free( cmdRsp.pCmdID );
// 4700 
// 4701   if ( status == ZSuccess )
// 4702   {
// 4703     return TRUE;
// 4704   }
// 4705   else
// 4706   {
// 4707     return FALSE;
// 4708   }
// 4709 }
// 4710 
// 4711 #endif // ZCL_DISCOVER
// 4712 
// 4713 /*********************************************************************
// 4714 *********************************************************************/
// 
// 5 290 bytes in segment CODE
//   184 bytes in segment DATA16_C
//     1 byte  in segment DATA16_I
//     1 byte  in segment DATA16_ID
//    15 bytes in segment DATA16_Z
// 
// 5 290 bytes of CODE  memory
//   185 bytes of CONST memory
//    16 bytes of DATA  memory
//
//Errors: none
//Warnings: none
